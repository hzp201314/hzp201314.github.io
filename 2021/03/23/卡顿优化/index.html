<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>卡顿优化 | Hzp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言在上篇，笔者详细分析了目前的App绘制与布局优化的相关优化方案，如果对绘制优化与布局优化还不是非常熟悉的可以仔细看看前几篇文章：Android性能优化之绘制优化、深入探索Android布局优化。由于卡顿优化这一主题包含的内容太多，为了更详细地进行讲解，因此，笔者将它分为了上、下两篇。本篇，即为《深入探索Android卡顿优化》的上篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="卡顿优化">
<meta property="og:url" content="https://hzp201314.github.io/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hzp&#39;s Blog">
<meta property="og:description" content="前言在上篇，笔者详细分析了目前的App绘制与布局优化的相关优化方案，如果对绘制优化与布局优化还不是非常熟悉的可以仔细看看前几篇文章：Android性能优化之绘制优化、深入探索Android布局优化。由于卡顿优化这一主题包含的内容太多，为了更详细地进行讲解，因此，笔者将它分为了上、下两篇。本篇，即为《深入探索Android卡顿优化》的上篇。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-4e8496ebc31551e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-8dbd16242b9e751e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-84ec8cef45120e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-ad808f5f1a791910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-03-23T08:26:10.000Z">
<meta property="article:modified_time" content="2021-03-23T08:30:08.737Z">
<meta property="article:author" content="Hzp">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/14601315-4e8496ebc31551e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hzp's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hzp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hzp201314.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-卡顿优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-03-23T08:26:10.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      卡顿优化
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇，笔者详细分析了目前的App绘制与布局优化的相关优化方案，如果对绘制优化与布局优化还不是非常熟悉的可以仔细看看前几篇文章：<a href="">Android性能优化之绘制优化</a>、<a href="">深入探索Android布局优化</a>。由于卡顿优化这一主题包含的内容太多，为了更详细地进行讲解，因此，笔者将它分为了上、下两篇。本篇，即为《深入探索Android卡顿优化》的上篇。</p>
<span id="more"></span>

<p>本篇包含的主要内容如下所示：</p>
<ul>
<li>  1、卡顿优化分析方法与工具</li>
<li>  2、自动化卡顿检测方案及优化</li>
</ul>
<p>在我们使用各种各样的App的时候，有时会看见有些App运行起来并不流畅，即出现了卡顿现象，<strong>那么如何去定义发生了卡顿现象呢？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果App的FPS平均值小于30，最小值小于24，即表明应用发生了卡顿。</span><br></pre></td></tr></table></figure>

<p>那我么又如何去分析应用是否出现了卡顿呢？下面，我们就先来了解一下解决卡顿问题时需要用到的分析方法与工具。</p>
<h1 id="一、卡顿优化分析方法与工具"><a href="#一、卡顿优化分析方法与工具" class="headerlink" title="一、卡顿优化分析方法与工具"></a>一、卡顿优化分析方法与工具</h1><h2 id="1、背景介绍"><a href="#1、背景介绍" class="headerlink" title="1、背景介绍"></a>1、背景介绍</h2><ul>
<li>  很多性能问题不易被发现，但是卡顿问题很容易被直观感受。</li>
<li>  卡顿问题难以定位。</li>
</ul>
<h3 id="那么卡顿问题到底难在哪里呢？"><a href="#那么卡顿问题到底难在哪里呢？" class="headerlink" title="那么卡顿问题到底难在哪里呢？"></a>那么卡顿问题到底难在哪里呢？</h3><ul>
<li>  1、卡顿产生的原因是错综复杂的，它涉及到代码、内存、绘制、IO、CPU等等。</li>
<li>  2、线上的卡顿问题在线下是很难复现的，因为它与当时的场景是强相关的，比如说线上用户的磁盘IO空间不足了，它影响了磁盘IO的写入性能，所以导致卡顿。针对这种问题，我们最好<strong>在发现卡顿的时候尽量地去记录用户当时发生卡顿时的具体的场景信息</strong>。</li>
</ul>
<h2 id="2、卡顿分析方法之使用shell命令分析CPU耗时"><a href="#2、卡顿分析方法之使用shell命令分析CPU耗时" class="headerlink" title="2、卡顿分析方法之使用shell命令分析CPU耗时"></a>2、卡顿分析方法之使用shell命令分析CPU耗时</h2><p>尽管造成卡顿的原因有很多种，不过最终都会反映到CPU时间上。</p>
<p>CPU时间包含用户时间和系统时间。</p>
<ul>
<li>  用户时间：执行用户态应用程序代码所消耗的时间。</li>
<li>  系统时间：执行内核态系统调用所消耗的时间，<strong>包括I/O、锁、中断和其它系统调用所消耗的时间。</strong></li>
</ul>
<p>CPU的问题大致可以分为以下三类：</p>
<p><strong>1、CPU资源冗余使用</strong></p>
<ul>
<li>  <strong>算法效率太低</strong>：明明可以遍历一次的却需要去遍历两次，<strong>主要出现在查找、排序、删除等环节。</strong></li>
<li>  <strong>没有使用cache</strong>：明明解码过一次的图片还去重复解码。</li>
<li>  <strong>计算时使用的基本类型不对：明明使用int就足够，却要使用long，这会导致CPU的运算压力多出4倍。</strong></li>
</ul>
<p><strong>2、CPU资源争抢</strong></p>
<ul>
<li>  <strong>抢主线程的CPU资源</strong>：这是最常见的问题，并且在Android 6.0版本之前没有renderthread的时候，主线程的繁忙程度就决定了是否会引发用户的卡顿问题。</li>
<li>  <strong>抢音视频的CPU资源</strong>：音视频编解码本身会消耗大量的CPU资源，并且其对于解码的速度是有硬性要求的，如果达不到就可能产生播放流畅度的问题。我们可以<strong>采取两种方式去优化：1、尽量排除非核心业务的消耗。2、优化自身的性能消耗，把CPU负载转化为GPU负载，如使用renderscript来处理视频中的影像信息。</strong></li>
<li>  <strong>大家平等，互相抢</strong>：比如在自定义的相册中，我开了20个线程做图片解码，那就是互相抢CPU了，结果就是会导致图片的显示速度非常慢。这简直就是三个和尚没水喝的典型案例。因此，在自定义线程池的时候我们需要按照系统核心数去控制线程数。</li>
</ul>
<p><strong>3、CPU资源利用率低</strong></p>
<p>对于启动、界面切换、音视频编解码这些场景，为了保证其速度，我们需要去好好利用CPU。<strong>而导致无法充分利用CPU的因素，不仅有磁盘和网络I/O，还有锁操作、sleep等等。对于锁的优化，通常是尽可能地缩减锁的范围。</strong></p>
<h3 id="1、了解CPU-性能"><a href="#1、了解CPU-性能" class="headerlink" title="1、了解CPU 性能"></a>1、了解CPU 性能</h3><p>我们可以通过CPU的<strong>主频、核心数、缓存</strong>等参数去评估CPU的性能，这些参数的好坏能表现出<strong>CPU计算能力和指令执行能力的强弱</strong>，也就是<strong>CPU每秒执行的浮点计算数和每秒执行的指令数的多少</strong>。</p>
<p>此外，现在最新的主流机型都使用了<strong>多级能效的CPU架构（即多核分层架构）</strong>，以确保在平常低负荷工作时能仅使用低频核心来节省电量。</p>
<p>并且，我们还可以通过shell命令直接查看手机的CPU核心数与频率等信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先输入adb shell进入手机的shell环境</span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 CPU 核心数，我的手机是8核</span><br><span class="line">platina:&#x2F; $ cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br><span class="line">0-7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取第一个 CPU 的最大频率</span><br><span class="line">platina:&#x2F; $ cat</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq                         &lt;</span><br><span class="line">1843200</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取第二个CPU的最小频率</span><br><span class="line">platina:&#x2F; $ cat</span><br><span class="line">&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu1&#x2F;cpufreq&#x2F;cpuinfo_min_freq                         &lt;</span><br><span class="line">633600</span><br></pre></td></tr></table></figure>

<p>从 CPU 到 GPU 再到 AI 芯片（如专为神经网络计算打造的 NPU（Neural network Processing Unit）），随着手机 CPU 整体性能的飞跃，医疗诊断、图像超清化等一些 AI 应用场景也可以在移动端更好地落地。我们可以<strong>充分利用移动端的计算能力来降低高昂的服务器成本。</strong></p>
<p>此外，CPU的性能越好，应用就能获得更好的支持，如线程池可以根据不同手机的CPU核心数来配备不同的线程数、<strong>仅在手机主频比较高或者带有NPU的设备去开启一些高级的AI功能</strong>。</p>
<h3 id="2、通过读取-proc-stat与-proc-PID-stat文件来计算并评估系统的CPU耗时情况"><a href="#2、通过读取-proc-stat与-proc-PID-stat文件来计算并评估系统的CPU耗时情况" class="headerlink" title="2、通过读取/proc/stat与/proc/[PID]/stat文件来计算并评估系统的CPU耗时情况"></a>2、通过读取/proc/stat与/proc/[PID]/stat文件来计算并评估系统的CPU耗时情况</h3><p>当应用出现卡顿问题之后，首先我们应该查看系统CPU的使用率。</p>
<p>首先，我们通过<strong>读取 /proc/stat 文件获取总的 CPU 时间</strong>，并<strong>读取 /proc/[PID]/stat 获取应用进程 的CPU 时间</strong>，然后，<strong>采样两个足够短的时间间隔的 CPU 快照与进程快照来计算其 CPU 使用率</strong>。</p>
<h4 id="计算总的-CPU-使用率"><a href="#计算总的-CPU-使用率" class="headerlink" title="计算总的 CPU 使用率"></a>计算总的 CPU 使用率</h4><p>1、采样两个足够短的时间间隔的 CPU 快照，即需要前后两次去读取 /proc/stat 文件，获取两个时间点对应的数据，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次采样</span><br><span class="line">platina:&#x2F; $ cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0</span><br><span class="line">cpu0 2244962 280573 2667000 22414199 99651 231869 439918 0 0 0</span><br><span class="line">cpu1 2672378 421880 2943791 21540302 121818 236850 438733 0 0 0</span><br><span class="line">cpu2 1648512 76856 1431036 25868789 46970 107094 52025 0 0 0</span><br><span class="line">cpu3 1418757 41280 1397203 25772984 40292 110168 41667 0 0 0</span><br><span class="line">cpu4 573203 79498 178263 19618235 9577 307949 10875 0 0 0</span><br><span class="line">cpu5 522638 67978 155454 19684358 8793 19787 4603 0 0 0</span><br><span class="line">cpu6 458438 64085 132252 19749439 8143 19942 98241 0 0 0</span><br><span class="line">cpu7 392663 49951 97535 19814735 5703 26779 2916 0 0 0</span><br><span class="line">intr...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二次采样</span><br><span class="line">platina:&#x2F; $ cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  9931673 1082113 9002679 174466561 340954 1060446 1088994 0 0 0</span><br><span class="line">cpu0 2244999 280578 2667032 22414604 99653 231869 439918 0 0 0</span><br><span class="line">cpu1 2672434 421881 2943861 21540606 121822 236855 438747 0 0 0</span><br><span class="line">cpu2 1648525 76859 1431054 25869234 46971 107095 52026 0 0 0</span><br><span class="line">cpu3 1418773 41283 1397228 25773412 40292 110170 41668 0 0 0</span><br><span class="line">cpu4 573203 79498 178263 19618720 9577 307949 10875 0 0 0</span><br><span class="line">cpu5 522638 67978 155454 19684842 8793 19787 4603 0 0 0</span><br><span class="line">cpu6 458438 64085 132252 19749923 8143 19942 98241 0 0 0</span><br><span class="line">cpu7 392663 49951 97535 19815220 5703 26779 2916 0 0 0</span><br><span class="line">int...    </span><br></pre></td></tr></table></figure>

<p>因为我的手机是8核，所以这里的cpu个数是8个，从cpu0到cpu7，<strong>第一行的cpu即是8个cpu的指标数据汇总</strong>，因为是要计算系统cpu的使用率，那当然应该以cpu为基准了。两次采样的CPU指标数据如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu1  9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0</span><br><span class="line">cpu2  9931673 1082113 9002679 174466561 340954 1060446 1088994 0 0 0</span><br></pre></td></tr></table></figure>

<p>其对应的各项指标如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU (user, nice, system, idle, iowait, irq, softirq, stealstolen, guest);</span><br></pre></td></tr></table></figure>

<p>拿cpu1（9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0）的数据来说，下面，我就来详细地解释下这些指标的含义。</p>
<ul>
<li>  user(9931551)： 表示从<strong>系统启动开始至今处于用户态的运行时间</strong>，注意<strong>不包含 nice 值为负的进程</strong>。</li>
<li>  nice(1082101) ：表示<strong>从系统启动开始至今nice 值为负的进程所占用的 CPU 时间</strong>。</li>
<li>  system(9002534)： 表示<strong>从系统启动开始至今处于内核态的运行时间</strong>。</li>
<li>  idle(174463041) ：表示<strong>从系统启动开始至今除 IO 等待时间以外的其他等待时间</strong>。</li>
<li>  iowait(340947)：表示<strong>从系统启动开始至今的IO 等待时间</strong>。(从Linux V2.5.41开始包含)</li>
<li>  irq(1060438)：表示<strong>从系统启动开始至今的硬中断时间</strong>。(从Linux V2.6.0-test4开始包含)</li>
<li>  softirq(1088978)：表示<strong>从系统启动开始至今的软中断时间</strong>。(从Linux V2.6.0-test4开始包含)</li>
<li>  stealstolen(0) ：表示当在虚拟化环境中运行时在其他操作系统中所花费的时间。在Android系统下此值为0。(从Linux V2.6.11开始包含)</li>
<li>  guest(0) ：表示当在Linux内核的控制下为其它操作系统运行虚拟CPU所花费的时间。在Android系统下此值为0。(从 V2.6.24开始包含)</li>
</ul>
<p>此外，这些数值的单位都是 jiffies，<strong>jiffies 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 Linux 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 Linux 系统内核中的这个值可能不同，通常在 1ms 到 10ms 之间</strong>。</p>
<p>了解了/proc/stat命令下各项参数的含义之后，我们就可以由前后两次时间点的CPU数据计算得到cpu1与cpu2的活动时间，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">totalCPUTime &#x3D; user + nice + system + idle + iowait + irq + softirq + stealstolen + guest </span><br><span class="line">cpu1 &#x3D; 9931551 + 1082101 + 9002534 +  174463041 + 340947 + 1060438 + 1088978 + 0  + 0 + 0 &#x3D; 196969590jiffies</span><br><span class="line">cpu2 &#x3D; 9931673 + 1082113 + 9002679 +  174466561 + 340954 + 1060446 + 1088994 + 0 + 0 + 0 &#x3D; 196973420jiffies</span><br></pre></td></tr></table></figure>

<p>因此可得出总的CPU时间，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">totalCPUTime &#x3D; CPU2 – CPU1 &#x3D; 3830jiffies</span><br></pre></td></tr></table></figure>

<p>最后，我们就可以计算出<strong>系统CPU的使用率</strong>：：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先计算得到CPU的空闲时间</span><br><span class="line">idleCPUTime &#x3D; idle2 – idle1 &#x3D; 3520jiffies</span><br><span class="line">&#x2F;&#x2F; 最后得到系统CPU的使用率</span><br><span class="line">totalCPUUse &#x3D; (totalCPUTime – idleCPUTime) &#x2F; totalCPUTime &#x3D; （3830 - 3520）&#x2F; 3830 &#x3D; 8%</span><br></pre></td></tr></table></figure>

<p>可以看到，前后两次时间点间的CPU使用率大概为8%，说明我们系统的CPU是处于空闲状态的，<strong>如果CPU 使用率一直大于 60% ，则表示系统处于繁忙状态，此时就需要进一步分析用户时间和系统时间的比例，看看到底是系统占用了CPU还是应用进程占用了CPU</strong>。</p>
<h3 id="3、使用top命令查看应用进程的CPU消耗情况"><a href="#3、使用top命令查看应用进程的CPU消耗情况" class="headerlink" title="3、使用top命令查看应用进程的CPU消耗情况"></a>3、使用top命令查看应用进程的CPU消耗情况</h3><p>此外，由于Android是基于Linux内核改造而成的操作系统，自然而然也能使用Linux的一些常用命令。比如我们可以使用top命令查看哪些进程是 CPU 的主要消耗者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用top命令会定时不断地输出进程的相关信息</span><br><span class="line">1|platina:&#x2F; $ top</span><br><span class="line">PID USER         PR  NI VIRT  RES  SHR S[%CPU] %MEM     TIME+ ARGS</span><br><span class="line">12700 u0_a945    10 -10 4.3G 122M  67M S 15.6   2.1   1:06.41 json.chao.com.w+</span><br><span class="line">753 system       RT   0  90M 1.1M 1.0M S 13.6   0.0 127:47.73 android.hardwar+</span><br><span class="line">2064 system      18  -2 4.6G 309M 215M S 12.3   5.4 978:15.18 system_server</span><br><span class="line">22142 u0_a163    20   0 2.0G  97M  41M S 10.3   1.6   2:22.99 com.tencent.mob+</span><br><span class="line">2293 system      20   0 4.7G 250M  87M S  8.6   4.3 353:15.77 com.android.sys+</span><br></pre></td></tr></table></figure>

<p>从以上可知我们的Awesome-WanAndroid应用进程占用了15.6%的CPU。最后，这里再列举下最常用的top命令，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 排除0%的进程信息</span><br><span class="line">adb shell top | grep -v &#39;0% S&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取指定进程的CPU、内存消耗，并设置刷新间隔</span><br><span class="line">adb shell top -d 1 | grep json.chao.com.wanandroid</span><br><span class="line">|platina:&#x2F; $ top -d 1|grep json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 13.8   2.2   1:04.46 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 19.0   2.2   1:04.51 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 15.0   2.2   1:04.70 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:04.85 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 26.0   2.2   1:04.94 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:05.20 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M R 17.0   2.2   1:05.29 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 20.0   2.2   1:05.46 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:05.66 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M R 21.0   2.2   1:05.75 json.chao.com.w+</span><br><span class="line">5689 u0_a945      10 -10 4.3G 129M  71M S 14.0   2.2   1:05.96 json.chao.com.w+</span><br></pre></td></tr></table></figure>

<h3 id="4、PS软件"><a href="#4、PS软件" class="headerlink" title="4、PS软件"></a>4、PS软件</h3><p>除了top命令可以比较全面地查看整体的CPU信息之外，如果我们只想<strong>查看当前指定进程已经消耗的CPU时间占系统总时间的百分比或其它的状态信息</strong>的话，可以使用ps命令，常用的ps命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看指定进程的状态信息</span><br><span class="line">platina:&#x2F; $ ps -p 31333</span><br><span class="line">USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAME</span><br><span class="line">u0_a945      31333  1277 4521308 127460 0                   0 S json.chao.com.w+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看指定进程已经消耗的CPU时间占系统总时间的百分比</span><br><span class="line">platina:&#x2F; $ ps -o PCPU -p 31333</span><br><span class="line">%CPU</span><br><span class="line">10.8</span><br></pre></td></tr></table></figure>

<p>其中输出参数的含义如下所示：</p>
<ul>
<li>  USER：用户名</li>
<li>  PID：进程ID</li>
<li>  PPID：父进程ID</li>
<li>  VSZ：虚拟内存大小（1k为单位）</li>
<li>  RSS：常驻内存大小（正在使用的页）</li>
<li>  WCHAN：进程在内核态中的运行时间</li>
<li>  Instruction pointer：指令指针</li>
<li>  NAME：进程名字</li>
</ul>
<p>最后的输出参数S表示的是进程当前的状态，总共有10种可能的状态，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R (running) S (sleeping) D (device I&#x2F;O) T (stopped)  t (traced)</span><br><span class="line">Z (zombie)  X (deader)   x (dead)       K (wakekill) W (waking)</span><br></pre></td></tr></table></figure>

<p>可以看到，我们当前主进程是休眠的状态。</p>
<h3 id="5、dumpsys-cpuinfo"><a href="#5、dumpsys-cpuinfo" class="headerlink" title="5、dumpsys cpuinfo"></a>5、dumpsys cpuinfo</h3><p>使用dumpsys cpuinfo命令获得的信息比起top命令得到的信息要更加精炼，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">platina:&#x2F; $ dumpsys cpuinfo</span><br><span class="line">Load: 1.92 &#x2F; 1.59 &#x2F; 0.97</span><br><span class="line">CPU usage from 45482ms to 25373ms ago (2020-02-04 17:00:37.666 to 2020-02-04 17:00:57.775):</span><br><span class="line">33% 2060&#x2F;system_server: 22% user + 10% kernel &#x2F; faults: 8152 minor 6 major</span><br><span class="line">17% 2292&#x2F;com.android.systemui: 12% user + 4.7% kernel &#x2F; faults: 21636 minor 3 major</span><br><span class="line">14% 750&#x2F;android.hardware.sensors@1.0-service: 4.4% user + 10% kernel</span><br><span class="line">6.1% 778&#x2F;surfaceflinger: 3.3% user + 2.7% kernel &#x2F; faults: 128 minor</span><br><span class="line">3.3% 2598&#x2F;com.miui.home: 2.8% user + 0.4% kernel &#x2F; faults: 7655 minor 11 major</span><br><span class="line">2.2% 2914&#x2F;cnss_diag: 1.6% user + 0.6% kernel</span><br><span class="line">1.9% 745&#x2F;android.hardware.graphics.composer@2.1-service: 1.4% user + 0.5% kernel &#x2F; faults: 5 minor</span><br><span class="line">1.7% 4525&#x2F;kworker&#x2F;u16:6: 0% user + 1.7% kernel</span><br><span class="line">1.6% 748&#x2F;android.hardware.memtrack@1.0-service: 0.6% user + 0.9% kernel</span><br><span class="line">1.4% 4551&#x2F;kworker&#x2F;u16:14: 0% user + 1.4% kernel</span><br><span class="line">1.4% 31333&#x2F;json.chao.com.wanandroid: 0.9% user + 0.4% kernel &#x2F; faults: 3995 minor 22 major</span><br><span class="line">1.1% 6670&#x2F;kworker&#x2F;u16:0: 0% user + 1.1% kernel</span><br><span class="line">0.9% 448&#x2F;mmc-cmdqd&#x2F;0: 0% user + 0.9% kernel</span><br><span class="line">0.7% 95&#x2F;system: 0% user + 0.7% kernel</span><br><span class="line">0.6% 4512&#x2F;mdss_fb0: 0% user + 0.6% kernel</span><br><span class="line">0.6% 7393&#x2F;com.android.incallui: 0.6% user + 0% kernel &#x2F; faults: 2272 minor</span><br><span class="line">0.6% 594&#x2F;logd: 0.4% user + 0.1% kernel &#x2F; faults: 38 minor 3 major</span><br><span class="line">0.5% 3108&#x2F;com.xiaomi.xmsf: 0.2% user + 0.2% kernel &#x2F; faults: 1812 minor</span><br><span class="line">0.5% 4526&#x2F;kworker&#x2F;u16:9: 0% user + 0.5% kernel</span><br><span class="line">0.5% 4621&#x2F;com.gotokeep.keep: 0.3% user + 0.1% kernel &#x2F; faults: 55 minor</span><br><span class="line">0.5% 354&#x2F;irq&#x2F;267-NVT-ts: 0% user + 0.5% kernel</span><br><span class="line">0.5% 2572&#x2F;com.android.phone: 0.3% user + 0.1% kernel &#x2F; faults: 323 minor</span><br><span class="line">0.5% 4554&#x2F;kworker&#x2F;u16:15: 0% user + 0.5% kernel</span><br><span class="line">0.4% 290&#x2F;kgsl_worker_thr: 0% user + 0.4% kernel</span><br><span class="line">0.3% 2933&#x2F;irq&#x2F;61-1008000.: 0% user + 0.3% kernel</span><br><span class="line">0.3% 3932&#x2F;com.tencent.mm: 0.2% user + 0% kernel &#x2F; faults: 647 minor 1 major</span><br><span class="line">0.3% 4550&#x2F;kworker&#x2F;u16:13: 0% user + 0.3% kernel</span><br><span class="line">0.3% 744&#x2F;android.hardware.graphics.allocator@2.0-service: 0% user + 0.3% kernel &#x2F; faults: 48 minor</span><br><span class="line">0.3% 8906&#x2F;com.tencent.mm:appbrand0: 0.2% user + 0% kernel &#x2F; faults: 45 minor</span><br><span class="line">0.2% 79&#x2F;smem_native_rpm: 0% user + 0.2% kernel</span><br><span class="line">0.2% 759&#x2F;vendor.qti.hardware.perf@1.0-service: 0% user + 0.2% kernel &#x2F; faults: 46 minor</span><br><span class="line">0.2% 3197&#x2F;com.miui.powerkeeper: 0% user + 0.1% kernel &#x2F; faults: 141 minor</span><br><span class="line">0.2% 4489&#x2F;kworker&#x2F;1:1: 0% user + 0.2% kernel</span><br><span class="line">0.2% 595&#x2F;servicemanager: 0% user + 0.2% kernel</span><br><span class="line">0.2% 754&#x2F;android.hardware.wifi@1.0-service: 0.1% user + 0% kernel</span><br><span class="line">0.2% 1258&#x2F;jbd2&#x2F;dm-2-8: 0% user + 0.2% kernel</span><br><span class="line">0.2% 5800&#x2F;com.eg.android.AlipayGphone: 0.1% user + 0% kernel &#x2F; faults: 48 minor</span><br><span class="line">0.2% 21590&#x2F;iptables-restore: 0% user + 0.1% kernel &#x2F; faults: 563 minor</span><br><span class="line">0.2% 21592&#x2F;ip6tables-restore: 0% user + 0.1% kernel &#x2F; faults: 647 minor</span><br><span class="line">0.1% 3&#x2F;ksoftirqd&#x2F;0: 0% user + 0.1% kernel</span><br><span class="line">0.1% 442&#x2F;cfinteractive: 0% user + 0.1% kernel</span><br><span class="line">0.1% 568&#x2F;ueventd: 0% user + 0% kernel</span><br><span class="line">0.1% 1295&#x2F;netd: 0% user + 0.1% kernel &#x2F; faults: 250 minor</span><br><span class="line">0.1% 3002&#x2F;com.miui.securitycenter.remote: 0.1% user + 0% kernel &#x2F; faults: 818 minor 1 major</span><br><span class="line">0.1% 20555&#x2F;com.eg.android.AlipayGphone:push: 0% user + 0% kernel &#x2F; faults: 20 minor</span><br><span class="line">0.1% 7&#x2F;rcu_preempt: 0% user + 0.1% kernel</span><br><span class="line">0.1% 15&#x2F;ksoftirqd&#x2F;1: 0% user + 0.1% kernel</span><br><span class="line">0.1% 76&#x2F;lpass_smem_glin: 0% user + 0.1% kernel</span><br><span class="line">0.1% 1299&#x2F;rild: 0.1% user + 0% kernel &#x2F; faults: 12 minor</span><br><span class="line">0.1% 1448&#x2F;android.process.acore: 0.1% user + 0% kernel &#x2F; faults: 1719 minor</span><br><span class="line">0% 4419&#x2F;com.google.android.webview:s: 0% user + 0% kernel &#x2F; faults: 602 minor</span><br><span class="line">0% 20465&#x2F;com.miui.hybrid: 0% user + 0% kernel &#x2F; faults: 1575 minor</span><br><span class="line">0% 10&#x2F;rcuop&#x2F;0: 0% user + 0% kernel</span><br><span class="line">0% 75&#x2F;smem_native_lpa: 0% user + 0% kernel</span><br><span class="line">0% 90&#x2F;kcompactd0: 0% user + 0% kernel</span><br><span class="line">0% 1508&#x2F;msm_irqbalance: 0% user + 0% kernel</span><br><span class="line">0% 1745&#x2F;cds_mc_thread: 0% user + 0% kernel</span><br><span class="line">0% 2899&#x2F;charge_logger: 0% user + 0% kernel</span><br><span class="line">0% 3612&#x2F;com.tencent.mm:tools: 0% user + 0% kernel &#x2F; faults: 29 minor</span><br><span class="line">0% 4203&#x2F;kworker&#x2F;0:0: 0% user + 0% kernel</span><br><span class="line">0% 7377&#x2F;com.android.server.telecom:ui: 0% user + 0% kernel &#x2F; faults: 1083 minor</span><br><span class="line">0% 32113&#x2F;com.tencent.mobileqq: 0% user + 0% kernel &#x2F; faults: 49 minor</span><br><span class="line">0% 8&#x2F;rcu_sched: 0% user + 0% kernel</span><br><span class="line">0% 22&#x2F;ksoftirqd&#x2F;2: 0% user + 0% kernel</span><br><span class="line">0% 25&#x2F;rcuop&#x2F;2: 0% user + 0% kernel</span><br><span class="line">0% 29&#x2F;ksoftirqd&#x2F;3: 0% user + 0% kernel</span><br><span class="line">0% 39&#x2F;rcuop&#x2F;4: 0% user + 0% kernel</span><br><span class="line">0% 53&#x2F;rcuop&#x2F;6: 0% user + 0% kernel</span><br><span class="line">0% 487&#x2F;irq&#x2F;715-ima-rdy: 0% user + 0% kernel</span><br><span class="line">0% 749&#x2F;android.hardware.power@1.0-service: 0% user + 0% kernel</span><br><span class="line">0% 764&#x2F;healthd: 0% user + 0% kernel &#x2F; faults: 2 minor</span><br><span class="line">0% 845&#x2F;wlan_logging_th: 0% user + 0% kernel</span><br><span class="line">0% 860&#x2F;mm-pp-dpps: 0% user + 0% kernel</span><br><span class="line">0% 1297&#x2F;wificond: 0% user + 0% kernel &#x2F; faults: 12 minor</span><br><span class="line"> 0% 1309&#x2F;com.miui.weather2: 0% user + 0% kernel &#x2F; faults: 729 minor 23 major</span><br><span class="line">0% 1542&#x2F;rild: 0% user + 0% kernel &#x2F; faults: 3 minor</span><br><span class="line">0% 2915&#x2F;tcpdump: 0% user + 0% kernel &#x2F; faults: 6 minor</span><br><span class="line">0% 2974&#x2F;com.tencent.mobileqq:MSF: 0% user + 0% kernel &#x2F; faults: 121 minor</span><br><span class="line">0% 3044&#x2F;com.miui.contentcatcher: 0% user + 0% kernel &#x2F; faults: 315 minor</span><br><span class="line">0% 3057&#x2F;com.miui.dmregservice: 0% user + 0% kernel &#x2F; faults: 332 minor</span><br><span class="line">0% 3095&#x2F;com.xiaomi.mircs: 0% user + 0% kernel</span><br><span class="line">0% 3115&#x2F;com.xiaomi.finddevice: 0% user + 0% kernel &#x2F; faults: 270 minor 3 major</span><br><span class="line">0% 3513&#x2F;com.xiaomi.metoknlp: 0% user + 0% kernel &#x2F; faults: 136 minor</span><br><span class="line">0% 3603&#x2F;com.tencent.mm:toolsmp: 0% user + 0% kernel &#x2F; faults: 35 minor</span><br><span class="line">0% 4527&#x2F;kworker&#x2F;u16:11: 0% user + 0% kernel</span><br><span class="line">0% 4841&#x2F;com.gotokeep.keep:xg_service_v4: 0% user + 0% kernel &#x2F; faults: 275 minor</span><br><span class="line">0% 5064&#x2F;com.sohu.inputmethod.sogou.xiaomi: 0% user + 0% kernel &#x2F; faults: 102 minor</span><br><span class="line">0% 5257&#x2F;kworker&#x2F;0:1: 0% user + 0% kernel</span><br><span class="line">0% 5839&#x2F;com.tencent.mm:push: 0% user + 0% kernel &#x2F; faults: 98 minor</span><br><span class="line">0% 6644&#x2F;kworker&#x2F;3:2: 0% user + 0% kernel</span><br><span class="line">0% 6657&#x2F;com.miui.wmsvc: 0% user + 0% kernel &#x2F; faults: 52 minor</span><br><span class="line">0% 6945&#x2F;com.xiaomi.account:accountservice: 0% user + 0% kernel &#x2F; faults: 1 minor</span><br><span class="line">0% 9387&#x2F;com.tencent.mm:appbrand1: 0% user + 0% kernel &#x2F; faults: 27 minor</span><br><span class="line">13% TOTAL: 6.8% user + 5.3% kernel + 0.2% iowait + 0.3% irq + 0.4% softirq</span><br></pre></td></tr></table></figure>

<p>从上述信息可知，<strong>第一行显示的是cpuload （负载平均值）信息</strong>：Load: 1.92 / 1.59 / 0.97 这<strong>三个数字表示逐渐变长的时间段（平均一分钟，五分钟和十五分钟）的平均值，而较低的数字则更好</strong>。数字越大表示有问题或机器过载。需要注意的是，这里的<strong>Load需要除以核心数</strong>，比如我这里的系统核心数为8核，所以最终每一个单核CPU的Load为0.24 / 0.20 / 0.12，<strong>如果Load超过1，则表示出现了问题</strong>。</p>
<p>此外，<strong>占用系统CPU资源最高的是system_server进程</strong>，而我们的wanandroid应用进程仅占用了 1.4%的CPU资源，其中有0.9%的是用户态所占用的时间，0.4%是内核态所占用的时间。最后，我们可以看到系统总占用的CPU时间是13%，这个值是根据<strong>前面所有值加起来 / 系统CPU数</strong>的处理的，也就是**104% / 8 = 13%**。</p>
<p>除了上述方式来分析系统与应用的CPU使用情况之外，我们还应该关注卡顿率与卡顿树这两个指标。它们能帮助我们有效地去评估、并且更有针对性地去优化应用发生的卡顿。</p>
<h4 id="卡顿率"><a href="#卡顿率" class="headerlink" title="卡顿率"></a>卡顿率</h4><p>类似于<a target="_blank" rel="noopener" href="https://jsonchao.github.io/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">深入探索Android稳定性优化</a>一文中讲到的UV、PV崩溃率，卡顿也可以有其对应的UV、PV卡顿率，<strong>UV就是Unique visitor，指的就是一台手机客户端为一个访客，00:00-24:00内相同的客户端只被计算一次</strong>。而<strong>PV即Page View，即页面浏览量或点击量</strong>。所以UV、PV卡顿率的定义即为如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UV 卡顿率可以评估卡顿的影响范围</span><br><span class="line">UV 卡顿率 &#x3D; 发生过卡顿 UV &#x2F; 开启卡顿采集 UV</span><br><span class="line">&#x2F;&#x2F; PV 卡顿率评估卡顿的严重程度</span><br><span class="line">PV 卡顿率 &#x3D; 发生过卡顿 PV &#x2F; 启动采集 PV</span><br></pre></td></tr></table></figure>

<p>因为卡顿问题的采样规则跟内存问题是相似的，一般都是采取<strong>抽样上报</strong>的方式，并且都应该<strong>按照单个用户来抽样</strong>。<strong>一个用户如果命中采集，那么在一天内都会持续的采集数据</strong>。</p>
<h4 id="卡顿树"><a href="#卡顿树" class="headerlink" title="卡顿树"></a>卡顿树</h4><p>我们可以实现卡顿的火焰图，即卡顿树，在一张图里就可以看到卡顿的整体信息。由于卡顿的具体耗时跟手机性能，还有当时的使用场景、环境等密切相关，而且卡顿问题在日活大的应用上出现的场景非常多，所以对于大于我们指定的卡顿阈值如1s\2s\3s时，我们就可以抛弃具体的耗时，只<strong>按照相同堆栈出现的比例来聚合各类卡顿信息</strong>。这样我们就能够<strong>很直观地从卡顿树上看到到底哪些堆栈出现的卡顿问题最多</strong>，以便于我们能够<strong>优先去解决 Top 的卡顿问题</strong>，达到使用最少的精力获取最大的优化效果的目的。</p>
<h2 id="3、卡顿优化工具"><a href="#3、卡顿优化工具" class="headerlink" title="3、卡顿优化工具"></a>3、卡顿优化工具</h2><h3 id="1、CPU-Profiler回顾"><a href="#1、CPU-Profiler回顾" class="headerlink" title="1、CPU Profiler回顾"></a>1、CPU Profiler回顾</h3><p>CPU Profiler的使用笔者已经在<a target="_blank" rel="noopener" href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">深入探索Android启动速度优化</a>中详细分析过了，如果对CPU Profiler还不是很熟悉的话，可以去看看这篇文章。</p>
<p>下面我们来简单来回顾一下CPU Profiler。</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>  图形的形式展示执行时间、调用栈等。</li>
<li>  信息全面，包含所有线程。</li>
</ul>
<h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><p>运行时开销严重，整体都会变慢，可能会带偏我们的优化方向。</p>
<h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F; 需要检测的代码片段</span><br><span class="line">...</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>

<p>最终生成的生成文件在sd卡：Android/data/packagename/files。</p>
<h3 id="2、Systrace回顾"><a href="#2、Systrace回顾" class="headerlink" title="2、Systrace回顾"></a>2、Systrace回顾</h3><p>systrace 利用了 <strong>Linux 的ftrace调试工具（ftrace是用于了解Linux内核内部运行情况的调试工具），相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。Android 在 ftrace 的基础上封装了atrace，并增加了更多特有的探针，比如Graphics、Activity Manager、Dalvik VM、System Server 等等</strong>。对于Systrace的使用笔者在<a target="_blank" rel="noopener" href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">深入探索Android启动速度优化</a>这篇文章中已经详细分析过了，如果对Systrace还不是很熟悉的话可以去看看这篇文章。</p>
<p>下面我们来简单回顾一下Systrace。</p>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>监控和跟踪API调用、线程运行情况，生成HTML报告。</p>
<h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><p>API 18以上使用，推荐使用TraceCompat。</p>
<h4 id="使用方式：-1"><a href="#使用方式：-1" class="headerlink" title="使用方式："></a>使用方式：</h4><p>使用python命令执行脚本，后面加上一系列参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -t 10 [other-options] [categories]</span><br><span class="line">&#x2F;&#x2F; 笔者通常使用的systrace配置</span><br><span class="line">python &#x2F;Users&#x2F;quchao&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;platform-tools&#x2F;systrace&#x2F;systrace.py -t 20 sched gfx view wm am app webview -a &quot;com.wanandroid.json.chao&quot; -o ~&#x2F;Documents&#x2F;open-project&#x2F;systrace_data&#x2F;wanandroid_start_1.html</span><br></pre></td></tr></table></figure>

<p>具体参数含义如下：</p>
<ul>
<li>  -t：指定统计时间为20s。</li>
<li>  shced：cpu调度信息。</li>
<li>  gfx：图形信息。</li>
<li>  view：视图。</li>
<li>  wm：窗口管理。</li>
<li>  am：活动管理。</li>
<li>  app：应用信息。</li>
<li>  webview：webview信息。</li>
<li>  -a：指定目标应用程序的包名。</li>
<li>  -o：生成的systrace.html文件。</li>
</ul>
<h4 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>  1、轻量级，开销小。</li>
<li>  2、它能够直观地反映CPU的利用率。</li>
<li>  3、右侧的Alerts能够根据我们应用的问题给出具体的建议，比如说，它会告诉我们App界面的<strong>绘制比较慢或者GC比较频繁</strong>。</li>
</ul>
<p>最后，我们还可以通过编译时给每个函数插桩的方式来实现线下自动增加应用程序的耗时分析，但是要注意需<strong>过滤大部分的短函数，以减少性能损耗</strong>（这一点可以<strong>通过黑名单配置的方式去过滤短函数或调用非常频繁的函数</strong>）。使用这种方式我们就可以看到<strong>整个应用程序的调用流程。包括应用关键线程的函数调用，例如渲染耗时、线程锁，GC 耗时等等</strong>。这里可以使用zhengcx的<a target="_blank" rel="noopener" href="https://github.com/zhengcx/MethodTraceMan/blob/master/README.md">MethodTraceMan</a>，但是目前仅仅能实现对包名和类名的过滤配置，所以需要对源码进行定制化，以支持过滤短函数或调用非常频繁函数的配置功能。</p>
<p>基于性能的考虑，<strong>如果要在线上使用此方案，最好只去监控主线程的耗时</strong>。虽然插桩方案对性能的影响并不是很大，但是建议仅在线下或灰度环境中使用。</p>
<p>此外，如果你需要分析Native 函数的调用，请使用Android 5.0 新增的<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md">Simpleperf</a>性能分析工具，它<strong>利用了 CPU 的性能监控单元（PMU）提供的硬件 perf 事件</strong>。使用 Simpleperf 可以看到所有的 Native 代码的耗时，对<strong>一些 Android 系统库的调用</strong>，在分析问题时有比较大的帮助，例如分析<strong>加载 dex、verify class 的耗时等等</strong>。此外，在 Android Studio 3.2 中的 Profiler 也直接支持了 Simpleper（SampleNative性能分析工具 (API Level 26+)），这更加方便了native代码的调试。</p>
<h3 id="3、StrictMode"><a href="#3、StrictMode" class="headerlink" title="3、StrictMode"></a>3、StrictMode</h3><p>StrictMode是Android 2.3引入的一个工具类，它被称为严苛模式，是Android提供的一种<strong>运行时检测机制</strong>，可以用来帮助开发人员用来检测代码中一些不规范的问题。对于我们的项目当中，可能会成千上万行代码，如果我们用肉眼Review，这样不仅效率非常低效，而且比较容易出问题。使用StrictMode之后，<strong>系统会自动检测出来在主线程中的一些异常情况，并按照我们的配置给出相应的反应</strong>。</p>
<p>StrictMode这个工具是非常强大的，但是我们可能因为对它不熟悉而忽略掉它。StrictMode主要用来检测两大问题：</p>
<h4 id="1、线程策略"><a href="#1、线程策略" class="headerlink" title="1、线程策略"></a>1、线程策略</h4><p>线程策略的检测内容，是一些<strong>自定义的耗时调用、磁盘读取操作以及网络请求等</strong>。</p>
<h4 id="2、虚拟机策略"><a href="#2、虚拟机策略" class="headerlink" title="2、虚拟机策略"></a>2、虚拟机策略</h4><p>虚拟机策略的检测内容如下：</p>
<ul>
<li>  <strong>Activity泄漏</strong></li>
<li>  <strong>Sqlite对象泄漏</strong></li>
<li>  <strong>检测实例数量</strong></li>
</ul>
<h4 id="StrictMode实战"><a href="#StrictMode实战" class="headerlink" title="StrictMode实战"></a>StrictMode实战</h4><p>如果要在应用中使用StrictMode，只需要在Applicaitoin的onCreate方法中对StrictMode进行统一配置，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void initStrictMode() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1、设置Debug标志位，仅仅在线下环境才使用StrictMode</span><br><span class="line">    if (DEV_MODE) &#123;</span><br><span class="line">        &#x2F;&#x2F; 2、设置线程策略</span><br><span class="line">        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                .detectCustomSlowCalls() &#x2F;&#x2F;API等级11，使用StrictMode.noteSlowCode</span><br><span class="line">                .detectDiskReads()</span><br><span class="line">                .detectDiskWrites()</span><br><span class="line">                .detectNetwork() &#x2F;&#x2F; or .detectAll() for all detectable problems</span><br><span class="line">                .penaltyLog() &#x2F;&#x2F;在Logcat 中打印违规异常信息</span><br><span class="line">&#x2F;&#x2F;              .penaltyDialog() &#x2F;&#x2F;也可以直接跳出警报dialog</span><br><span class="line">&#x2F;&#x2F;              .penaltyDeath() &#x2F;&#x2F;或者直接崩溃</span><br><span class="line">                .build());</span><br><span class="line">        &#x2F;&#x2F; 3、设置虚拟机策略</span><br><span class="line">        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()</span><br><span class="line">                .detectLeakedSqlLiteObjects()</span><br><span class="line">                &#x2F;&#x2F; 给NewsItem对象的实例数量限制为1</span><br><span class="line">                .setClassInstanceLimit(NewsItem.class, 1)</span><br><span class="line">                .detectLeakedClosableObjects() &#x2F;&#x2F;API等级11</span><br><span class="line">                .penaltyLog()</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在日志输出栏中注意使用“StrictMode”关键字过滤出对应的log即可。</p>
<h2 id="4、Profilo"><a href="#4、Profilo" class="headerlink" title="4、Profilo"></a>4、Profilo</h2><p>Profilo是一个用于收集应用程序生产版本的性能跟踪的Android库。</p>
<p>对于Profilo来说，它<strong>集成了atrace功能，ftrace 所有的性能埋点数据都会通过 trace_marker 文件写入到内核缓冲区，Profilo 使用了 PLT Hook 拦截了写入操作，以选择部分关心的事件去做特定的分析</strong>。这样所有的 systrace 的探针我们都可以拿到，例如<strong>四大组件生命周期、锁等待时间、类校验、GC 时间等等</strong>。不过大部分的 atrace 事件都比较笼统，从事件“B|pid|activityStart”，我们无法明确知道该事件具体是由哪个 Activity 来创建的。</p>
<p>此外，使用Profilo还能够快速获取Java堆栈。<strong>由于获取堆栈需要暂停主线程的运行，所以profilo通过间隔发送 SIGPROF 信号这样一种类似 Native 崩溃捕捉的方式去快速获取 Java 堆栈</strong>。</p>
<p><strong>Profilo能够低耗时地快速获取Java堆栈的具体实现原理为当Signal Handler 捕获到信号后，它就会获取到当前正在执行的 Thread，通过 Thread 对象就可以拿到当前线程的 ManagedStack，ManagedStack 是一个单链表，它保存了当前的 ShadowFrame 或者 QuickFrame 栈指针，先依次遍历 ManagedStack 链表，然后遍历其内部的 ShadowFrame 或者 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈</strong>。关于ManagedStack与ShadowFrame、QuickFrame三者的关系如下图所示:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-4e8496ebc31551e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>Profilo通过这种方式，就可以实现线程同步运行的同时，我们还可以去帮它做检查，并且耗时基本可以忽略不计。但是目前 Profilo 快速获取堆栈的功能不支持 Android 8.0 和 Android 9.0，并且它内部使用了Hook等大量的黑科技手段，鉴于稳定性问题，建议采取<strong>抽样部分用户</strong>的方式来开启该功能。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo">Profilo项目地址</a></p>
<p>前面我们说过，Profilo最终也使用了ftrace，而Systrace主要也是根据Linux的ftrace机制来实现的，而<strong>ftrace的作用是帮助我们了解 Linux 内核的运行时行为，以便进行故障调试或性能分析</strong>。ftrace的整体架构如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-8dbd16242b9e751e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>由上图可知，<strong>Ftrace 有两大组成部分，一个是 framework，另外就是一系列的 tracer 。每个 tracer 用于完成不同的功能，并且它们统一由 framework 管理。 ftrace 的 trace 信息保存在 ring buffer 中，由 framework 负责管理。 Framework 利用 debugfs 系统在 /debugfs 下建立 tracing 目录，并提供了一系列的控制文件。</strong></p>
<p>下面，我这里给出使用 PLTHook 技术来获取 Atrace 日志的一个项目。</p>
<h3 id="1、使用profilo的PLTHook来hook-libc-so的-write-与-write-chk-方法"><a href="#1、使用profilo的PLTHook来hook-libc-so的-write-与-write-chk-方法" class="headerlink" title="1、使用profilo的PLTHook来hook libc.so的 write 与 __write_chk 方法"></a>1、使用profilo的PLTHook来hook libc.so的 write 与 __write_chk 方法</h3><p><a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06">使用 PLTHook 技术来获取 Atrace 的日志-项目地址</a></p>
<p>运行项目后，我们点击按钮开启Atrace日志，然后就可以在Logcat中看到如下的native层日志信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2020-02-05 10:58:00.873 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;install systrace hoook&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2020-02-05 10:58:00.879 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|inflate</span><br><span class="line">2020-02-05 10:58:00.880 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|LinearLayout</span><br><span class="line">2020-02-05 10:58:00.881 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.882 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|TextView</span><br><span class="line">2020-02-05 10:58:00.884 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.885 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.888 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|notifyFramePending</span><br><span class="line">2020-02-05 10:58:00.888 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.889 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|Choreographer#doFrame</span><br><span class="line">2020-02-05 10:58:00.889 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|input</span><br><span class="line">2020-02-05 10:58:00.889 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.889 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|traversal</span><br><span class="line">2020-02-05 10:58:00.889 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|draw</span><br><span class="line">2020-02-05 10:58:00.890 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|Record View#draw()</span><br><span class="line">2020-02-05 10:58:00.891 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|DrawFrame</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|syncFrameState</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|prepareTree</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.891 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.891 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13052&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|setBuffersDimensions</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.892 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|dequeueBuffer</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|importBuffer</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|HIDL::IMapper::importBuffer::passthrough</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.894 13052-13058&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|Compiling</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; E</span><br><span class="line">2020-02-05 10:58:00.894 13052-13075&#x2F;com.dodola.atrace I&#x2F;HOOOOOOOOK: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B|13052|query</span><br></pre></td></tr></table></figure>

<p>需要注意的是，日志中的B代表begin，也就是对应时间开始的时间，而E代表End，即对应事件结束的时间，并且，B|事件和E|事件是成对出现的，这样我们就可以<strong>通过该事件的结束时间减去对应的开始时间来获得每个事件使用的时间</strong>。例如，上述log中我们可以看出TextView的draw方法显示使用了3ms。</p>
<p>此外，在下面这个项目里展示了如何使用 PLTHook 技术来获取线程创建的堆栈。</p>
<h3 id="2、使用PLTHook技术来获取线程创建的堆栈"><a href="#2、使用PLTHook技术来获取线程创建的堆栈" class="headerlink" title="2、使用PLTHook技术来获取线程创建的堆栈"></a>2、使用PLTHook技术来获取线程创建的堆栈</h3><p><a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus">使用 PLTHook 技术来获取线程创建的堆栈-项目地址</a></p>
<p>运行项目后，我们点击开启 Thread Hook按钮，然后点击新建 Thread按钮。最后可以在Logcat 中看到Thread创建的堆栈信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2020-02-05 13:47:59.006 20159-20159&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: stack:com.dodola.thread.ThreadHook.getStack(ThreadHook.java:16)</span><br><span class="line">com.dodola.thread.MainActivity$2.onClick(MainActivity.java:40)</span><br><span class="line">android.view.View.performClick(View.java:6311)</span><br><span class="line">android.view.View$PerformClick.run(View.java:24833)</span><br><span class="line">android.os.Handler.handleCallback(Handler.java:794)</span><br><span class="line">android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">android.os.Looper.loop(Looper.java:173)</span><br><span class="line">android.app.ActivityThread.main(ActivityThread.java:6653)</span><br><span class="line">java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821)</span><br><span class="line">2020-02-05 13:47:59.007 20159-20339&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: thread name:Thread-2</span><br><span class="line">2020-02-05 13:47:59.008 20159-20339&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: thread id:1057</span><br><span class="line">2020-02-05 13:47:59.009 20159-20339&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: stack:com.dodola.thread.ThreadHook.getStack(ThreadHook.java:16)</span><br><span class="line">com.dodola.thread.MainActivity$2$1.run(MainActivity.java:38)</span><br><span class="line">2020-02-05 13:47:59.011 20159-20340&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: inner thread name:Thread-3</span><br><span class="line">2020-02-05 13:47:59.012 20159-20340&#x2F;com.dodola.thread E&#x2F;HOOOOOOOOK: inner thread id:1058</span><br></pre></td></tr></table></figure>

<p>由于Profilo与PLT Hook涉及了大量的C/C++、NDK开发的知识，限于篇幅，所以这部分不做详细讲解，如对NDK开发感兴趣的同学可以期待下我后面的<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-Android-NDK">Awesome-Android-NDK系列文章</a>，等性能优化系列文章更新完毕之后，就会开始去系统地学习NDK相关的开发知识，敬请期待。</p>
<h1 id="二、自动化卡顿检测方案及优化"><a href="#二、自动化卡顿检测方案及优化" class="headerlink" title="二、自动化卡顿检测方案及优化"></a>二、自动化卡顿检测方案及优化</h1><h2 id="1、为什么需要自动化卡顿检测方案？"><a href="#1、为什么需要自动化卡顿检测方案？" class="headerlink" title="1、为什么需要自动化卡顿检测方案？"></a>1、为什么需要自动化卡顿检测方案？</h2><p>主要有以下两点原因：</p>
<ul>
<li>  1、Cpu Profiler、Systrace等系统工具仅适合线下针对性分析。</li>
<li>  2、线上及测试环境需要自动化的卡顿检方案来定位卡顿，同时，更重要的是，它能记录卡顿发生时的场景。</li>
</ul>
<h2 id="2、卡顿检测方案原理"><a href="#2、卡顿检测方案原理" class="headerlink" title="2、卡顿检测方案原理"></a>2、卡顿检测方案原理</h2><p>它的原理源于Android的消息处理机制，<strong>一个线程不管有多少Handler，它只会有一个Looper存在，主线程执行的任何代码都会通过Looper.loop()方法执行。而在Looper函数中，它有一个mLogging对象，这个对象在每个message处理前后都会被调用。主线程发生了卡顿，那一定是在dispatchMessage()方法中执行了耗时操作。那么，我们就可以通过这个mLogging对象对dispatchMessage()进行监控</strong>。</p>
<h3 id="卡顿检测方案的具体实现步骤"><a href="#卡顿检测方案的具体实现步骤" class="headerlink" title="卡顿检测方案的具体实现步骤"></a>卡顿检测方案的具体实现步骤</h3><p>首先，我们看下Looper用于执行消息循环的loop()方法，关键代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void loop() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line">        if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging &#x3D; me.mLogging;</span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 1</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F; 2 </span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">            dispatchEnd &#x3D; needEndTime ? SystemClock.uptimeMillis() : 0;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag !&#x3D; 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 3</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在Looper的loop()方法中，在其执行每一个消息（注释2处）的前后都由logging进行了一次打印输出。可以看到，在执行消息前是输出的”&gt;&gt;&gt;&gt;&gt; Dispatching to “，在执行消息后是输出的”&lt;&lt;&lt;&lt;&lt; Finished to “,它们打印的日志是不一样的，我们就可以由此来判断消息执行的前后时间点。</p>
<p>所以，具体的实现可以归纳为如下步骤：</p>
<ul>
<li>  1、<strong>首先，我们需要使用Looper.getMainLooper().setMessageLogging()去设置我们自己的Printer实现类去打印输出logging。这样，在每个message执行的之前和之后都会调用我们设置的这个Printer实现类。</strong></li>
<li>  2、<strong>如果我们匹配到”&gt;&gt;&gt;&gt;&gt; Dispatching to “之后，我们就可以执行一行代码：也就是在指定的时间阈值之后，我们在子线程去执行一个任务，这个任务就是去获取当前主线程的堆栈信息以及当前的一些场景信息，比如：内存大小、电脑、网络状态等。</strong></li>
<li>  3、<strong>如果在指定的阈值之内匹配到了”&lt;&lt;&lt;&lt;&lt; Finished to “，那么说明message就被执行完成了，则表明此时没有产生我们认为的卡顿效果，那我们就可以将这个子线程任务取消掉。</strong></li>
</ul>
<h2 id="3、AndroidPerformanceMonitor"><a href="#3、AndroidPerformanceMonitor" class="headerlink" title="3、AndroidPerformanceMonitor"></a>3、AndroidPerformanceMonitor</h2><p>它是一个非侵入式的性能监控组件，可以通过通知的形式弹出卡顿信息。它的原理就是我们刚刚讲述到的卡顿监控的实现原理。</p>
<p>接下我们通过一个简单的示例来讲解一下它的使用。</p>
<p>首先，我们需要在moudle的build.gradle下配置它的依赖，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; release：项目中实现了线上监控体系的时候去使用</span><br><span class="line">api &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用</span><br><span class="line">debugApi &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br><span class="line">releaseApi &#39;com.github.markzhai:blockcanary-no-op:1.5.0&#39;</span><br></pre></td></tr></table></figure>

<p>其次，在Application的onCreate方法中开启卡顿监控：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 注意在主进程初始化调用</span><br><span class="line">BlockCanary.install(this, new AppBlockCanaryContext()).start();</span><br></pre></td></tr></table></figure>

<p>最后，继承BlockCanaryContext类去实现自己的监控配置上下文类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">public class AppBlockCanaryContext extends BlockCanaryContext &#123;</span><br><span class="line">    &#x2F;&#x2F; 实现各种上下文，包括应用标识符，用户uid，网络类型，卡顿判断阙值，Log保存位置等等</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 提供应用的标识符</span><br><span class="line">    *</span><br><span class="line">    * @return 标识符能够在安装的时候被指定，建议为 version + flavor.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public String provideQualifier() &#123;</span><br><span class="line">        return &quot;unknown&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 提供用户uid，以便在上报时能够将对应的</span><br><span class="line">    * 用户信息上报至服务器 </span><br><span class="line">    *</span><br><span class="line">    * @return user id</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public String provideUid() &#123;</span><br><span class="line">        return &quot;uid&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 提供当前的网络类型</span><br><span class="line">    *</span><br><span class="line">    * @return &#123;@link String&#125; like 2G, 3G, 4G, wifi, etc.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public String provideNetworkType() &#123;</span><br><span class="line">        return &quot;unknown&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 配置监控的时间区间，超过这个时间区间    ，BlockCanary将会停止, use</span><br><span class="line">    * with &#123;@code BlockCanary&#125;&#39;s isMonitorDurationEnd</span><br><span class="line">    *</span><br><span class="line">    * @return monitor last duration (in hour)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public int provideMonitorDuration() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 指定判定为卡顿的阈值threshold (in millis),  </span><br><span class="line">    * 你可以根据不同设备的性能去指定不同的阈值</span><br><span class="line">    *</span><br><span class="line">    * @return threshold in mills</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public int provideBlockThreshold() &#123;</span><br><span class="line">        return 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 设置线程堆栈dump的间隔, 当阻塞发生的时候使用, BlockCanary 将会根据</span><br><span class="line">    * 当前的循环周期在主线程去dump堆栈信息</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * 由于依赖于Looper的实现机制, 真实的dump周期 </span><br><span class="line">    * 将会比设定的dump间隔要长(尤其是当CPU很繁忙的时候).</span><br><span class="line">    * &lt;&#x2F;p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @return dump interval (in millis)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public int provideDumpInterval() &#123;</span><br><span class="line">        return provideBlockThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 保存log的路径, 比如 &quot;&#x2F;blockcanary&#x2F;&quot;, 如果权限允许的话，</span><br><span class="line">    * 会保存在本地sd卡中</span><br><span class="line">    *</span><br><span class="line">    * @return path of log files</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public String providePath() &#123;</span><br><span class="line">        return &quot;&#x2F;blockcanary&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 是否需要通知去通知用户发生阻塞</span><br><span class="line">    *</span><br><span class="line">    * @return true if need, else if not need.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public boolean displayNotification() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 用于将多个文件压缩为一个.zip文件</span><br><span class="line">    *</span><br><span class="line">    * @param src  files before compress</span><br><span class="line">    * @param dest files compressed</span><br><span class="line">    * @return true if compression is successful</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public boolean zip(File[] src, File dest) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 用于将已经被压缩好的.zip log文件上传至</span><br><span class="line">    * APM后台</span><br><span class="line">    *</span><br><span class="line">    * @param zippedFile zipped file</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public void upload(File zippedFile) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 用于设定包名, 默认使用进程名，</span><br><span class="line">    *</span><br><span class="line">    * @return null if simply concern only package with process name.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public List&lt;String&gt; concernPackages() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 使用 @&#123;code concernPackages&#125;方法指定过滤的堆栈信息 </span><br><span class="line">    *</span><br><span class="line">    * @return true if filter, false it not.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public boolean filterNonConcernStack() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 指定一个白名单, 在白名单的条目将不会出现在展示阻塞信息的UI中</span><br><span class="line">    *</span><br><span class="line">    * @return return null if you don&#39;t need white-list filter.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public List&lt;String&gt; provideWhiteList() &#123;</span><br><span class="line">        LinkedList&lt;String&gt; whiteList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        whiteList.add(&quot;org.chromium&quot;);</span><br><span class="line">        return whiteList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 使用白名单的时候，是否去删除堆栈在白名单中的文件</span><br><span class="line">    *</span><br><span class="line">    * @return true if delete, false it not.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public boolean deleteFilesInWhiteList() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 阻塞拦截器, 我们可以指定发生阻塞时应该做的工作</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public void onBlock(Context context, BlockInfo blockInfo) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在上述配置中，我们指定了卡顿的阈值为1000ms。接下来，我们可以测试一下BlockCanary监测卡顿时的效果，这里我在Activity的onCreate方法中添加如下代码使线程休眠3s：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(3000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们运行项目，打开App，即可看到类似LeakCanary界面那样的卡顿信息堆栈。</p>
<p>除了发生卡顿时BlockCanary提供的图形界面可供开发和测试人员直接查看卡顿原因之外。其最大的作用还是在线上环境或者自动化monkey测试的环节进行大范围的log采集与分析，对于分析的纬度，可以从以下两个纬度来进行：</p>
<ul>
<li>  卡顿时间。</li>
<li>  根据同堆栈出现的卡顿次数来进行排序和归类。</li>
</ul>
<h3 id="BlockCanary的优势如下"><a href="#BlockCanary的优势如下" class="headerlink" title="BlockCanary的优势如下"></a>BlockCanary的优势如下</h3><ul>
<li>  非侵入式。</li>
<li>  方便精准，能够定位到代码的某一行代码。</li>
</ul>
<h3 id="那么这种自动检测卡顿的方案有什么问题吗？"><a href="#那么这种自动检测卡顿的方案有什么问题吗？" class="headerlink" title="那么这种自动检测卡顿的方案有什么问题吗？"></a>那么这种自动检测卡顿的方案有什么问题吗？</h3><p>在卡顿的周期之内，应用确实发生了卡顿，但是获取到的卡顿信息可能会不准确，和我们的OOM一样，也就是<strong>最后的堆栈信息仅仅只是一个表象，并不是真正发生问题时的一个堆栈</strong>。下面，我们先看下如下的一个示意图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-84ec8cef45120e42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>假设主线程在T1到T2的时间段内发生了卡顿，卡顿检测方案获取卡顿时的堆栈信息是T2时刻，但是实际上发生卡顿的时刻可能是在这段时间区域内另一个耗时过长的函数，那么可能在我们捕获卡顿的时刻时，真正的卡顿时机已经执行完成了，所以在T2时刻捕获到的一个卡顿信息并不能够反映卡顿的现场，也就是最后呈现出来的堆栈信息仅仅只是一个表象，并不是真正问题的藏身之处。</p>
<h3 id="那么，我们如何对这种情况进行优化呢？"><a href="#那么，我们如何对这种情况进行优化呢？" class="headerlink" title="那么，我们如何对这种情况进行优化呢？"></a>那么，我们如何对这种情况进行优化呢？</h3><p>我们可以<strong>获取卡顿周期内的多个堆栈</strong>，而不仅仅是最后一个，这样的话，如果发生了卡顿，我们就可以<strong>根据这些堆栈信息来清晰地还原整个卡顿现场</strong>。因为我们有卡顿现场的多个堆栈信息，我们完全知道卡顿时究竟发生了什么，<strong>到底哪些函数它的调用时间比较长</strong>。接下来，我们看看下面的卡顿检测优化流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-ad808f5f1a791910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>根据图中，可以梳理出优化后的具体实现步骤为：</p>
<ul>
<li>  1、首先，我们会通过startMonitor方法对这个过程进行监控。</li>
<li>  2、接着，我们就开始<strong>高频采集堆栈信息。如果发生了卡顿，我们就会调用endMonitor方法</strong>。</li>
<li>  3、然后，将之前我们采集的多个堆栈信息记录到文件中。</li>
<li>  4、最后，在合适的时机上报给我们的服务器。</li>
</ul>
<p>通过上述的优化，我们就可以知道在整个卡顿周期之内，究竟是哪些方法在执行，哪些方法比较耗时。</p>
<p>但是这种海量卡顿堆栈的处理又存在着另一个问题，那就是高频卡顿上报量太大，服务器压力较大，这里我们来分析下<strong>如何减少服务端对堆栈信息的处理量</strong>。</p>
<p>在出现卡顿的情况下，我们<strong>采集到了多个堆栈，大概率的情况下，可能会存在多个重复的堆栈</strong>，而这个重复的堆栈信息才是我们应该关注的地方。我们可以<strong>对一个卡顿下的堆栈进行能hash排重，找出重复的堆栈</strong>。这样，<strong>服务器需要处理的数据量就会大大减少，同时也过滤出了我们需要重点关注的对象</strong>。对于开发人员来说，就能更快地找到卡顿的原因。</p>
<h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>在本节中，我们学习了自动化卡顿检测的原理，然后，我们使用这种方案进行了实战，最后，我还介绍了这种方案的问题和它的优化思路。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本篇文章中，我们主要对卡顿优化分析方法与工具 、自动化卡顿检测方案及优化相关的知识进行了全面且深入地讲解，这里再简单总结一下本篇文章涉及的两大主题：</p>
<ul>
<li>  1、卡顿优化分析方法与工具：背景介绍、卡顿分析方法之使用shell命令分析CPU耗时、卡顿优化工具。</li>
<li>  2、自动化卡顿检测方案及优化：卡顿检测方案原理、AndroidPerformanceMonitor实战及其优化。</li>
</ul>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章中，笔者带领大家学习了卡顿优化分析方法与工具、自动化卡顿检测方案及优化这两块内容。如果对这块内容还不了解的同学建议先看看<a href="">《深入探索Android卡顿优化（上）》</a>。本篇，为深入探索Android卡顿优化的下篇。这篇文章包含的主要内容如下所示：</p>
<ul>
<li>  1、ANR分析与实战</li>
<li>  2、卡顿单点问题检测方案</li>
<li>  3、高效实现界面秒开</li>
<li>  4、优雅监控耗时盲区</li>
<li>  5、卡顿优化技巧总结</li>
<li>  6、常见卡顿问题解决方案总结</li>
<li>  7、卡顿优化的常见问题</li>
</ul>
<p>卡顿时间过长，一定会造成应用发生ANR。下面，我们就来从应用的ANR分析与实战来开始今天的探索之旅。</p>
<h2 id="一、ANR分析与实战"><a href="#一、ANR分析与实战" class="headerlink" title="一、ANR分析与实战"></a>一、ANR分析与实战</h2><h3 id="1、ANR介绍与实战"><a href="#1、ANR介绍与实战" class="headerlink" title="1、ANR介绍与实战"></a>1、ANR介绍与实战</h3><p>首先，我们再来回顾一下ANR的几种常见的类型，如下所示：</p>
<ul>
<li>  1、KeyDispatchTimeout：按键事件在<strong>5s</strong>的时间内没有处理完成。</li>
<li>  2、BroadcastTimeout：广播接收器在<strong>前台10s，后台60s</strong>的时间内没有响应完成。</li>
<li>  3、ServiceTimeout：服务在<strong>前台20s，后台200s</strong>的时间内没有处理完成。</li>
</ul>
<p>具体的时间定义我们可以在AMS（ActivityManagerService）中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; How long we allow a receiver to run before giving up on it.</span><br><span class="line">static final int BROADCAST_FG_TIMEOUT &#x3D; 10*1000;</span><br><span class="line">static final int BROADCAST_BG_TIMEOUT &#x3D; 60*1000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; How long we wait until we timeout on key dispatching.</span><br><span class="line">static final int KEY_DISPATCHING_TIMEOUT &#x3D; 5*1000;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们来看一下ANR的执行流程。</p>
<h4 id="ANR执行流程"><a href="#ANR执行流程" class="headerlink" title="ANR执行流程"></a>ANR执行流程</h4><ul>
<li>  1、首先，我们的应用发生了ANR。</li>
<li>  2、然后，我们的进程就会接受到异常终止信息，并开始写入进程ANR信息，也就是当时应用的场景信息，它包含了应用所有的堆栈信息、CPU、IO等使用的情况等待。</li>
<li>  3、最后，会弹出一个ANR提示框，看你是要选择继续等待还是退出应用，需要注意这个ANR提示框不一定会弹出，根据不同ROM，它的表现情况也不同。因为有些手机厂商它会默认去掉这个提示框，以避免带来不好的用户体验。</li>
</ul>
<p>分析完ANR的执行流程之后，我们来分析下怎样去解决ANR，究竟哪里可以作为我们的一个突破点。</p>
<p>在上面我们说过，当应用发生ANR时，会写入当时发生ANR的场景信息到文件中，<strong>那么，我们可不可以通过这个文件来判断是否发生了ANR呢？</strong></p>
<p>关于根据ANR log进行ANR问题的排查与解决的方式笔者已经在<a href="">深入探索Android稳定性优化</a>的第三节ANR优化中讲解过了，这里就不多赘述了。</p>
<h4 id="线上ANR监控方式"><a href="#线上ANR监控方式" class="headerlink" title="线上ANR监控方式"></a>线上ANR监控方式</h4><p>在<a href="">深入探索Android稳定性优化</a>的第三节ANR优化中我说到了使用FileObserver可以监听 /data/anr/traces.txt的变化，利用它可以实现线上ANR的监控，但是它有一个致命的缺点，就是高版本ROM需要root权限，解决方案是只能通过海外Google Play服务、国内Hardcoder的方式去规避。但是，这在国内显然是不现实的，那么，有没有更好的实现方式呢？</p>
<p>那就是ANR-WatchDog，下面我就来详细地介绍一下它。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/SalomonBrys/ANR-WatchDog">ANR-WatchDog项目地址</a></p>
<p>ANR-WatchDog是一种非侵入式的ANR监控组件，可以用于线上ANR的监控，接下来，我们就使用ANR-WatchDog来监控ANR。</p>
<p>首先，在我们项目的app/build.gradle中添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.github.anrwatchdog:anrwatchdog:1.4.0&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，在应用的Application的onCreate方法中添加如下代码启动ANR-WatchDog：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ANRWatchDog().start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，它的初始化方式非常地简单，同时，它内部的实现也非常简单，整个库只有两个类，一个是ANRWatchDog，另一个是ANRError。</p>
<p>接下来我们来看一下ANRWatchDog的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* A watchdog timer thread that detects when the UI thread has frozen.</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ANRWatchDog extends Thread &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，ANRWatchDog实际上是继承了Thread类，也就是它是一个线程，对于线程来说，最重要的就是其run方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_ANR_TIMEOUT &#x3D; 5000;</span><br><span class="line"></span><br><span class="line">private volatile long _tick &#x3D; 0;</span><br><span class="line">private volatile boolean _reported &#x3D; false;</span><br><span class="line"></span><br><span class="line">private final Runnable _ticker &#x3D; new Runnable() &#123;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">        _tick &#x3D; 0;</span><br><span class="line">        _reported &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1、首先，将线程命名为|ANR-WatchDog|。</span><br><span class="line">    setName(&quot;|ANR-WatchDog|&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2、接着，声明了一个默认的超时间隔时间，默认的值为5000ms。</span><br><span class="line">    long interval &#x3D; _timeoutInterval;</span><br><span class="line">    &#x2F;&#x2F; 3、然后，在while循环中通过_uiHandler去post一个_ticker Runnable。</span><br><span class="line">    while (!isInterrupted()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3.1 这里的_tick默认是0，所以needPost即为true。</span><br><span class="line">        boolean needPost &#x3D; _tick &#x3D;&#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 这里的_tick加上了默认的5000ms</span><br><span class="line">        _tick +&#x3D; interval;</span><br><span class="line">        if (needPost) &#123;</span><br><span class="line">            _uiHandler.post(_ticker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 接下来，线程会sleep一段时间，默认值为5000ms。</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            _interruptionListener.onInterrupted(e);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4、如果主线程没有处理Runnable，即_tick的值没有被赋值为0，则说明发生了ANR，第二个_reported标志位是为了避免重复报道已经处理过的ANR。</span><br><span class="line">        if (_tick !&#x3D; 0 &amp;&amp; !_reported) &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection ConstantConditions</span><br><span class="line">            if (!_ignoreDebugger &amp;&amp; (Debug.isDebuggerConnected() || Debug.waitingForDebugger())) &#123;</span><br><span class="line">                Log.w(&quot;ANRWatchdog&quot;, &quot;An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))&quot;);</span><br><span class="line">                _reported &#x3D; true;</span><br><span class="line">                continue ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            interval &#x3D; _anrInterceptor.intercept(_tick);</span><br><span class="line">            if (interval &gt; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final ANRError error;</span><br><span class="line">            if (_namePrefix !&#x3D; null) &#123;</span><br><span class="line">                error &#x3D; ANRError.New(_tick, _namePrefix, _logThreadsWithoutStackTrace);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 5、如果没有主动给ANR_Watchdog设置线程名，则会默认会使用ANRError的NewMainOnly方法去处理ANR。</span><br><span class="line">                error &#x3D; ANRError.NewMainOnly(_tick);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 6、最后会通过ANRListener调用它的onAppNotResponding方法，其默认的处理会直接抛出当前的ANRError，导致程序崩溃。 _anrListener.onAppNotResponding(error);</span><br><span class="line">            interval &#x3D; _timeoutInterval;</span><br><span class="line">            _reported &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，在注释1处，我们将线程命名为了|ANR-WatchDog|。接着，在注释2处，声明了一个默认的超时间隔时间，默认的值为5000ms。然后，注释3处，在while循环中通过_uiHandler去post一个_ticker Runnable。注意这里的_tick默认是0，所以needPost即为true。接下来，线程会sleep一段时间，默认值为5000ms。在注释4处，如果主线程没有处理Runnable，即_tick的值没有被赋值为0，则说明发生了ANR，第二个_reported标志位是为了避免重复报道已经处理过的ANR。如果发生了ANR，就会调用接下来的代码，开始会处理debug的情况，然后，我们看到注释5处，如果没有主动给ANR_Watchdog设置线程名，则会默认会使用ANRError的NewMainOnly方法去处理ANR。ANRError的NewMainOnly方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The minimum duration, in ms, for which the main thread has been blocked. May be more.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final long duration;</span><br><span class="line"></span><br><span class="line">static ANRError NewMainOnly(long duration) &#123;</span><br><span class="line">    &#x2F;&#x2F; 1、获取主线程的堆栈信息</span><br><span class="line">    final Thread mainThread &#x3D; Looper.getMainLooper().getThread();</span><br><span class="line">    final StackTraceElement[] mainStackTrace &#x3D; mainThread.getStackTrace();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2、返回一个包含主线程名、主线程堆栈信息以及发生ANR的最小时间值的实例。</span><br><span class="line">    return new ANRError(new $(getThreadTitle(mainThread), mainStackTrace).new _Thread(null), duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在注释1处，首先获了主线程的堆栈信息，然后返回了一个包含主线程名、主线程堆栈信息以及发生ANR的最小时间值的实例。（我们可以改造其源码在此时添加更多的卡顿现场信息，如CPU 使用率和调度信息、内存相关信息、I/O 和网络相关的信息等等）</p>
<p>接下来，我们再回到ANRWatchDog的run方法中的注释6处，最后这里会通过ANRListener调用它的onAppNotResponding方法，其默认的处理会直接抛出当前的ANRError，导致程序崩溃。对应的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final ANRListener DEFAULT_ANR_LISTENER &#x3D; new ANRListener() &#123;</span><br><span class="line">    @Override public void onAppNotResponding(ANRError error) &#123;</span><br><span class="line">        throw error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>了解了ANRWatchDog的实现原理之后，我们试一试它的效果如何。首先，我们给MainActivity中的悬浮按钮添加主线程休眠10s的代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@OnClick(&#123;R.id.main_floating_action_btn&#125;)</span><br><span class="line">void onClick(View view) &#123;</span><br><span class="line">    switch (view.getId()) &#123;</span><br><span class="line">        case R.id.main_floating_action_btn:</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 对应项目中的第170行</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            jumpToTheTop();</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们重新安装运行项目，点击悬浮按钮，发现在10s内都不能触发屏幕点击和触摸事件，并且在10s之后，应用直接发生了崩溃。接着，我们在Logcat过滤栏中输入<strong>fatal</strong>关键字，找出致命的错误，log如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">2020-01-18 09:55:53.459 29924-29969&#x2F;? E&#x2F;AndroidRuntime: FATAL EXCEPTION: |ANR-WatchDog|</span><br><span class="line">Process: json.chao.com.wanandroid, PID: 29924</span><br><span class="line">com.github.anrwatchdog.ANRError: Application Not Responding for at least 5000 ms.</span><br><span class="line">Caused by: com.github.anrwatchdog.ANRError$$$_Thread: main (state &#x3D; TIMED_WAITING)</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at java.lang.Thread.sleep(Thread.java:373)</span><br><span class="line">    at java.lang.Thread.sleep(Thread.java:314)</span><br><span class="line">    &#x2F;&#x2F; 1</span><br><span class="line">    at json.chao.com.wanandroid.ui.main.activity.MainActivity.onClick(MainActivity.java:170)</span><br><span class="line">    at json.chao.com.wanandroid.ui.main.activity.MainActivity_ViewBinding$1.doClick(MainActivity_ViewBinding.java:45)</span><br><span class="line">    at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22)</span><br><span class="line">    at android.view.View.performClick(View.java:6311)</span><br><span class="line">    at android.view.View$PerformClick.run(View.java:24833)</span><br><span class="line">    at android.os.Handler.handleCallback(Handler.java:794)</span><br><span class="line">    at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">    at android.os.Looper.loop(Looper.java:173)</span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:6653)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821)</span><br><span class="line"> Caused by: com.github.anrwatchdog.ANRError$$$_Thread: AndroidFileLogger.&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;json.chao.com.wanandroid&#x2F;log&#x2F; (state &#x3D; RUNNABLE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，发生崩溃的线程正是|ANR-WatchDog|。我们重点关注注释1，这里发生崩溃的位置是在MainActivity的onClick方法，对应的行数为170行，从前可知，这里正是线程休眠的地方。</p>
<p>接下来，我们来分析一下ANR-WatchDog的实现原理。</p>
<h3 id="2、ANR-WatchDog原理"><a href="#2、ANR-WatchDog原理" class="headerlink" title="2、ANR-WatchDog原理"></a>2、ANR-WatchDog原理</h3><ul>
<li>  首先，我们调用了ANR-WatchDog的start方法，然后这个线程就会开始工作。</li>
<li>  然后，我们通过主线程的Handler post一个消息将主线程的某个值进行一个加值的操作。</li>
<li>  post完成之后呢，我们这个线程就sleep一段时间。</li>
<li>  在sleep之后呢，它就会来检测我们这个值有没有被修改，如果这个值被修改了，那就说明我们在主线程中执行了这个message，即表明主线程没有发生卡顿，否则，则说明主线程发生了卡顿。</li>
<li>  最后，ANR-WatchDog就会判断发生了ANR，抛出一个异常给我们。</li>
</ul>
<p>最后，ANR-WatchDog的工作流程简图如下所示：</p>
<p>上面我们最后说到，如果检测到主线程发生了卡顿，则会抛出一个ANR异常，这将会导致应用崩溃，这显然不能将这种方案带到线上，那么，<strong>有什么方式能够自定义最后发生卡顿时的处理过程吗？</strong></p>
<p>其实ANR-WatchDog自身就实现了一个我们自身也可以去实现的<strong>ANRListener，通过它，我们就可以对ANR事件去做一个自定义的处理</strong>，比如将堆栈信息压缩后保存到本地，并在适当的时间上传到APM后台。</p>
<h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>ANR-WatchDog是一种非侵入式的ANR监控方案，它能够弥补我们在高版本中没有权限去读取traces.txt文件的问题，需要注意的是，在线上这两种方案我们是结合使用的。</p>
<p>在之前，我们还讲到了<strong>AndroidPerformanceMonitor，那么它和ANR-WatchDog有什么区别呢？</strong></p>
<p>对于AndroidPerformanceMonitor来说，它是监控我们主线程中每一个message的执行，它会在主线程的每一个message的前后打印一个时间戳，然后，我们就可以据此计算每一个message的具体执行时间，但是我们需要注意的是一个message的执行时间通常是非常短暂的，也就是很难达到ANR这个级别。然后我们来看看ANR-WatchDog的原理，它是不管应用是如何执行的，它只会看最终的结果，即sleep 5s之后，我就看主线程的这个值有没有被更改。如果说被改过，就说明没有发生ANR，否则，就表明发生了ANR。</p>
<p>根据这两个库的原理，我们便可以判断出它们分别的适用场景，对于AndroidPerformanceMonitor来说，它适合监控卡顿，因为每一个message它执行的时间并不长。对于ANR-WatchDog来说，它更加适合于ANR监控的补充。</p>
<p>此外，虽然ANR-WatchDog解决了在高版本系统没有权限读取 /data/anr/traces.txt 文件的问题，但是在Java层去获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。如果是对性能要求比较高的应用,可以通过Hook Native层的方式去获得所有线程的堆栈信息，具体为如下两个步骤：</p>
<ul>
<li>  通过libart.so、dlsym调用<a target="_blank" rel="noopener" href="http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_list.cc#1501">ThreadList::ForEach</a>方法，拿到所有的 Native 线程对象。</li>
<li>  遍历线程对象列表，调用<a target="_blank" rel="noopener" href="http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc#1615">Thread::DumpState</a>方法。</li>
</ul>
<p>通过这种方式就大致模拟了系统打印 ANR 日志的流程，但是由于采用的是Hook方式，所以可能会产生一些异常甚至崩溃的情况，这个时候就需要通过 fork 子进程方式去避免这种问题，而且使用 子进程去获取堆栈信息的方式可以做到完全不卡住我们主进程。</p>
<p>但是需要注意的是，fork 进程会导致进程号发生改变，此时需要通过指定 /proc/[父进程 id]的方式重新获取应用主进程的堆栈信息。</p>
<p>通过 Native Hook 的 方式我们实现了一套“无损”获取所有 Java 线程堆栈与详细信息的卡顿监控体系。为了降低上报数据量，建议只有主线程的 Java 线程状态是 WAITING、TIME_WAITING 或者 BLOCKED 的时候，才去使用这套方案。</p>
<h2 id="二、卡顿单点问题检测方案"><a href="#二、卡顿单点问题检测方案" class="headerlink" title="二、卡顿单点问题检测方案"></a><a href=""></a>二、卡顿单点问题检测方案</h2><p>除了自动化的卡顿与ANR监控之外，我们还需要进行卡顿单点问题的检测，因为上述两种检测方案的并不能满足所有场景的检测要求，这里我举一个小栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如我有很多的message要执行，但是每一个message的执行时间</span><br><span class="line">都不到卡顿的阈值，那自动化卡顿检测方案也就不能够检测出卡</span><br><span class="line">顿，但是对用户来说，用户就觉得你的App就是有些卡顿。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除此之外，为了建立体系化的监控解决方案，我们就必须在上线之前将问题尽可能地暴露出来。</p>
<h3 id="1、IPC单点问题检测方案"><a href="#1、IPC单点问题检测方案" class="headerlink" title="1、IPC单点问题检测方案"></a><a href=""></a>1、IPC单点问题检测方案</h3><p>常见的单点问题有主线程IPC、DB操作等等，这里我就拿主线程IPC来说，因为IPC其实是一个很耗时的操作，但是在实际开发过程中，我们可能对IPC操作没有足够的重视，所以，我们经常在主程序中去做频繁IPC操作，所以说，这种耗时它可能并不到你设定卡顿的一个阈值，接下来，我们看一下，对于IPC问题，我们应该去监测哪些指标。</p>
<ul>
<li>  1、IPC调用类型：如PackageManager、TelephoneManager的调用。</li>
<li>  2、每一个的调用次数与耗时。</li>
<li>  3、IPC的调用堆栈（表明哪行代码调用的）、发生线程。</li>
</ul>
<h4 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a><a href=""></a>常规方案</h4><p>常规方案就是在IPC的前后加上埋点。但是，这种方式不够优雅，而且，在平常开发过程中我们经常忘记某个埋点的真正用处，同时它的维护成本也非常大。</p>
<p>接下来，我们讲解一下IPC问题监测的技巧。</p>
<h4 id="IPC问题监测技巧"><a href="#IPC问题监测技巧" class="headerlink" title="IPC问题监测技巧"></a><a href=""></a>IPC问题监测技巧</h4><p>在线下，我们可以通过adb命令的方式来进行监测，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、首先，对IPC操作开始进行监控</span><br><span class="line">adb shell am trace-ipc start</span><br><span class="line">&#x2F;&#x2F; 2、然后，结束IPC操作的监控，同时，将监控到的信息存放到指定的文件当中</span><br><span class="line">adb shell am trace-ipc stop -dump-file &#x2F;data&#x2F;local&#x2F;tmp&#x2F;ipc-trace.txt</span><br><span class="line">&#x2F;&#x2F; 3、最后，将监控到的ipc-trace导出到电脑查看</span><br><span class="line">adb pull &#x2F;data&#x2F;local&#x2F;tmp&#x2F;ipc-trace.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，这里我们介绍一种优雅的实现方案，看过<a href="">深入探索Android布局优化（上）</a>的同学可能知道这里的实现方案无非就是ARTHook或AspectJ这两种方案，这里我们需要去监控IPC操作，那么，我们应该选用哪种方式会更好一些呢？</p>
<p>要回答这个问题，就需要我们对ARTHook和AspectJ这两者的思想有足够的认识，对应ARTHook来说，其实我们可以用它来去Hook系统的一些方法，因为对于系统代码来说，我们无法对它进行更改，但是我们可以Hook住它的一个方法，在它的方法体里面去加上自己的一些代码。但是，对于AspectJ来说，它只能针对于哪些非系统方法，也就是我们App自己的源码，或者是我们所引用到的一些jar、aar包。因为AspectJ实际上是往我们的具体方法里面插入相对于的代码，所以说，他不能够针对于我们的系统方法去做操作，在这里，我们就需要采用ARTHook的方式去进行IPC操作的监控。</p>
<p>在使用ARTHook去监控IPC操作之前，我们首先思考一下，哪些操作是IPC操作呢？</p>
<p>比如说，我们通过PackageManager去拿到我们应用的一些信息，或者去拿到设备的DeviceId这样的信息以及AMS相关的信息等等，这些其实都涉及到了IPC的操作，而这些操作都会通过固定的方式进行IPC，并最终会调用到<strong>android.os.BinderProxy</strong>，接下来，我们来看看它的transact方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们仅仅关注transact方法的参数即可，第一个参数是一个行动编码，为int类型，它是在FIRST_CALL_TRANSACTION与LAST_CALL_TRANSACTION之间的某个值，第二、三个参数都是Parcel类型的参数，用于获取和回复相应的数据，第四个参数为一个int类型的标记值，为0表示一个正常的IPC调用，否则表明是一个单向的IPC调用。然后，我们在项目中的Application的onCreate方法中使用ARTHook对android.os.BinderProxy类的transact方法进行Hook，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        DexposedBridge.findAndHookMethod(Class.forName(&quot;android.os.BinderProxy&quot;), &quot;transact&quot;,</span><br><span class="line">                int.class, Parcel.class, Parcel.class, int.class, new XC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">                        LogHelper.i( &quot;BinderProxy beforeHookedMethod &quot; + param.thisObject.getClass().getSimpleName()</span><br><span class="line">                                + &quot;\n&quot; + Log.getStackTraceString(new Throwable()));</span><br><span class="line">                        super.beforeHookedMethod(param);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新安装应用，即可看到如下的Log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ WanAndroidApp$1.beforeHookedMethod  (WanAndroidApp.java:160)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │    LogHelper.i  (LogHelper.java:37)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [WanAndroidApp.java | 160 | beforeHookedMethod] BinderProxy beforeHookedMethod BinderProxy</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ java.lang.Throwable</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at json.chao.com.wanandroid.app.WanAndroidApp$1.beforeHookedMethod(WanAndroidApp.java:160)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at com.taobao.android.dexposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:237)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.onHookBoolean(Entry64.java:72)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:237)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.booleanBridge(Entry64.java:86)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.os.ServiceManagerProxy.getService(ServiceManagerNative.java:123)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.os.ServiceManager.getService(ServiceManager.java:56)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.os.ServiceManager.getServiceOrThrow(ServiceManager.java:71)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.UiModeManager.&lt;init&gt;(UiModeManager.java:127)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.SystemServiceRegistry$42.createService(SystemServiceRegistry.java:511)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.SystemServiceRegistry$42.createService(SystemServiceRegistry.java:509)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:970)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:920)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ContextImpl.getSystemService(ContextImpl.java:1677)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.view.ContextThemeWrapper.getSystemService(ContextThemeWrapper.java:171)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.Activity.getSystemService(Activity.java:6003)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegateImplV23.&lt;init&gt;(AppCompatDelegateImplV23.java:33)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegateImplN.&lt;init&gt;(AppCompatDelegateImplN.java:31)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegate.create(AppCompatDelegate.java:198)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegate.create(AppCompatDelegate.java:183)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatActivity.getDelegate(AppCompatActivity.java:519)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.support.v7.app.AppCompatActivity.onCreate(AppCompatActivity.java:70)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at me.yokeyword.fragmentation.SupportActivity.onCreate(SupportActivity.java:38)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at json.chao.com.wanandroid.base.activity.AbstractSimpleActivity.onCreate(AbstractSimpleActivity.java:29)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at json.chao.com.wanandroid.base.activity.BaseActivity.onCreate(BaseActivity.java:37)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.Activity.performCreate(Activity.java:7098)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.Activity.performCreate(Activity.java:7089)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1215)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2895)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ActivityThread.-wrap11(Unknown Source:0)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1616)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.os.Looper.loop(Looper.java:173)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at android.app.ActivityThread.main(ActivityThread.java:6653)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)</span><br><span class="line">2020-01-22 19:52:47.657 10683-10683&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，这里弹出了应用中某一个IPC调用的所有堆栈信息。在这里，具体是在AbstractSimpleActivity的onCreate方法中调用了ServiceManager的getService方法，它是一个IPC调用的方法。这样，应用的IPC调用我们就能很方便地捕获到了。</p>
<p>大家可以看到，通过这种方式我们可以很方便地拿到应用中所有的IPC操作，并可以获得到IPC调用的类型、调用耗时、发生次数、调用的堆栈等等一系列信息。当然，除了IPC调用的问题之外，还有IO、DB、View绘制等一系列单点问题需要去建立与之对应的检测方案。</p>
<h4 id="2、卡顿问题检测方案"><a href="#2、卡顿问题检测方案" class="headerlink" title="2、卡顿问题检测方案"></a><a href=""></a>2、卡顿问题检测方案</h4><p>对于卡顿问题检测方案的建设，主要是利用ARTHook去完善线下的检测工具，尽可能地去Hook相对应的操作，以暴露、分析问题。这样，才能更好地实现卡顿的体系还解决方案。</p>
<h2 id="三、如何实现界面秒开？"><a href="#三、如何实现界面秒开？" class="headerlink" title="三、如何实现界面秒开？"></a><a href=""></a>三、如何实现界面秒开？</h2><p>界面的打开速度对用户体验来说是至关重要的，那么如何实现界面秒开呢？</p>
<p>其实界面秒开就是一个小的启动优化，其优化的思想可以借鉴启动速度优化与布局优化的一些实现思路。</p>
<h3 id="1、界面秒开实现"><a href="#1、界面秒开实现" class="headerlink" title="1、界面秒开实现"></a><a href=""></a>1、界面秒开实现</h3><p>首先，我们可以通过Systrace来观察CPU的运行状况，比如有没有跑满CPU；然后，我们在启动优化中学习到的优雅异步以及优雅延迟初始化等等一些方案；其次，针对于我们的界面布局，我们可以使用异步Inflate、X2C、其它的绘制优化措施等等；最后，我们可以使用预加载的方式去提前获取页面的数据，以避免网络或磁盘IO速度的影响，或者也可以将获取数据的方法放到onCreate方法的第一行。</p>
<h4 id="那么我们如何去衡量界面的打开速度呢？"><a href="#那么我们如何去衡量界面的打开速度呢？" class="headerlink" title="那么我们如何去衡量界面的打开速度呢？"></a><a href=""></a>那么我们如何去衡量界面的打开速度呢？</h4><p>通常，我们是通过界面秒开率去统计页面的打开速度的，具体就是计算onCreate到onWindowFocusChanged的时间。当然，在某些特定的场景下，把onWindowFocusChanged作为页面打开的结束点并不是特别的精确，那我们可以去实现一个特定的接口来适配我们的Activity或Fragment，我们可以把那个接口方法作为页面打开的结束点。</p>
<p>那么，除了以上说到的一些界面秒开的实现方式之外，还没有更好的方式呢？</p>
<p>那就是Lancet。</p>
<h3 id="2、Lancet"><a href="#2、Lancet" class="headerlink" title="2、Lancet"></a><a href=""></a>2、Lancet</h3><p>Lancet是一个轻量级的Android AOP框架，它具有如下优势：</p>
<ul>
<li>  1、编译速度快，支持增量编译。</li>
<li>  2、API简单，没有任何多余代码插入apk。（这一点对应包体积优化时至关重要的）</li>
</ul>
<p>然后，我来简单地讲解下Lancet的用法。Lancet自身提供了一些注解用于Hook，如下所示：</p>
<ul>
<li>  @Prxoy：通常是用于对系统API调用的Hook。</li>
<li>  @Insert：经常用于操作App或者是Library当中的一些类。</li>
</ul>
<p>接下来，我们就是使用Lancet来进行一下实战演练。</p>
<p>首先，我们需要在项目根目录的 build.gradle 添加如下依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    classpath &#39;me.ele:lancet-plugin:1.0.5&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，在 app 目录的’build.gradle’ 添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;me.ele.lancet&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly &#39;me.ele:lancet-base:1.0.5&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以使用Lancet了，这里我们需要先新建一个类去进行专门的Hook操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityHooker &#123;</span><br><span class="line"></span><br><span class="line">    @Proxy(&quot;i&quot;)</span><br><span class="line">    @TargetClass(&quot;android.util.Log&quot;)</span><br><span class="line">    public static int i(String tag, String msg) &#123;</span><br><span class="line">        msg &#x3D; msg + &quot;JsonChao&quot;;</span><br><span class="line">        return (int) Origin.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的方法就是对android.util.Log的i方法进行Hook，并在所有的msg后面加上”JsonChao”字符串，注意这里的i方法我们需要从android.util.Log里面将它的i方法复制过来，确保方法名和对应的参数信息一致；然后，方法上面的@TargetClass与@Proxy分别是指定对应的全路径类名与方法名；最后，我们需要通过Lancet提供的Origin类去调用它的call方法来实现返回原来的调用信息。完成之后，我们重新运行项目，会出现如下log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-01-23 13:13:34.124 7277-7277&#x2F;json.chao.com.wanandroid I&#x2F;MultiDex: VM with version 2.1.0 has multidex supportJsonChao</span><br><span class="line">2020-01-23 13:13:34.124 7277-7277&#x2F;json.chao.com.wanandroid I&#x2F;MultiDex: Installing applicationJsonChao</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，log后面都加上了我们预先添加的字符串，说明Hook成功了。下面，我们就可以用Lancet来统计一下项目界面的秒开率了，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static ActivityRecord sActivityRecord;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    sActivityRecord &#x3D; new ActivityRecord();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Insert(value &#x3D; &quot;onCreate&quot;,mayCreateSuper &#x3D; true)</span><br><span class="line">@TargetClass(value &#x3D; &quot;android.support.v7.app.AppCompatActivity&quot;,scope &#x3D; Scope.ALL)</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    sActivityRecord.mOnCreateTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#x2F;&#x2F; 调用当前Hook类方法中原先的逻辑</span><br><span class="line">    Origin.callVoid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Insert(value &#x3D; &quot;onWindowFocusChanged&quot;,mayCreateSuper &#x3D; true)</span><br><span class="line">@TargetClass(value &#x3D; &quot;android.support.v7.app.AppCompatActivity&quot;,scope &#x3D; Scope.ALL)</span><br><span class="line">public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class="line">    sActivityRecord.mOnWindowsFocusChangedTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    LogHelper.i(getClass().getCanonicalName() + &quot; onWindowFocusChanged cost &quot;+(sActivityRecord.mOnWindowsFocusChangedTime - sActivityRecord.mOnCreateTime));</span><br><span class="line">    Origin.callVoid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面，我们通过@TargetClass和@Insert两个注解实现Hook了android.support.v7.app.AppCompatActivity的onCreate与onWindowFocusChanged方法。我们注意到，这里@Insert注解可以指定两个参数，其源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Insert &#123;</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">    boolean mayCreateSuper() default false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个参数mayCreateSuper设定为true则表明如果没有重写父类的方法，则会默认去重写这个方法。对应到我们ActivityHooker里面实现的@Insert注解方法就是如果当前的Activity没有重写父类的onCreate和<br>onWindowFocusChanged方法，则此时默认回去重写父类的这个方法，以避免因某些Activity不存在该方法而Hook失败的情况。</p>
<p>然后，我们注意到@TargetClass也可以指定两个参数，其源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@java.lang.annotation.Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">public @interface TargetClass &#123;</span><br><span class="line">    String value();</span><br><span class="line"></span><br><span class="line">    Scope scope() default Scope.SELF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个参数scope指定的值是一个枚举，可选的值如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum Scope &#123;</span><br><span class="line"></span><br><span class="line">    SELF,</span><br><span class="line">    DIRECT,</span><br><span class="line">    ALL,</span><br><span class="line">    LEAF</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Scope.SELF，它代表仅匹配目标value所指定的一个匹配类；对于DIRECT，它代表匹配value所指定的类的一个直接子类；如果是Scope.ALL，它就表明会去匹配value所指定的类的所有子类，而我们上面指定的value值为android.support.v7.app.AppCompatActivity，因为scope指定为了Scope.ALL，则说明会去匹配AppCompatActivity的所有子类。而最后的Scope.LEAF 代表匹配 value 指定类的最终子类，因为java是单继承，所以继承关系是树形结构，所以这里代表了指定类为顶点的继承树的所有叶子节点。</p>
<p>最后，我们设定了一个ActivityRecord类去记录onCreate与onWindowFocusChanged的时间戳，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityRecord &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * 避免没有仅执行onResume就去统计界面打开速度的情况，如息屏、亮屏等等</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public boolean isNewCreate;</span><br><span class="line"></span><br><span class="line">    public long mOnCreateTime;</span><br><span class="line">    public long mOnWindowsFocusChangedTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过sActivityRecord.mOnWindowsFocusChangedTime - sActivityRecord.mOnCreateTime得到的时间即为界面的打开速度，最后，重新运行项目，会得到如下log信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-01-23 14:12:16.406 15098-15098&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.SplashActivity onWindowFocusChanged cost 257</span><br><span class="line">2020-01-23 14:12:18.930 15098-15098&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.MainActivity onWindowFocusChanged cost 608</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的log信息，我们就可以知道 SplashActivity 和 MainActivity 的界面打开速度分别是257ms和608ms。</p>
<p>最后，我们来看下界面秒开的监控纬度。</p>
<h3 id="3、界面秒开监控纬度"><a href="#3、界面秒开监控纬度" class="headerlink" title="3、界面秒开监控纬度"></a><a href=""></a>3、界面秒开监控纬度</h3><p>对于界面秒开的监控纬度，主要分为以下三个方面：</p>
<ul>
<li>  总体耗时</li>
<li>  生命周期耗时</li>
<li>  生命周期间隔耗时</li>
</ul>
<p>首先，我们会监控界面打开的整体耗时，也就是onCreate到onWindowFocusChanged这个方法的耗时；当然，如果我们是在一个特殊的界面，我们需要更精确的知道界面打开的一个时间，这个我们可以用自定义的接口去实现。其次，我们也需要去监控生命周期的一个耗时，如onCreate、onStart、onResume等等。最后，我们也需要去做生命周期间隔的耗时监控，这点经常被我们所忽略，比如onCreate的结束到onStart开始的这一段时间，也是有时间损耗的，我们可以监控它是不是在一个合理的范围之内。通过这三个方面的监控纬度，我们就能够非常细粒度地去检测页面秒开各个方面的情况。</p>
<h2 id="“四、优雅监控耗时盲区”-四、优雅监控耗时盲区"><a href="#“四、优雅监控耗时盲区”-四、优雅监控耗时盲区" class="headerlink" title=" “四、优雅监控耗时盲区”)四、优雅监控耗时盲区"></a><a href=""></a> “四、优雅监控耗时盲区”)四、优雅监控耗时盲区</h2><p>尽管我们在应用中监控了很多的耗时区间，但是还是有一些耗时区间我们还没有捕捉到，如onResume到列表展示的间隔时间，这些时间在我们的统计过程中很容易被忽视，这里我们举一个小栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们在Activity的生命周期中post了一个message，那这个message很可能其中执行了一段耗时操作，那你知道这个message它的具体执行时间吗？这个message其实很有可能在列表展示之前就执行了，如果这个message耗时1s，那么列表的展示时间就会延迟1s，如果是200ms，那么我们设定的自动化卡顿检测就无法发现它，那么列表的展示时间就会延迟200ms。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实这种场景非常常见，接下来，我们就在项目中来进行实战演练。</p>
<p>首先，我们在MainActivity的onCreate中加上post消息的一段代码，其中模拟了延迟1000ms的耗时操作，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下代码是为了演示Msg导致的主线程卡顿</span><br><span class="line">    new Handler().post(() -&gt; &#123;</span><br><span class="line">        LogHelper.i(&quot;Msg 执行&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，我们在RecyclerView对应的Adapter中将列表展示的时间打印出来，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (helper.getLayoutPosition() &#x3D;&#x3D; 1 &amp;&amp; !mHasRecorded) &#123;</span><br><span class="line">        mHasRecorded &#x3D; true;</span><br><span class="line">        helper.getView(R.id.item_search_pager_group).getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onPreDraw() &#123;</span><br><span class="line">                helper.getView(R.id.item_search_pager_group).getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">                LogHelper.i(&quot;FeedShow&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，我们重新运行下项目，看看两者的执行时间，log信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2020-01-23 15:21:55.076 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [MainActivity.java | 108 | lambda$initEventAndData$1$MainActivity] Msg 执行</span><br><span class="line">2020-01-23 15:21:56.264 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.MainActivity onWindowFocusChanged cost 1585</span><br><span class="line">2020-01-23 15:21:57.207 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ ArticleListAdapter$1.onPreDraw  (ArticleListAdapter.java:93)</span><br><span class="line">2020-01-23 15:21:57.208 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │    LogHelper.i  (LogHelper.java:37)</span><br><span class="line">2020-01-23 15:21:57.208 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄</span><br><span class="line">2020-01-23 15:21:57.208 19091-19091&#x2F;json.chao.com.wanandroid I&#x2F;WanAndroid-LOG: │ [ArticleListAdapter.java | 93 | onPreDraw] FeedShow</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从log信息中可以看到，MAinActivity的onWindowFocusChanged方法延迟了1000ms才被调用，与此同时，列表页时延迟了1000ms才展示出来。也就是说，post的这个message消息是执行在界面、列表展示之前的。因为任何一个开发都有可能在某一个生命周期或者是某一个阶段以及一些第三方的SDK里面，回去做一些handler post的相关操作，这样，他的handler post的message的执行，很有可能在我们的界面或列表展示之前就被执行，所以说，出现这种耗时的盲区是非常普遍的，而且也不好排查，下面，我们分析下耗时盲区存在的难点。</p>
<h3 id="1、耗时盲区监控难点"><a href="#1、耗时盲区监控难点" class="headerlink" title="1、耗时盲区监控难点"></a><a href=""></a>1、耗时盲区监控难点</h3><p>首先，我们可以通过细化监控的方式去获取耗时的一些盲区，但是我们却不知道在这个盲区中它执行了什么操作。其次，对于线上的一些耗时盲区，我们是无法进行排查的。</p>
<p>这里，我们先来看看如何建立耗时盲区监控的线下方案。</p>
<h3 id="2、耗时盲区监控线下方案"><a href="#2、耗时盲区监控线下方案" class="headerlink" title="2、耗时盲区监控线下方案"></a><a href=""></a>2、耗时盲区监控线下方案</h3><p>这里我们直接使用TraceView去检测即可，因为它能够清晰地记录线程在具体的时间内到底做了什么操作，特别适合一段时间内的盲区监控。</p>
<p>然后，我们来看下如何建立耗时盲区监控的线上方案。</p>
<h3 id="3、耗时盲区监控线上方案"><a href="#3、耗时盲区监控线上方案" class="headerlink" title="3、耗时盲区监控线上方案"></a><a href=""></a>3、耗时盲区监控线上方案</h3><p>我们知道主线程的所有方法都是通过message来执行的，还记得在之前我们学习了一个库：AndroidPerformanceMonitor，我们是否可以通过这个mLogging来做盲区检测呢？通过这个mLogging确实可以知道我们主线程发生的message，但是通过mLogging无法获取具体的调用栈信息，因为它所获取的调用栈信息都是系统回调回来的，它并不知道当前的message是被谁抛出来的，所以说，这个方案并不够完美。</p>
<p>那么，我们是否可以通过AOP的方式去切Handler方法呢？比如sendMessage、sendMessageDeleayd方法等等，这样我们就可以知道发生message的一个堆栈，但是这种方案也存在着一个问题，就是它不清楚准确的执行时间，我们切了这个handler的方法，仅仅只知道它具体是在那个地方被调用的和它所对应的堆栈信息，但是无法获取准确的执行时间。如果我们想知道在onResume到列表展示之间执行了哪些message，那么通过AOP的方式也无法实现。</p>
<p>那么，最终的耗时盲区监控的一个线上方案就是使用一个统一的Handler，定制了它的两个方法，一个是sendMessageAtTime，另外一个是dispatchMessage方法。因为对于发送message，不管调用哪个方法最终都会调用到一个是sendMessageAtTime这个方法，而处理message呢，它最终会调用dispatchMessage方法。然后，我们需要定制一个gradle插件，来实现自动化的接入我们定制好的handler，通过这种方式，我们就能在编译期间去动态地替换所有使用Handler的父类为我们定制好的这个handler。这样，在整个项目中，所有的sendMessage和handleMessage都会经过我们的回调方法。接下来，我们来进行一下实战演练。</p>
<p>首先，我这里给出定制好的全局Handler类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class GlobalHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    private long mStartTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    public GlobalHandler() &#123;</span><br><span class="line">        super(Looper.myLooper(), null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlobalHandler(Callback callback) &#123;</span><br><span class="line">        super(Looper.myLooper(), callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlobalHandler(Looper looper, Callback callback) &#123;</span><br><span class="line">        super(looper, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlobalHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">        boolean send &#x3D; super.sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">        &#x2F;&#x2F; 1</span><br><span class="line">        if (send) &#123;</span><br><span class="line">            GetDetailHandlerHelper.getMsgDetail().put(msg, Log.getStackTraceString(new Throwable()).replace(&quot;java.lang.Throwable&quot;, &quot;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return send;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void dispatchMessage(Message msg) &#123;</span><br><span class="line">        mStartTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        super.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">        if (GetDetailHandlerHelper.getMsgDetail().containsKey(msg)</span><br><span class="line">            &amp;&amp; Looper.myLooper() &#x3D;&#x3D; Looper.getMainLooper()) &#123;</span><br><span class="line">            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 2</span><br><span class="line">                jsonObject.put(&quot;Msg_Cost&quot;, System.currentTimeMillis() - mStartTime);</span><br><span class="line">                jsonObject.put(&quot;MsgTrace&quot;, msg.getTarget() + &quot; &quot; + GetDetailHandlerHelper.getMsgDetail().get(msg));</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 3</span><br><span class="line">                LogHelper.i(&quot;MsgDetail &quot; + jsonObject.toString());</span><br><span class="line">                GetDetailHandlerHelper.getMsgDetail().remove(msg);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的GlobalHandler将会是我们项目中所有Handler的一个父类。在注释1处，我们在sendMessageAtTime这个方法里面判断如果message发送成功，将会把当前message对象对应的调用栈信息都保存到一个ConcurrentHashMap中，GetDetailHandlerHelper类的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class GetDetailHandlerHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static ConcurrentHashMap&lt;Message, String&gt; sMsgDetail &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static ConcurrentHashMap&lt;Message, String&gt; getMsgDetail() &#123;</span><br><span class="line">        return sMsgDetail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，我们就能够知道这个message它是被谁发送过来的。然后，在dispatchMessage方法里面，我们可以计算拿到其处理消息的一个耗时，并在注释2处将这个耗时保存到一个jsonObject对象中，同时，我们也可以通过GetDetailHandlerHelper类的ConcurrentHashMap对象拿到这个message对应的堆栈信息，并在注释3处将它们输出到log控制台上，当然，如果是线上监控，则会把这些信息保存到本地，然后选择合适的时间去上传。最后，我们还可以在方法体里面做一个判断，我们设置一个阈值，比如阈值为20ms，超过了20ms就把这些保存好的信息上报到APM后台。</p>
<p>在前面的实战演练中，我们使用了handler post的方式去发送一个消息，通过gradle插件将所有handler的父类替换为我们定制好的GlobalHandler之后，我们就可以优雅地去监控应用中的耗时盲区了。</p>
<p>对于实现全局替换handler的gradle插件，除了使用AspectJ实现之外，这里推荐一个已有的项目：<a target="_blank" rel="noopener" href="https://github.com/didi/DroidAssist">DroidAssist</a>。</p>
<p>然后，重新运行项目，关键的log信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MsgDetail &#123;&quot;Msg_Cost&quot;:1001,&quot;MsgTrace&quot;:&quot;Handler (com.json.chao.com.wanandroid.performance.handler.GlobalHandler) &#123;b0d4d48&#125; \n\tat </span><br><span class="line">com.json.chao.com.wanandroid.performance.handler.GlobalHandler.sendMessageAtTime(GlobalHandler.java:36)\n\tat</span><br><span class="line">json.chao.com.wanandroid.ui.main.activity.MainActivity.initEventAndData$__twin__(MainActivity.java:107)\n\tat&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从以上信息我们不仅可以知道message执行的时间，还可以从对应的堆栈信息中得到发送message的位置，这里的位置是MainActivity的107行，也就是new Handler().post()这一行代码。使用这种方式我们就可以知道在列表展示之前到底执行了哪些自定义的message，我们一眼就可以知道哪些message其实是不符合我们预期的，比如说message的执行时间过长，或者说这个message其实可以延后执行，这个我们都可以根据实际的项目和业务需求进行相应地修改。</p>
<h3 id="4、耗时盲区监控方案总结"><a href="#4、耗时盲区监控方案总结" class="headerlink" title="4、耗时盲区监控方案总结"></a><a href=""></a>4、耗时盲区监控方案总结</h3><p>耗时盲区监控是我们卡顿监控中不可或缺的一个环节，也是卡顿监控全面性的一个重要保障。而需要注意的是，TraceView仅仅适用于线下的一个场景，同时对于TraceView来说，它可以用于监控我们系统的message。而最后介绍的动态替换的方式其实是适合于线上的，同时，它只有应用自身的一个message。</p>
<h2 id="五、卡顿优化技巧总结"><a href="#五、卡顿优化技巧总结" class="headerlink" title="五、卡顿优化技巧总结"></a><a href=""></a>五、卡顿优化技巧总结</h2><h3 id="1、卡顿优化实践经验"><a href="#1、卡顿优化实践经验" class="headerlink" title="1、卡顿优化实践经验"></a><a href=""></a>1、卡顿优化实践经验</h3><p>如果应用出现了卡顿现象，那么可以考虑以下方式进行优化：</p>
<ul>
<li>  首先，对于耗时的操作，我们可以考虑异步或延迟初始化的方式，这样可以解决大多数的问题。但是，大家一定要注意代码的优雅性。</li>
<li>  对于布局加载优化，可以采用AsyncLayoutInflater或者是X2C的方式来优化主线程IO以及反射导致的消耗，同时，需要注意，对于重绘问题，要给与一定的重视。</li>
<li>  此外，内存问题也可能会导致应用界面的卡顿，我们可以通过降低内存占用的方式来减少GC的次数以及时间，而GC的次数和时间我们可以通过log查看。</li>
</ul>
<p>然后，我们来看看卡顿优化的工具建设。</p>
<h3 id="2、卡顿优化工具建设"><a href="#2、卡顿优化工具建设" class="headerlink" title="2、卡顿优化工具建设"></a><a href=""></a>2、卡顿优化工具建设</h3><p>工具建设这块经常容易被大家所忽视，但是它的收益却非常大，也是卡顿优化的一个重点。首先，对于系统工具而言，我们要有一个认识，同时一定要学会使用它，这里我们再回顾一下。</p>
<ul>
<li>  对于Systrace来说，我们可以很方便地看出来它的CPU使用情况。另外，它的开销也比较小。</li>
<li>  对于TraceView来说，我们可以很方便地看出来每一个线程它在特定的时间内做了什么操作，但是TraceView它的开销相对比较大，有时候可能会被带偏优化方向。</li>
<li>  同时，需要注意，StrictMode也是一个非常强大的工具。</li>
</ul>
<p>然后，我们介绍了自动化工具建设以及优化方案。我们介绍了两个工具，AndroidPerformanceMonitor以及ANR-WatchDog。同时针对于AndroidPerformanceMonitor的问题，我们采用了高频采集，以找出重复率高的堆栈这样一种方式进行优化，在学习的过程中，我们不仅需要学会怎样去使用工具，更要去理解它们的实现原理以及各自的使用场景。</p>
<p>同时，我们对于卡顿优化工具的建设也做了细化，对于单点问题，比如说IPC监控，我们通过AOP或者是Hook的手段来做到尽早的发现问题。对于耗时盲区的监控，我们在线上采用的是替换Handler的方式来监控所有子线程message执行的耗时以及调用堆栈。</p>
<p>最后，我们来看一下卡顿监控的指标。我们会计算应用整体的卡顿率，ANR率、界面秒开率以及交换时间、生命周期时间等等。在上报ANR信息的同时，我们也需要上报环境和场景信息，这样不仅方便我们在不同版本之家进行横向对比，同时，也可以结合我们的报警平台在第一时间感知到异常。</p>
<h2 id="六、常见卡顿问题解决方案总结"><a href="#六、常见卡顿问题解决方案总结" class="headerlink" title="六、常见卡顿问题解决方案总结"></a><a href=""></a>六、常见卡顿问题解决方案总结</h2><h3 id="1、CPU资源争抢引发的卡顿问题如何解决？"><a href="#1、CPU资源争抢引发的卡顿问题如何解决？" class="headerlink" title="1、CPU资源争抢引发的卡顿问题如何解决？"></a><a href=""></a>1、CPU资源争抢引发的卡顿问题如何解决？</h3><p>此时，我们的应用不仅应该控制好核心功能的CPU消耗，也需要尽量减少非核心需求的CPU消耗。</p>
<h3 id="2、要注意Android-Java中提供的哪些低效的API？"><a href="#2、要注意Android-Java中提供的哪些低效的API？" class="headerlink" title="2、要注意Android Java中提供的哪些低效的API？"></a><a href=""></a>2、要注意Android Java中提供的哪些低效的API？</h3><p>比如List.removeall方法，它内部会遍历一次需要过滤的消息列表，在已经存在循环列表的情况下会造成CPU资源的冗余使用，此时应该去优化相关的算法，避免使用List.removeall这个方法。</p>
<h3 id="3、如何减少图形处理的CPU消耗？"><a href="#3、如何减少图形处理的CPU消耗？" class="headerlink" title="3、如何减少图形处理的CPU消耗？"></a><a href=""></a>3、如何减少图形处理的CPU消耗？</h3><p>这个时候我们需要使用神器renderscript来图形处理的相关运算，将CPU转换到GPU。关于renderscript的背景知识可以看看笔者之前写的<a target="_blank" rel="noopener" href="https://juejin.im/post/5e1e6cf66fb9a0301828ca0a#heading-25">深入探索Android布局优化（下）</a>。</p>
<h3 id="4、硬件加速长中文字体渲染时造成的卡顿如何解决？"><a href="#4、硬件加速长中文字体渲染时造成的卡顿如何解决？" class="headerlink" title="4、硬件加速长中文字体渲染时造成的卡顿如何解决？"></a><a href=""></a>4、硬件加速长中文字体渲染时造成的卡顿如何解决？</h3><p>此时只能关闭文本TextView的硬件加速，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当开启了硬件加速进行长中文字体的渲染时，首先会调用ViewRootImpl.draw()方法，最后会调用GLES20Canvas.nDrawDisplayList()方法开始通过JNI调整到Native层。在这个方法里，会继续调用OpenGLRenderer.drawDisplayList()方法，它通过调用DisplayList的replay方法，以回放前面录制的DisplayList执行绘制操作。</p>
<p>DisplayList的replay方法会遍历DisplayList中保存的每一个操作。其中渲染字体的操作名是DrawText，当遍历到一个DrawText操作时，会调用OpenGLRender::drawText方法区渲染字体。最终，会在OpenGLRender::drawText方法里去调用Font::render()方法渲染字体，而在这个方法中有一个很关键的操作，即获取字体缓存。我们都知道每一个中文的编码都是不同的，因此中文的缓存效果非常不理想，但是对于英文而言，只需要缓存26个字母就可以了。在Android 4.1.2版本之前对文本的Buffer设置过小，所以情况比较严重，如果你的应用在其它版本的渲染性能尚可，就可以仅仅把Android 4.0.x的硬件加速关闭，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AndroidManifest中</span><br><span class="line">&lt;Applicaiton</span><br><span class="line">        ...</span><br><span class="line">        android:hardwareAccelerated&#x3D;&quot;@bool&#x2F;hardware_acceleration&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; value-v14、value-v15中设置相应的Bool</span><br><span class="line">值即可</span><br><span class="line">&lt;bool name&#x3D;&quot;hardware_acceleration&quot;&gt;false&lt;&#x2F;bool&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，硬件渲染还有一些其它的问题在使用时需要注意，具体为如下所示：</p>
<ul>
<li>  1、在软件渲染的情况下，如果需要重绘某个父View的所有子View，只需要调用这个Parent View的invalidate()方法即可，但如果开启了硬件加速，这么做是行不通的，需要遍历整个子View并调用invalidate()。</li>
<li>  2、在软件渲染的情况下，会常常使用Bitmap重用的方式来节省内存，但是如果开启了硬件加速，这将会无效。</li>
<li>  3、当开启硬件加速的UI在前台运行时，需要耗费额外的内存。当硬件加速的UI切换到后台时，上述额外内存有可能不会释放，这大多存在于Android 4.1.2版本中。</li>
<li>  4、长或宽大于2048像素的Bitmap无法绘制，显示为一片透明。原因是OpenGL的材质大小上限为2048<em>2048，因此对于超过2048像素的Bitmap，需要将其切割成2048</em>2048以内的图片块，最后在显示的时候拼起来。</li>
<li>  5、当UI中存在过渡绘制时，可能会发生花屏，一般来说绘制少于5层不会出现花屏现象，如果有大块红色区域就要十分小心了。</li>
<li>  6、需要注意，关于LAYER_TYPE_SOFTWARE，虽然无论在App打开硬件加速或没有打开硬件加速的时候，都会通过软件绘制Bitmap作为离屏缓存，但区别在于打开硬件加速的时候，Bitmap最终还会通过硬件加速方式drawDisplayList去渲染这个Bitmap。</li>
</ul>
<h2 id="七、卡顿优化的常见问题"><a href="#七、卡顿优化的常见问题" class="headerlink" title="七、卡顿优化的常见问题"></a><a href=""></a>七、卡顿优化的常见问题</h2><h3 id="1、你是怎么做卡顿优化的？"><a href="#1、你是怎么做卡顿优化的？" class="headerlink" title="1、你是怎么做卡顿优化的？"></a><a href=""></a>1、你是怎么做卡顿优化的？</h3><p>从项目的初期到壮大期，最后再到成熟期，每一个阶段都针对卡顿优化做了不同的处理。各个阶段所做的事情如下所示：</p>
<ul>
<li>  1、系统工具定位、解决</li>
<li>  2、自动化卡顿方案及优化</li>
<li>  3、线上监控及线下监测工具的建设</li>
</ul>
<p>我做卡顿优化也是经历了一些阶段，最初我们的项目当中的一些模块出现了卡顿之后，我是通过系统工具进行了定位，我使用了Systrace，然后看了卡顿周期内的CPU状况，同时结合代码，对这个模块进行了重构，将部分代码进行了异步和延迟，在项目初期就是这样解决了问题。但是呢，随着我们项目的扩大，线下卡顿的问题也越来越多，同时，在线上，也有卡顿的反馈，但是线上的反馈卡顿，我们在线下难以复现，于是我们开始寻找自动化的卡顿监测方案，其思路是来自于Android的消息处理机制，主线程执行任何代码都会回到Looper.loop方法当中，而这个方法中有一个mLogging对象，它会在每个message的执行前后都会被调用，我们就是利用这个前后处理的时机来做到的自动化监测方案的。同时，在这个阶段，我们也完善了线上ANR的上报，我们采取的方式就是监控ANR的信息，同时结合了ANR-WatchDog，作为高版本没有文件权限的一个补充方案。在做完这个卡顿检测方案之后呢，我们还做了线上监控及线下检测工具的建设，最终实现了一整套完善，多维度的解决方案。</p>
<h3 id="2、你是怎么样自动化的获取卡顿信息？"><a href="#2、你是怎么样自动化的获取卡顿信息？" class="headerlink" title="2、你是怎么样自动化的获取卡顿信息？"></a><a href=""></a>2、你是怎么样自动化的获取卡顿信息？</h3><p>我们的思路是来自于Android的消息处理机制，主线程执行任何代码它都会走到Looper.loop方法当中，而这个函数当中有一个<strong>mLogging</strong>对象，它会在每个message处理前后都会被调用，而主线程发生了卡顿，那就一定会在dispatchMessage方法中执行了耗时的代码，那我们在这个message执行之前呢，我们可以在子线程当中去postDelayed一个任务，这个Delayed的时间就是我们设定的阈值，如果主线程的messaege在这个阈值之内完成了，那就取消掉这个子线程当中的任务，如果主线程的message在阈值之内没有被完成，那子线程当中的任务就会被执行，它会获取到当前主线程执行的一个堆栈，那我们就可以知道哪里发生了卡顿。</p>
<p>经过实践，我们发现这种方案获取的堆栈信息它不一定是准确的，因为获取到的堆栈信息它很可能是主线程最终执行的一个位置，而真正耗时的地方其实已经执行完成了，于是呢，我们就对这个方案做了一些优化，我们采取了<strong>高频采集</strong>的方案，也就是在一个周期内我们会多次采集主线程的堆栈信息，如果发生了卡顿，那我们就将这些卡顿信息压缩之后上报给APM后台，然后找出重复的堆栈信息，这些重复发生的堆栈大概率就是卡顿发生的一个位置，这样就提高了获取卡顿信息的一个准确性。</p>
<h3 id="3、卡顿的一整套解决方案是怎么做的？"><a href="#3、卡顿的一整套解决方案是怎么做的？" class="headerlink" title="3、卡顿的一整套解决方案是怎么做的？"></a><a href=""></a>3、卡顿的一整套解决方案是怎么做的？</h3><p>首先，针对卡顿，我们采用了<strong>线上、线下工具相结合</strong>的方式，线下工具我们册中医药尽可能早地去暴露问题，而针对于线上工具呢，我们侧重于监控的全面性、自动化以及异常感知的灵敏度。</p>
<p>同时呢，卡顿问题还有很多的难题。比如说<strong>有的代码呢，它不到你卡顿的一个阈值，但是执行过多，或者它错误地执行了很多次，它也会导致用户感官上的一个卡顿</strong>，所以我们在线下通过AOP的方式对常见的耗时代码进行了Hook，然后对一段时间内获取到的数据进行分析，我们就可以知道这些耗时的代码发生的时机和次数以及耗时情况。然后，看它是不是满足我们的一个预期，不满足预期的话，我们就可以直接到线下进行修改。同时，卡顿监控它还有很多容易被忽略的一个<strong>盲区</strong>，比如说生命周期的一个间隔，那对于这种特定的问题呢，我们就采用了编译时注解的方式修改了项目当中所有Handler的父类，对于其中的两个方法进行了监控，我们就可以知道主线程message的执行时间以及它们的调用堆栈。</p>
<p>对于<strong>线上卡顿</strong>，我们除了计算App的卡顿率、ANR率等常规指标之外呢，我们还计算了页面的秒开率、生命周期的执行时间等等。而且，在卡顿发生的时刻，我们也尽可能多地保存下来了当前的一个场景信息，这为我们之后解决或者复现这个卡顿留下了依据。</p>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a><a href=""></a>八、总结</h2><p>恭喜你，如果你看到了这里，你会发现要做好应用的卡顿优化的确不是一件简单的时，它需要你有成体系的知识构建基底。最后，我们再来回顾一下面对卡顿优化，我们已经探索的以下九大主题：</p>
<ul>
<li>  1、卡顿优化分析方法与工具：背景介绍、卡顿分析方法之使用shell命令分析CPU耗时、卡顿优化工具。</li>
<li>  2、自动化卡顿检测方案及优化：卡顿检测方案原理、AndroidPerformanceMonitor实战及其优化。</li>
<li>  3、ANR分析与实战：ANR执行流程、线上ANR监控方式、ANR-WatchDog原理。</li>
<li>  4、卡顿单点问题检测方案：IPC单点问题检测方案、卡顿问题检测方案。</li>
<li>  5、如何实现界面秒开？：界面秒开实现、Lancet、界面秒开监控纬度。</li>
<li>  6、优雅监控耗时盲区：耗时盲区监控难点以及线上与线下的监控方案。</li>
<li>  7、卡顿优化技巧总结：卡顿优化实践经验、卡顿优化工具建设。</li>
<li>  8︎、常见卡顿问题解决方案总结</li>
<li>  9、卡顿优化的常见问题</li>
</ul>
<p>相信看到这里，你一定收获满满，但是要记住，方案再好，也只有自己动手去实践，才能真正地掌握它。<strong>只有重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。</strong></p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a><a href=""></a>参考链接：</h5><hr>
<p>1、<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/308.html">国内Top团队大牛带你玩转Android性能分析与优化 第6章 卡顿优化</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71982">极客时间之Android开发高手课 卡顿优化</a></p>
<p>3、《Android移动性能实战》第四章 CPU</p>
<p>4、《Android移动性能实战》第七章 流畅度</p>
<p>5、<a target="_blank" rel="noopener" href="https://blog.csdn.net/lindroid/article/details/90904947">Android dumpsys cpuinfo 信息解读</a></p>
<p>6、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20448467">如何清楚易懂的解释“UV和PV＂的定义？</a></p>
<p>7、<a target="_blank" rel="noopener" href="https://github.com/uber/nanoscope">nanoscope-An extremely accurate Android method tracing tool</a></p>
<p>8、<a target="_blank" rel="noopener" href="https://github.com/didi/DroidAssist">DroidAssist-A lightweight Android Studio gradle plugin based on Javassist for editing bytecode in Android.</a></p>
<p>9、<a target="_blank" rel="noopener" href="https://github.com/eleme/lancet">lancet-A lightweight and fast AOP framework for Android App and SDK developers</a></p>
<p>10、<a target="_blank" rel="noopener" href="https://github.com/zhengcx/MethodTraceMan">MethodTraceMan-用于快速找到高耗时方法，定位解决Android App卡顿问题</a></p>
<p>11、<a target="_blank" rel="noopener" href="http://www.samirchen.com/linux-cpu-performance/">Linux环境下进程的CPU占用率</a></p>
<p>12、<a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/debug/ftrace?hl=zh-cn">使用 ftrace</a></p>
<p>13、<a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo">profilo-A library for performance traces from production</a></p>
<p>14、<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html">ftrace 简介</a></p>
<p>15、<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp">atrace源码</a></p>
<p>16、<a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06">AndroidAdvanceWithGeektime<br>/ Chapter06</a></p>
<p>17、<a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus">AndroidAdvanceWithGeektime<br>/ Chapter06-plus</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hzp201314.github.io/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/" data-id="ckmlrcyei0002gkufhj3n3rce" data-title="卡顿优化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/24/%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          绘制优化
        
      </div>
    </a>
  
  
    <a href="/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">布局优化</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag">Android架构师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" style="font-size: 10px;">Android架构师</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/24/%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/">绘制优化</a>
          </li>
        
          <li>
            <a href="/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">卡顿优化</a>
          </li>
        
          <li>
            <a href="/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">布局优化</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E9%AB%98%E7%BA%A7%E7%AF%87/">内存优化-高级篇</a>
          </li>
        
          <li>
            <a href="/2021/03/17/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">内存优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Hzp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>