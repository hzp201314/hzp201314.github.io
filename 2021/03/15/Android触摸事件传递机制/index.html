<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android触摸事件传递机制 | Hzp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言一、了解Activity的构成一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android触摸事件传递机制">
<meta property="og:url" content="https://hzp201314.github.io/2021/03/15/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hzp&#39;s Blog">
<meta property="og:description" content="前言一、了解Activity的构成一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-728789ef6cb4f8c6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png">
<meta property="article:published_time" content="2021-03-15T01:00:31.000Z">
<meta property="article:modified_time" content="2021-03-15T02:17:53.516Z">
<meta property="article:author" content="Hzp">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hzp's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hzp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hzp201314.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Android触摸事件传递机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T01:00:31.000Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android触摸事件传递机制
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="一、了解Activity的构成"><a href="#一、了解Activity的构成" class="headerlink" title="一、了解Activity的构成"></a>一、了解Activity的构成</h3><p>一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<h3 id="二、触摸事件的类型"><a href="#二、触摸事件的类型" class="headerlink" title="二、触摸事件的类型"></a>二、触摸事件的类型</h3><p>触摸事件对应的是MotionEvent类，事件的类型主要有如下三种：</p>
<ul>
<li>  ACTION_DOWN</li>
<li>  ACTION_MOVE(移动的距离超过一定的阈值会被判定为ACTION_MOVE操作)</li>
<li>  ACTION_UP</li>
</ul>
<h3 id="三、事件传递的三个阶段"><a href="#三、事件传递的三个阶段" class="headerlink" title="三、事件传递的三个阶段"></a>三、事件传递的三个阶段</h3><ul>
<li>  分发（dispatchTouchEvent）：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件。</li>
<li>拦截（onInterceptTouchEvent）：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。<br>  如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　<ul>
<li>1.如果该View(ViewGroup)存在子View且点击到了该子View, 则不拦截, 继续分发<br>给子View 处理, 此时相当于return false。</li>
<li>2.如果该View(ViewGroup)没有子View或者有子View但是没有点击中子View(此时ViewGroup<br>相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。<br>注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而<br>ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。</li>
</ul>
</li>
</ul>
<ul>
<li><p>消费（onTouchEvent）：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：</p>
<ul>
<li>1.如果该View是clickable或者longclickable的,则会返回true, 表示消费<br>了该事件, 与返回true一样;</li>
<li>2.如果该View不是clickable或者longclickable的,则会返回false, 表示不<br>消费该事件,将会向上传递,与返回false一样.</li>
</ul>
</li>
</ul>
<p>注意：在Android系统中，拥有事件传递处理能力的类有以下三种。</p>
<ul>
<li>  Activity：拥有分发和消费两个方法。</li>
<li>  ViewGroup：拥有分发、拦截和消费三个方法。</li>
<li>  View：拥有分发、消费两个方法。</li>
</ul>
<h3 id="四、Activity对点击事件的分发过程"><a href="#四、Activity对点击事件的分发过程" class="headerlink" title="四、Activity对点击事件的分发过程"></a>四、Activity对点击事件的分发过程</h3><p>我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的设备节点中。而我们的Android 输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。<br>当点击事件产生后，事件会传递给当前的Activity，由Activity中的PhoneWindow完成，PhoneWindow再把事件处理工作交给DecorView，之后再由DecorView将事件处理工作交给ViewGroup。源码流程如下所示：</p>
<h5 id="1-Activity-dispatchTouchEvent"><a href="#1-Activity-dispatchTouchEvent" class="headerlink" title="1.Activity#dispatchTouchEvent"></a>1.Activity#dispatchTouchEvent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 由Activity所附属的Window分发，返回true，事件循环结束</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回false意味着事件没人处理，所有View的onTouchEvent都</span><br><span class="line">    &#x2F;&#x2F; 返回了false，那么Activity的onTouchEvent就会被调用</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-抽象类Window-superDispatchTouchEvent"><a href="#2-抽象类Window-superDispatchTouchEvent" class="headerlink" title="2.抽象类Window#superDispatchTouchEvent"></a>2.抽象类Window#superDispatchTouchEvent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract boolean superDispatchTouchEvent(MotionEvent event);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-唯一实现类PhoneWindow-superDispatchTouchEvent"><a href="#3-唯一实现类PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.唯一实现类PhoneWindow#superDispatchTouchEvent"></a>3.唯一实现类PhoneWindow#superDispatchTouchEvent</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、View的事件分发机制"><a href="#五、View的事件分发机制" class="headerlink" title="五、View的事件分发机制"></a>五、View的事件分发机制</h3><p>事件分发到ViewGroup的dispatchTouchEvent方法，如果它的onInterceptTouchEvent返回true，则由自己处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。如果它的onInterceptTouchEvent返回false，则交给点击事件链上的子View处理，如此循环，完成分发。ViewGroup#dispatchTouchEvent关键源码如下所示：</p>
<h5 id="1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作"><a href="#1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作" class="headerlink" title="1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作"></a>1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Handle an initial down.</span><br><span class="line">if (actionMasked &#x3D;&#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    &#x2F;&#x2F; Throw away all previous state when starting a new touch gesture.</span><br><span class="line">    &#x2F;&#x2F; The framework may have dropped the up or cancel event for the</span><br><span class="line">    &#x2F;&#x2F; previous gesture due to an app switch, ANR, or some other stae change.</span><br><span class="line">    cancelAndClearTouchTarget(ev);</span><br><span class="line">    &#x2F;&#x2F; 在此方法中会重置FLAG_DISALLOW_INTERCEPT</span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-处理当前View是否拦截点击事件"><a href="#2-处理当前View是否拦截点击事件" class="headerlink" title="2.处理当前View是否拦截点击事件"></a>2.处理当前View是否拦截点击事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean interception；</span><br><span class="line">&#x2F;&#x2F; 当事件由ViewGorup的子元素成功处理时，mFirstTouchTarget会被赋值</span><br><span class="line">&#x2F;&#x2F; 并指向子元素，反之，被ViewGroup拦截时，mFirstTouchTarget则为null。</span><br><span class="line">if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在子View中通过requestDisallowInterceptTouchEvent方法来设置</span><br><span class="line">    &#x2F;&#x2F; FLAG_DISALLOW_INTERCEPT,此时ViewGroup将无法拦截除ACTION_DOWN以外的其他事件 </span><br><span class="line">    final boolean disallowIntercept &#x3D; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) !&#x3D; 0;</span><br><span class="line">    if (!disallowIntercept) &#123;</span><br><span class="line">        intercepted &#x3D; onInterceptTouchEvent(ev);</span><br><span class="line">        &#x2F;&#x2F;re store action in case it was changed</span><br><span class="line">        ev.setAction(action);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        intercepted &#x3D; false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; There are no touch targets and this action is not an initial down so this </span><br><span class="line">        &#x2F;&#x2F; view group continues to intercept touches（ACTION_MOVE、ACTION_UP.eg).</span><br><span class="line">        intercepted &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-dispatchTouchEvent-方法剩余的部分源码"><a href="#3-dispatchTouchEvent-方法剩余的部分源码" class="headerlink" title="3.dispatchTouchEvent()方法剩余的部分源码"></a>3.dispatchTouchEvent()方法剩余的部分源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final View[] children &#x3D; mChildren;</span><br><span class="line">    &#x2F;&#x2F; 遍历ViewGroup的子元素，如果子元素能够接受到点击事件，则交给子元素处理。</span><br><span class="line">    for (int i &#x3D; childrenCount - 1;i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line">        final int childIndex &#x3D; customOrder ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">        final View child &#x3D; (preorderedList &#x3D;&#x3D; null) ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line">        if (childWithAccessibilityFocus !&#x3D; null) &#123;</span><br><span class="line">            if (childWithAccessibilityFocus !&#x3D; child) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            childWithAccessibilityFocus &#x3D; null;</span><br><span class="line">            i &#x3D; childrenCount - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 判断触摸点的位置是否在子View的范围内或者子View是否在播放动画，有一项</span><br><span class="line">            &#x2F;&#x2F; 不符合则开始遍历下一个子View。</span><br><span class="line">            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            newTouchTarget &#x3D;&#x3D; getTouchTarget(child);</span><br><span class="line">            if (newTouchTarget !&#x3D; null) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |&#x3D; idBitsToAssign;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime &#x3D; ev.getDownTime();</span><br><span class="line">                if (preorderedList !&#x3D; null) &#123;</span><br><span class="line">                    for (int j &#x3D; 0;j &lt; childrenCOunt;j++) &#123;</span><br><span class="line">                        if (children[childIndex] &#x3D;&#x3D; mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex &#x3D; j;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mLastTouchDownIndex &#x3D; childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX &#x3D;&#x3D; ev.getX();</span><br><span class="line">                mLastTouchDownY &#x3D; ev.getY();</span><br><span class="line">                newTouchTarget &#x3D; addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget &#x3D;&#x3D; true;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"><a href="#4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑" class="headerlink" title="4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"></a>4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits) &#123;</span><br><span class="line">    final int oldAction &#x3D; event.getAction();</span><br><span class="line">    if (cancel || oldAction &#x3D;&#x3D; MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        &#x2F;&#x2F; 有子View，则调用子View的dispatchTouchEvent(event)方法，如果没有子View，</span><br><span class="line">        &#x2F;&#x2F; 则调用super.dispatchTouchEvent(event)方法。</span><br><span class="line">        if (child &#x3D;&#x3D; null) &#123;</span><br><span class="line">            handled &#x3D;&#x3D; super..dispatchTouchEvent(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handled &#x3D; child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-事件传递到View的dispatchTouchEvent"><a href="#5-事件传递到View的dispatchTouchEvent" class="headerlink" title="5.事件传递到View的dispatchTouchEvent()"></a>5.事件传递到View的dispatchTouchEvent()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">        &#x2F;&#x2F; onTouch方法优先级要高于onTouchEvent(event)方法</span><br><span class="line">        if (li !&#x3D; null &amp;&amp; li.mOnTouchListener !&#x3D; null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">            result &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result &#x3D;&#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6-事件传递到View的onTouchEvent"><a href="#6-事件传递到View的onTouchEvent" class="headerlink" title="6.事件传递到View的onTouchEvent()"></a>6.事件传递到View的onTouchEvent()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final int action &#x3D; event.getAction();</span><br><span class="line">    &#x2F;&#x2F; 只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会</span><br><span class="line">    &#x2F;&#x2F; 返回true消耗这个事件。</span><br><span class="line">    if ((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE || （viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) &#x3D;&#x3D; CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        switch(action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                boolean prepressed &#x3D; (mPrivateFlags &amp; PFLAG_PREPRESSED) !&#x3D; 0;</span><br><span class="line">                if ((mPrivatFlags &amp; PFLAG_PRESSED) !&#x3D; 0 || prepressed) &#123;</span><br><span class="line">                    boolean focusTaken &#x3D; false;</span><br><span class="line">                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        if (!focusTaken) &#123;</span><br><span class="line">                            if (mPerformClick &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                mPerformClick &#x3D; new PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-在ACTION-UP事件中会调用performCLick-方法"><a href="#7-在ACTION-UP事件中会调用performCLick-方法" class="headerlink" title="7.在ACTION_UP事件中会调用performCLick()方法"></a>7.在ACTION_UP事件中会调用performCLick()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">    final boolean result;</span><br><span class="line">    final Listenerinfo li &#x3D; mListenerInfo;</span><br><span class="line">    &#x2F;&#x2F; 如果View设置了点击事件，onClick方法就会执行。</span><br><span class="line">    if (li !&#x3D; null &amp;&amp; li.mOnClickListener !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(this);</span><br><span class="line">        result &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由以上源码分析可得出View完整的点击事件传递流程如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e1e469bffad8a95732db704cc161384f8e3c7f0e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323931313033382d35333439643665626233323337326461"><img src="https://upload-images.jianshu.io/upload_images/14601315-728789ef6cb4f8c6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<h3 id="六、总结：点击事件分发的传递规则"><a href="#六、总结：点击事件分发的传递规则" class="headerlink" title="六、总结：点击事件分发的传递规则"></a>六、总结：点击事件分发的传递规则</h3><p>由事件分发的源码分析可知点击事件分发的3个重要方法的关系，用伪代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean diapatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    boolean consume &#x3D; false;</span><br><span class="line">    if (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume &#x3D; onTouchEvent(ev);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        consume &#x3D; child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    return consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一些重要的结论：</p>
<p>1.事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。</p>
<p>2.正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。</p>
<p>3.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p>
<p>4.ViewGroup默认不拦截任何事件（返回false）。</p>
<p>5.View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。</p>
<p>6.View的enable属性不影响onTouchEvent的默认返回值。</p>
<p>7.通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
<p>最终完整的事件分发流程图如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png"><img src="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png"></a> </p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、《Android开发艺术探索》</p>
<p>2、《Android进阶之光》</p>
<p>3、《Android高级进阶》</p>
<p>4、<a target="_blank" rel="noopener" href="http://gityuan.com/2015/09/19/android-touch/">Gityuan Android事件分发机制</a></p>
<p>5、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&mid=2649492294&idx=1&sn=1645fa7730dbb1c627bd374e917cd557&chksm=8eec80b9b99b09af1938836b2f19afc60b46c284050b9f17ceb5018867cd86df1c6a40fe56eb&scene=38#wechat_redirect">通俗理解Android的事件分发机制</a></p>
<p>6、<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/38015afcdb58">Android事件分发机制详解：史上最全面、最易懂</a></p>
<p>7、<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&mid=2247486486&idx=1&sn=7acc1c9dd8c600ad0ec2db7d32f82f1f&chksm=97f6b2a2a0813bb425cf8bf329bf0e856d3769ac8e21ed5a9a6cb7c57b1097c41f94afe4202d&scene=38#wechat_redirect">Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hzp201314.github.io/2021/03/15/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" data-id="ckmafl1i800001kufh8thc728" data-title="Android触摸事件传递机制" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/15/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          View的绘制流程
        
      </div>
    </a>
  
  
    <a href="/2021/03/10/Android%E9%AB%98%E7%BA%A7%E7%AF%87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android高级篇</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag">Android架构师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" style="font-size: 10px;">Android架构师</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">Android启动速度优化</a>
          </li>
        
          <li>
            <a href="/2021/03/16/%E9%AB%98%E7%BA%A7UI%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%80%A6%E8%AE%BE%E8%AE%A1/">高级UI组件定制与解耦设计</a>
          </li>
        
          <li>
            <a href="/2021/03/15/Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">Android稳定性优化</a>
          </li>
        
          <li>
            <a href="/2021/03/15/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">View的绘制流程</a>
          </li>
        
          <li>
            <a href="/2021/03/15/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/">Android触摸事件传递机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Hzp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>