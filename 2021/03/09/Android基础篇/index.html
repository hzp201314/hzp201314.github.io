<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android基础篇 | Hzp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1、什么是ANR 如何避免它？答：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application NotResponding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要这样，这样系统就不会显示ANR给用户。 不同的组件发">
<meta property="og:type" content="article">
<meta property="og:title" content="Android基础篇">
<meta property="og:url" content="https://hzp201314.github.io/2021/03/09/Android%E5%9F%BA%E7%A1%80%E7%AF%87/index.html">
<meta property="og:site_name" content="Hzp&#39;s Blog">
<meta property="og:description" content="1、什么是ANR 如何避免它？答：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application NotResponding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要这样，这样系统就不会显示ANR给用户。 不同的组件发">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-5326820de2bdbbff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-08ae87bc89ff6a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-3d147d11ab67e075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-e7043716da007c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210310134117654.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210310134218406.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210310134333084.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210310134502042.png">
<meta property="article:published_time" content="2021-03-09T05:41:14.000Z">
<meta property="article:modified_time" content="2021-03-26T01:32:07.863Z">
<meta property="article:author" content="Hzp">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/14601315-5326820de2bdbbff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hzp's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hzp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hzp201314.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Android基础篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/09/Android%E5%9F%BA%E7%A1%80%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2021-03-09T05:41:14.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android基础篇
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1、什么是ANR-如何避免它？"><a href="#1、什么是ANR-如何避免它？" class="headerlink" title="1、什么是ANR 如何避免它？"></a>1、什么是ANR 如何避免它？</h3><p>答：在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应<br>用程序无响应（ANR：Application NotResponding）对话框。<br>用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此<br>，在程序里对响应性能的设计很重要这样，这样系统就不会显示ANR给用户。</p>
<p>不同的组件发生ANR的时间不一样，Activity是5秒，BroadCastReceiver是10秒，Service是20秒（均为前台）。</p>
<span id="more"></span>

<p>如果开发机器上出现问题，我们可以通过查看**/data/anr/traces.txt**即可，最新的ANR信息在最开始部分。</p>
<ul>
<li><p>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</p>
</li>
<li><p>主线程中存在耗时的计算</p>
</li>
<li><p>主线程中错误的操作，比如Thread.wait或者Thread.sleep等 </p>
</li>
</ul>
<p>Android系统会监控程序的响应状况。一旦出现下面几种情况，则弹出ANR对话框</p>
<ul>
<li><p>应用在5秒内未响应用户的输入事件（如按键或者触摸）</p>
</li>
<li><p>BroadcastReceiver未在10秒内完成相关的处理</p>
</li>
<li><p>Service在特定的时间内无法处理完成 20秒</p>
</li>
</ul>
<p><strong>解决方案：</strong><br>1、使用AsyncTask处理耗时IO操作。<br>2、使用Thread或者HandlerThread时，调用<code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</code>设置优先级，优先级过高会影响主线程执行效率降低，因此需要<strong>降低</strong>子线程优先级保证主线程能够及时响应用户操作，默认Thread的优先级和主线程相同。<br>3、使用Handler处理工作线程结果，而不是使用<code>Thread.wait()</code>或者<code>Thread.sleep()</code>来阻塞主线程。<br>4、Activity的<code>onCreate()</code>和<code>onResume()</code>回调中尽量避免耗时的代码。BroadcastReceiver中<code>onReceive()</code>代码也要尽量减少耗时，建议使用IntentService处理。</p>
<p>将所有耗时操作，比如访问网络，Socket通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然后通过handler.sendMessage、runonUIThread、AsyncTask、RxJava等方式更新UI。无论如何都要确保用户界面的流畅度。如果耗时操作需要让用户等待，那么可以在界面上显示度条。</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&mid=2649493643&idx=1&sn=34b51d1f61bd2ecaa8fd0a2d39c4d1d1&chksm=8eec9b74b99b126246acc4547597dfe55c836b8f689b2d1a65bdf1ee2054ced2fc070bfa2678&mpshare=1&scene=24&srcid=0116vzNfMMv2dLizhAT8mEYq#rd">深入理解</a></p>
<h3 id="2、Activity和Fragment生命周期有哪些？"><a href="#2、Activity和Fragment生命周期有哪些？" class="headerlink" title="2、Activity和Fragment生命周期有哪些？"></a>2、Activity和Fragment生命周期有哪些？</h3><p><img src="https://upload-images.jianshu.io/upload_images/14601315-5326820de2bdbbff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity和Fragment生命周期"><br>Activity:onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestory，onReStart</p>
<p>Fragment:<br>onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onViewCreated()<br>-&gt;Activity:onCreate()-&gt;onActivityCreated()<br>-&gt;Activity:onStart()-&gt;onStart()<br>-&gt;Activity:onResume()-&gt;onResume():Fragment完全初始化完毕<br>-&gt;onPause()-&gt;Activity:onPause()<br>-&gt;onStop()-&gt;Activity:onStop()<br>-&gt;onDestoryView()-&gt;onDestory()-&gt;onDetach()-&gt;Activity:onDestory()</p>
<h3 id="3、横竖屏切换时候Activity的生命周期"><a href="#3、横竖屏切换时候Activity的生命周期" class="headerlink" title="3、横竖屏切换时候Activity的生命周期"></a>3、横竖屏切换时候Activity的生命周期</h3><table>
<thead>
<tr>
<th>Android[API]</th>
<th>不配置<code>android:configChanges=&quot;&quot;</code></th>
<th>orientation</th>
<th>orientation|keyboardHidden</th>
<th>orientation|keyboardHidden|screenSize</th>
</tr>
</thead>
<tbody><tr>
<td>Android2.3[API13]<strong>之前</strong></td>
<td>切换横屏调用生命周期一次，切换竖屏调用两次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>不调用生命周期，但会调用onConfigurationChanged()方法</td>
<td>不调用生命周期，但会调用onConfigurationChanged()方法</td>
</tr>
<tr>
<td>Android2.3[API13]</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>不调用生命周期，但会调用onConfigurationChanged()方法</td>
</tr>
<tr>
<td>Android5.1.1[API22]</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>不调用生命周期，但会调用onConfigurationChanged()方法</td>
</tr>
<tr>
<td>Android10.0[API29]</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>切换横竖屏各调用一次生命周期</td>
<td>不调用生命周期，但会调用onConfigurationChanged()方法</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>configChanges属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>orientation</strong></td>
<td>屏幕在纵向和横向间旋转</td>
</tr>
<tr>
<td><strong>keyboardHidden</strong></td>
<td>键盘显示或隐藏</td>
</tr>
<tr>
<td><strong>screenSize</strong></td>
<td>屏幕大小改变了</td>
</tr>
<tr>
<td>fontScale</td>
<td>用户变更了首选的字体大小</td>
</tr>
<tr>
<td>locale</td>
<td>用户选择了不同的语言设定</td>
</tr>
<tr>
<td>keyboard</td>
<td>键盘类型变更，例如手机从12键盘切换到全键盘</td>
</tr>
<tr>
<td>touchscreen</td>
<td>键盘方式变化，一般不会发生这样的事件</td>
</tr>
<tr>
<td>navigation</td>
<td>导航方式变化，一般不会发生这样的事件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>screenOrientation属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>unspecified</td>
<td>默认值，由系统判断状态自动切换</td>
</tr>
<tr>
<td>landscape</td>
<td>横屏</td>
</tr>
<tr>
<td>portrait</td>
<td>竖屏</td>
</tr>
<tr>
<td>user</td>
<td>用户当前设置的orientation值</td>
</tr>
<tr>
<td>behind</td>
<td>下一个要显示的Activity的orientation值</td>
</tr>
<tr>
<td>sensor</td>
<td>使用传感器 传感器的方向</td>
</tr>
<tr>
<td>nosensor</td>
<td>不使用传感器 基本等同于unspecified</td>
</tr>
</tbody></table>
<p>1）、Android 3.2 (API 13) 之前：</p>
<p>不设置 Activity 的 android:configChanges 时，切屏会重新调用生命周期，切横屏会调用一次，切竖屏会调用两次。<br>设置 Activity 的 android:configChanges=”orientation” 时，切屏会重新调用生命周期，且横竖屏都是调用一次生命周期。<br>设置 Activity 的 android:configChanges=”orientation|keyboardHidden” 时，切屏不会重新调用 Activity 的生命周期，但是会调用 onConfigurationChanges() 方法。</p>
<p>2）、从Android 3.2 (API 13) 开始</p>
<p>不设置 Activity 的 android:configChanges 时、设置 Activity 的 android:configChanges=”orientation”<br>设置 Activity 的 android:configChanges=”orientaion|keyboardHidden”时切换横屏和竖屏都会重新调用一次生命周期。<br>设置 Activity 的 android:configChanges=”orientation|screenSize”时不会重新调用 Activity 的生命周期，但是会调用 onConfigurationChanges() 方法。</p>
<h3 id="4、AsyncTask的缺陷和问题，以及原理。"><a href="#4、AsyncTask的缺陷和问题，以及原理。" class="headerlink" title="4、AsyncTask的缺陷和问题，以及原理。"></a>4、AsyncTask的缺陷和问题，以及原理。</h3><p><strong>AsyncTask是什么？</strong></p>
<p> AsyncTask是一种<strong>轻量级的异步任务类</strong>，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。<br>AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示参数的类型，Progress表示后台任务的执行进度和类型，而Result则表示后台任务的返回结果的类型，如果AsyncTask不需要传递具体的参数，那么这三个泛型参数可以用Void来代替。</p>
<p><strong>关于线程池：</strong></p>
<p>AsyncTask对应的线程池ThreadPoolExecutor都是进程范围内共享的，且都是static的，所以是Asynctask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0后默认串行执行，不会出现个问题)。针对这种情况，可以尝试自定义线程池，配合Asynctask使用。</p>
<p><strong>关于默认线程池：</strong></p>
<p>AsyncTask里面线程池是一个核心线程数为CPU + 1，最大线程数为CPU * 2 + 1，工作队列长度为128的线程池，线程等待队列的最大等待数为128，但是可以自定义线程池。线程池是由AsyncTask来处理的，线程池允许tasks并行运行，需要注意的是并发情况下数据的一致性问题，新数据可能会被老数据覆盖掉。所以希望tasks能够串行运行的话，使用SERIAL_EXECUTOR。</p>
<p><strong>AsyncTask在不同的SDK版本中的区别：</strong></p>
<p>调用AsyncTask的<code>execute()</code>方法不能立即执行程序的原因及改善方案通过查阅官方文档发现，AsyncTask首次引入时，异步任务是在一个独立的线程中顺序的执行，也就是说<strong>一次只执行一个任务，不能并行的执行</strong>，从<strong>1.6</strong>开始，AsyncTask引入了线程池，<strong>支持同时执行5个异步任务，也就是说只能有5个线程运行</strong>，超过的线程只能等待，等待前的线程直到某个执行完了才被调度和运行。换句话说，如果进程中的AsyncTask实例个数超过5个，那么假如前5都运行很长时间的话，那么第6个只能等待机会了。这是AsyncTask的一个限制，而且对于2.3以前的版本无法解决。如果你的应用需要大量的后台线程去执行任务，那么只能放弃使用AsyncTask，自己创建线程池来管理Thread。不得不说，虽然AsyncTask较Thread使用起来方便，但是它最多只能同时运行5个线程，这也大大局限了它的作用，你必须要小心设计你的应用，错开使用AsyncTask时间，尽力做到分时，或者保证数量不会大于5个，否就会遇到上面提到的问题。可能是Google意识到了AsynTask的局限性了，从<strong>Android 3.0</strong>开始对AsyncTask的API做出了一些调整：<strong>每次只启动一个线程执行一个任务</strong>，完了之后再执行第二个任务，也就是相当于只有一个后台线程在执行所提交的任务。</p>
<p><strong>一些问题：</strong></p>
<p>1.生命周期</p>
<p>很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsynTask会一直执行，直到<code>doInBackground()</code>方法执行完毕，然后，如果<code>cancel(boolean)</code>被调用,那么<code>onCancelled(Result result)</code>方法会被执行；否则，执行``onPostExecute(Result result)`方法。如果我们的Activity销毁之前，没有取消AsyncTask，这有可能让我们的应用崩溃(crash)。因为它想要处理的view已经不存在了。所以，我们是必须<strong>确保在销毁活动之前取消任务</strong>。总之，我们使用AsyncTask需要确保AsyncTask正确的取消。</p>
<p>2.内存泄漏</p>
<p>如果AsyncTask被声明为Activity的非静态内部类，那么AsyncTask会保留一个对Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄漏。</p>
<p>3.结果丢失</p>
<p>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。</p>
<p>4.并行还是串行</p>
<p>在Android1.6之前的版本，AsyncTask是串行的，在1.6之后的版本，采用线程池处理并行任务，但是从Android 3.0开始，为了避免AsyncTask所带来的并发错误，又采用一个线程来串行执行任务。可以使用<code>executeOnExecutor()</code>方法来并行地执行任务。</p>
<p><strong>AsyncTask原理</strong></p>
<ul>
<li>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于任务的排队，而线程池THREAD_POOL_EXECUTOR用于真正地执行任务，InternalHandler用于将执行环境从线程池切换到主线程。</li>
<li>InternalHandler是一个静态的Handler对象，为了能够将执行环境切换到主线程，这就要求sHandler这个对象必须在主线程创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都将无法正常工作。</li>
</ul>
<h3 id="5、onSaveInstanceState-与-onRestoreIntanceState"><a href="#5、onSaveInstanceState-与-onRestoreIntanceState" class="headerlink" title="5、onSaveInstanceState() 与 onRestoreIntanceState()"></a>5、onSaveInstanceState() 与 onRestoreIntanceState()</h3><p>Activity的 <code>onSaveInstanceState() </code>和 <code>onRestoreInstanceState()</code>并不是生命周期方法，它们不同于 <code>onCreate()</code>、<code>onPause()</code>等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由<strong>系统</strong>销毁一个Activity时，<code>onSaveInstanceState() </code>会被调用。但是当<strong>用户</strong>主动去销毁一个Activity时，例如在应用中按返回键，<code>onSaveInstanceState()</code>就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。通常<code>onSaveInstanceState()</code>只适合用于保存一些临时性的状态，而<code>onPause()</code>适合用于数据的持久化保存。在activity被杀掉之前调用保存每个实例的状态,以保证该状态可以在<code>onCreate(Bundle)</code>或者<code>onRestoreInstanceState(Bundle)</code> (传入的Bundle参数是由onSaveInstanceState封装好的)中恢复。这个方法在一个activity被杀死前调用，当该activity在将来某个时刻回来时可以恢复其先前状态。例如，如果activity B启用后位于activity A的前端，在某个时刻activity A因为系统回收资源的问题要被杀掉，A通过onSaveInstanceState将有机会保存其用户界面状态，使得将来用户返回到activity A时能通过<code>onCreate(Bundle)</code>或者<code>onRestoreInstanceState(Bundle)</code>恢复界面的状态。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/89e0a7533dbe">深入理解</a></p>
<h3 id="6、android中进程的优先级？"><a href="#6、android中进程的优先级？" class="headerlink" title="6、android中进程的优先级？"></a>6、android中进程的优先级？</h3><p><strong>1. 前台进程：</strong><br>即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最晚被杀死的</p>
<p><strong>2. 可见进程：</strong><br>可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失了焦点而不能与用户交互</p>
<p><strong>3. 服务进程：</strong><br>其中运行着使用<code>startService()</code>方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面下载的文件等；当系统要空间运行，前两者进程才会被终止</p>
<p><strong>4. 后台进程：</strong><br>其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这时的进程系统一旦没了有内存就首先被杀死</p>
<p><strong>5. 空进程：</strong><br>不包含任何应用程序的进程，这样的进程系统是一般不会让他存在的</p>
<h3 id="7、Bunder传递对象为什么需要序列化？Serialzable和Parcelable的区别？"><a href="#7、Bunder传递对象为什么需要序列化？Serialzable和Parcelable的区别？" class="headerlink" title="7、Bunder传递对象为什么需要序列化？Serialzable和Parcelable的区别？"></a>7、Bunder传递对象为什么需要序列化？Serialzable和Parcelable的区别？</h3><p>因为bundle传递数据时只支持基本数据类型，所以在传递对象时需要序列化转换成<strong>可存储或可传输的本质状态（字节流）</strong>。序列化后的对象可以在网络、IPC（比如启动另一个进程的Activity、Service和Reciver）之间进行传输，也可以存储到本地。</p>
<p><strong>Serializable（Java自带）：</strong><br>Serializable 是序列化的意思，表示将一个对象转换成存储或可传输的状态。序列化后的对象可以在网络上进传输，也可以存储到本地。</p>
<p><strong>Parcelable（android专用）：</strong><br>除了Serializable之外，使用Parcelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这也就实现传递对象的功能了。</p>
<p><strong>区别总结：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Serializable接口</th>
<th>Parcelable接口</th>
</tr>
</thead>
<tbody><tr>
<td>平台</td>
<td>Java序列化接口</td>
<td>Android序列化接口</td>
</tr>
<tr>
<td>序列化原理</td>
<td>将一个对象转化为可存储或可传输的状态</td>
<td>将一个对象进行分解，且分解后的每一部分都是传递可支持的数据类型</td>
</tr>
<tr>
<td>优缺点</td>
<td>简单但效率较低，开销大。序列化(ObjectOutputStream类)和反序列化(ObjectInputStream类)过程都需要大量的I/O操作</td>
<td>高效但使用麻烦</td>
</tr>
<tr>
<td>使用场景</td>
<td>适合将对象序列化后存储到设备或者将对象序列化后通过网络设备传输</td>
<td>主要用在内存的序列化</td>
</tr>
</tbody></table>
<h3 id="8、动画"><a href="#8、动画" class="headerlink" title="8、动画"></a>8、动画</h3><ul>
<li><strong>tween 补间动画</strong>。通过指定View的初末状态和变化方式，对View的内容完成一系列的图形变换来实现动画效果。 Alpha, Scale ,Translate, Rotate。</li>
<li><strong>frame 帧动画</strong>。AnimationDrawable控制animation-list.xml布局</li>
<li><strong>PropertyAnimation 属性动画</strong>。3.0引入，属性动画核心思想是对值的变化。</li>
</ul>
<p>Property Animation 动画有两个步聚：<br>1.计算属性值<br>2.为目标对象的属性设置属性值，即应用和刷新动画<br><img src="https://upload-images.jianshu.io/upload_images/14601315-08ae87bc89ff6a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>计算属性分为3个过程：<br><strong>1.计算已完成动画分数 elapsed fraction：</strong><br>为了执行一个动画，你需要创建一个ValueAnimator，并且指定目标对象属性的开始、结束和持续时间。在调用 start 后的整个动画过程中，ValueAnimator 会根据已经完成的动画时间计算得到一个0 到 1 之间的分数，代表该动画的已完成动画百分比。0表示 0%，1 表示 100%。</p>
<p><strong>2.计算插值（动画变化率）interpolated fraction ：</strong><br>当 ValueAnimator计算完已完成的动画分数后，它会调用当前设置的TimeInterpolator，去计算得到一个interpolated（插值）分数，在计算过程中，已完成动画百分比会被加入到新的插值计算中。</p>
<p><strong>3.计算运动中的属性值：</strong><br>计算属性值当插值分数计算完成后，ValueAnimator会根据插值分数调用合适的 TypeEvaluator去计算运动中的属性值。<br>以上分析引入了两个概念：已完成动画分数（elapsed fraction）、插值分数( interpolated fraction )。</p>
<p><strong>原理及特点：</strong><br>1.属性动画：<br>插值器：作用是根据时间流逝的百分比来计算属性变化的百分比(已在API中定义好的)<br>估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类<br>其实就是利用插值器和估值器，来计出各个时刻View的属性，然后通过改变View的属性来实现View的动画效果。</p>
<p>2.View动画:<br>只是影像变化，view的实际位置还在原来地方。</p>
<p>3.帧动画：<br>是在xml中定义好一系列图片之后，使用AnimatonDrawable来播放的动画。</p>
<p><strong>它们的区别：</strong><br>属性动画才是真正的实现了 view 的移动，补间动画对view 的移动更像是在不同地方绘制了一个影子，实际对象还是处于原来的地方。<br>当动画的 repeatCount 设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没问题。<br>xml 文件实现的补间动画，复用率极高。在 Activity切换，窗口弹出时等情景中有着很好的效果。<br>使用帧动画时需要注意，不要使用过多特别大的图，容导致内存不足。</p>
<p><strong>为什么属性动画移动后仍可点击？</strong><br>播放补间动画的时候，我们所看到的变化，都只是临时的。而属性动画呢，它所改变的东西，却会更新到这个View所对应的矩阵中，所以<strong>当ViewGroup分派事件的时候，会正确的将当前触摸坐标，转换成矩阵变化后的坐标</strong>，这就是为什么播放补间动画不会改变触摸区域的原因了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ObjectAnimator基本使用继承子ValueAnimator</span></span><br><span class="line"><span class="comment">    * 对对象v的alpha参数进行操作，alpha的值从1.0变到0.3</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startObjectAnimatorAnim</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(v, <span class="string">&quot;alpha&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.3f</span>);</span><br><span class="line">       <span class="comment">//执行事件</span></span><br><span class="line">       alphaAnim.setDuration(<span class="number">1000</span>);</span><br><span class="line">       <span class="comment">//延迟</span></span><br><span class="line">       alphaAnim.setStartDelay(<span class="number">300</span>);</span><br><span class="line">       alphaAnim.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在一段时间内生成连续的值完成view的缩放</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startValueAnimatorAnim</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//不改变属性大小，只在一段事件内生成连续的值</span></span><br><span class="line">       ValueAnimator animator = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">100f</span>);</span><br><span class="line">       animator.setDuration(<span class="number">500</span>);</span><br><span class="line">       animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//百分比对应的值</span></span><br><span class="line">               <span class="keyword">float</span> value = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">               Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onAnimationUpdate: &quot;</span> + value);</span><br><span class="line">               v.setScaleX(<span class="number">0.5f</span> + value / <span class="number">200</span>);</span><br><span class="line">               v.setScaleY(<span class="number">0.5f</span> + value / <span class="number">200</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       animator.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一个动画实现多个效果的变换</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPropertyValueHolderAnim</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       PropertyValuesHolder alphaProper = PropertyValuesHolder.ofFloat(<span class="string">&quot;alpha&quot;</span>, <span class="number">0.5f</span>, <span class="number">1f</span>);</span><br><span class="line">       PropertyValuesHolder scaleXProper = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleX&quot;</span>, <span class="number">0.5f</span>, <span class="number">1f</span>);</span><br><span class="line">       PropertyValuesHolder scaleYProper = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleY&quot;</span>, <span class="number">0.5f</span>, <span class="number">1f</span>);</span><br><span class="line">       ValueAnimator animator = ObjectAnimator.ofPropertyValuesHolder(v, alphaProper, scaleXProper, scaleYProper);</span><br><span class="line">       animator.setDuration(<span class="number">500</span>);</span><br><span class="line">       animator.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行多个动画并控制动画顺序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimatorSet</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       ObjectAnimator animator1 = ObjectAnimator.ofFloat(v, <span class="string">&quot;translationX&quot;</span>, <span class="number">0f</span>, <span class="number">100f</span>);</span><br><span class="line">       ObjectAnimator animator2 = ObjectAnimator.ofFloat(v, <span class="string">&quot;alpha&quot;</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">       ObjectAnimator animator3 = ObjectAnimator.ofFloat(v, <span class="string">&quot;scaleX&quot;</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">       AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">       animatorSet.setDuration(<span class="number">500</span>);</span><br><span class="line">       <span class="comment">//动画1，2同时执行</span></span><br><span class="line">       animatorSet.play(animator1).with(animator2);</span><br><span class="line">       <span class="comment">//动画2执行完成后执行动画3</span></span><br><span class="line">       animatorSet.play(animator3).after(animator2);</span><br><span class="line">       animatorSet.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 估值器：</span></span><br><span class="line"><span class="comment">	 * 估值器可以自定义变换规则,普通动画是匀速执行</span></span><br><span class="line"><span class="comment">    * 使用估值器实现重力下落</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startEvaluator</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line">       ValueAnimator animator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">       animator.setDuration(<span class="number">3000</span>);</span><br><span class="line">       animator.setObjectValues(<span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="keyword">final</span> PointF pointF = <span class="keyword">new</span> PointF();</span><br><span class="line">       animator.setEvaluator(<span class="keyword">new</span> TypeEvaluator() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class="line">               <span class="comment">//fraction是运动中的匀速变化的值</span></span><br><span class="line">               <span class="comment">//根据重力计算实际的运动y=vt=0.5*g*t*t</span></span><br><span class="line">               <span class="comment">//g越大效果越明显</span></span><br><span class="line">               pointF.x = <span class="number">100</span> * (fraction * <span class="number">5</span>);</span><br><span class="line">               pointF.y = <span class="number">0.5f</span> * <span class="number">300f</span> * (fraction * <span class="number">5</span>) * (fraction * <span class="number">5</span>);</span><br><span class="line">               <span class="keyword">return</span> pointF;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">               PointF p = (PointF) animation.getAnimatedValue();</span><br><span class="line">               v.setX(p.x);</span><br><span class="line">               v.setY(p.y);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       animator.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *插值器</span></span><br><span class="line"><span class="comment">    *已经定义好计算规则的估值器(API中已经定义好了算法)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//加速插值器，参数越大，速度越来越快</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator(<span class="number">10</span>));</span><br><span class="line">   <span class="comment">//减速插值器，和上面相反</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator(<span class="number">10</span>));</span><br><span class="line">   <span class="comment">//先加速后减速插值器</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> AccelerateDecelerateInterpolator());</span><br><span class="line">   <span class="comment">//张力值，默认为2，T越大，初始的偏移越大，而且速度越快</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> AnticipateInterpolator(<span class="number">3</span>));</span><br><span class="line">   <span class="comment">//张力值tension，默认为2，张力越大，起始时和结束时的偏移越大</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> AnticipateOvershootInterpolator(<span class="number">6</span>));</span><br><span class="line">   <span class="comment">//弹跳插值器</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> BounceInterpolator());</span><br><span class="line">   <span class="comment">//周期插值器</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">2</span>));</span><br><span class="line">   <span class="comment">//线性差值器,匀速</span></span><br><span class="line">   animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br></pre></td></tr></table></figure>



<h3 id="9、Context相关"><a href="#9、Context相关" class="headerlink" title="9、Context相关"></a>9、Context相关</h3><ul>
<li><p>1、Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper。其他的继承自ContextWrapper。</p>
</li>
<li><p>2、每一个Activity和Service以及Application的Context是一个新的ContextImpl对象。</p>
</li>
<li><p>3、<code>getApplication()</code>用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那也许在绝大多数情况下我们都是在Activity或者Servic中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助<code>getApplicationContext()</code>方法，<code>getApplicationContext()</code>比<code>getApplication()</code>方法的作用域会更广一些，任何一个Context的实例，只要调用<code>getApplicationContext()</code>方法都可以拿到我们的Application对象。</p>
</li>
<li><p>4、创建对话框时不可以用Application的context，只能用Activity的context。</p>
</li>
<li><p>5、Context的数量等于Activity的个数 + Service的个数 +1，这个1为Application。</p>
</li>
</ul>
<h3 id="10、Android各版本新特性"><a href="#10、Android各版本新特性" class="headerlink" title="10、Android各版本新特性"></a>10、Android各版本新特性</h3><p><strong>Android5.0新特性</strong></p>
<ul>
<li><strong>MaterialDesign设计风格</strong></li>
<li><strong>支持64位ART虚拟机</strong>（5.0推出的ART虚拟机，在5.0之前都是Dalvik。他们的区别是：<br>Dalvik,每次运行,字节码都需要通过即时编译器转换成机器码(JIT)。<br>ART,第一次安装应用的时候,字节码就会预先编译成机器码(AOT)）</li>
<li>通知详情可以用户自己设计</li>
</ul>
<p><strong>Android6.0新特性</strong></p>
<ul>
<li><strong>动态权限管理</strong></li>
<li>支持快速充电的切换</li>
<li>支持文件夹拖拽应用</li>
<li>相机新增专业模式</li>
</ul>
<p><strong>Android7.0新特性</strong></p>
<ul>
<li><strong>多窗口支持</strong></li>
<li><strong>V2签名</strong></li>
<li>增强的Java8语言模式</li>
<li>夜间模式</li>
</ul>
<p><strong>Android8.0（O）新特性</strong></p>
<ul>
<li><strong>优化通知</strong><br>通知渠道 (Notification Channel) 通知标志 休眠 通知超时 通知设置 通知清除</li>
<li><strong>画中画模式</strong>：清单中Activity设置android:supportsPictureInPicture</li>
<li><strong>后台限制</strong></li>
<li>自动填充框架</li>
<li>系统优化</li>
<li>等等优化很多</li>
</ul>
<p><strong>Android9.0（P）新特性</strong></p>
<ul>
<li><strong>室内WIFI定位</strong></li>
<li><strong>“刘海”屏幕支持</strong></li>
<li>安全增强</li>
<li>等等优化很多</li>
</ul>
<p><strong>Android10.0（Q）新特性</strong></p>
<ul>
<li><p><strong>夜间模式</strong>：包括手机上的所有应用都可以为其设置暗黑模式。</p>
</li>
<li><p><strong>桌面模式</strong>：提供类似于PC的体验，但是远远不能代替PC。</p>
</li>
<li><p><strong>屏幕录制</strong>：通过长按“电源”菜单中的”屏幕快照”来开启。</p>
</li>
</ul>
<p><strong>Android11.0（P）新特性</strong><br><strong>Android12.0（）新特性</strong> </p>
<h3 id="11、Json"><a href="#11、Json" class="headerlink" title="11、Json"></a>11、Json</h3><p>JSON的全称是JavaScript Object Notation，也就是JavaScript 对象表示法<br>JSON是存储和交换文本信息的语法，类似XML，但是比XML<strong>更小、更快，更易解析</strong><br>JSON是轻量级的文本数据交换格式，独立于语言，具有可描述性，更易理解，对象可以包含多个名称/值对，比如：<br><code>&#123;&quot;name&quot;:&quot;zhangsan&quot; , &quot;age&quot;:25&#125;</code></p>
<p>使用谷歌的GSON包进行解析，在 Android Studio 里引入依赖：<br><code>compile &#39;com.google.code.gson:gson:2.7&#39;</code></p>
<p>值得注意的是实体类中变量名称必须和json中的值名字相同。<br>使用示例：<br>1、解析成实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">Student student = gson.fromJson(json1, Student.class);</span><br></pre></td></tr></table></figure>

<p>2、解析成int数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="keyword">int</span>[] ages = gson.fromJson(json2, <span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>

<p>3、直接解析成List.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">List&lt;Integer&gt; ages = gson.fromJson(json2,  newTypeToken&lt;List&lt;Integer&gt;&gt;()&#123;&#125;.getType);</span><br><span class="line"></span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">List&lt;Student&gt; students = gson.fromJson(json3, newTypeToke&lt;List&lt;Student&gt;&gt;()&#123;&#125;.getType);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>轻量级的数据交换格式</li>
<li>读写更加容易</li>
<li>易于机器的解析和生成</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>语义性较差，不如 xml 直观</li>
</ul>
<h3 id="12、android中有哪几种解析xml的类-官方推荐哪种？以及它们的原理和区别？"><a href="#12、android中有哪几种解析xml的类-官方推荐哪种？以及它们的原理和区别？" class="headerlink" title="12、android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别？"></a>12、android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别？</h3><p><strong>DOM解析</strong><br>优点:<br>1.<strong>XML树在内存中完整存储</strong>,因此可以直接<strong>修改其数据结构</strong>.<br>2.可以通过该解析器随时访问XML树中的任何一个节点.<br>3.DOM解析器的API在使用上也相对比较简单.</p>
<p>缺点:<br>如果XML文档体积比较大时,将文档读入内存是非消耗系统资源的.</p>
<p>使用场景:</p>
<ul>
<li><p>DOM 是与平台和语言无关的方式表示 XML文档的官方 W3C 标准.</p>
</li>
<li><p>DOM 是以层次结构组织的节点的集合.这个层次结构允许开人员在树中寻找特定信息.分析该结构通常需要加载整个文档和构造层次结构,然后才能进行任何工作.</p>
</li>
<li><p>DOM 是基于对象层次结构的.</p>
</li>
</ul>
<p>编程思路 DocumentBuilderFactory-&gt;DocumentBuilder-&gt;Document-&gt;通过节点获得NodeList-&gt;具体的Node</p>
<p>如果想修改 TransformerFactory-&gt;Transformer-&gt;transform(Souce, result)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">domParse</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//获取DocumentBuilderFactory</span></span><br><span class="line">	DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">	<span class="comment">//获取DocumentBuilder</span></span><br><span class="line">	DocumentBuilder documentBuilder = builderFactory.newDocumentBuilder();</span><br><span class="line">	<span class="comment">//通过documentBuilder.parse() 解析xml文档获得Document对象</span></span><br><span class="line">	Document document = documentBuilder.parse(<span class="string">&quot;book.xml&quot;</span>);</span><br><span class="line">	<span class="comment">//通过元素的名字可以找到元素的集合</span></span><br><span class="line">	NodeList nodeList = document.getElementsByTagName(<span class="string">&quot;售价&quot;</span>);</span><br><span class="line">	<span class="comment">//nodeList.getLength();</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nodeList.getLength();i++)&#123;</span><br><span class="line">		Node node = nodeList.item(i);</span><br><span class="line">		String content = node.getTextContent();</span><br><span class="line">		System.out.println(content);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找到第二个元素</span></span><br><span class="line">	Node node = nodeList.item(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//读出对应节点的文本内容</span></span><br><span class="line">	String content = node.getTextContent();</span><br><span class="line">	System.out.println(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">domModifyxml</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">	DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();</span><br><span class="line">	Document document = builder.parse(<span class="string">&quot;book.xml&quot;</span>);</span><br><span class="line">	NodeList nodeList = document.getElementsByTagName(<span class="string">&quot;售价&quot;</span>);</span><br><span class="line">	Node node = nodeList.item(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//修改节点的内容</span></span><br><span class="line">	node.setTextContent(<span class="string">&quot;199.00元&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	TransformerFactory transformerFactory = TransformerFactory.newInstance();</span><br><span class="line">	Transformer transformer = transformerFactory.newTransformer();</span><br><span class="line">	<span class="comment">//数据源</span></span><br><span class="line">	Source xmlSource = <span class="keyword">new</span> DOMSource(document);</span><br><span class="line">	<span class="comment">//要输出到的目的地</span></span><br><span class="line">	Result outputTarget = <span class="keyword">new</span> StreamResult(<span class="string">&quot;book.xml&quot;</span>);</span><br><span class="line">	transformer.transform(xmlSource, outputTarget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>SAX解析</strong></p>
<p>优点:<br>SAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中包含的部分数据时,SAX 这种扩展能力得到了更好的体现.</p>
<p>缺点:<br>用SAX方式进行XML解析时,需要顺序执行,所以很难访问同一文档中的不同数据.此外,在基于该方式的解析编码程序也相对复杂.</p>
<p>使用场景:<br>对于含有数据量十分巨大,而又不用对文档的所有数据行遍历或者分析的时候,使用该方法十分有效.该方法不将整个文档读入内存,而只需读取到程序所需的文档标记处即可.</p>
<p>原理：一个元素一个元素解析 解析到一个元素调用相关的方法 <code>startDocument()</code>:文档开始  <code>endDocument ()</code>:文档结束 <code>startElement()</code>: 元素开始  endElement():元素结束 <code>characters()</code>: 文本内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saxParser</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="comment">//获取工厂</span></span><br><span class="line">	SAXParserFactory parserFactory = SAXParserFactory.newInstance();</span><br><span class="line">       <span class="comment">//获取解析器</span></span><br><span class="line">	SAXParser saxParser = parserFactory.newSAXParser();</span><br><span class="line">	<span class="comment">//获取xmlReader通过这个reader可以试着 ContentHandler</span></span><br><span class="line">	XMLReader xmlReader = saxParser.getXMLReader();</span><br><span class="line">	<span class="comment">//给xmlReader设置contentHandler  contentHandler是一个接口 里面太多的方法没实现</span></span><br><span class="line">	<span class="comment">//不去直接实现contenthandler 而是继承它默认的实现 DefaultHandler</span></span><br><span class="line">	xmlReader.setContentHandler(<span class="keyword">new</span> Myhandler());</span><br><span class="line">	<span class="comment">//解析xml文档</span></span><br><span class="line">	xmlReader.parse(<span class="string">&quot;book.xml&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Myhandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;文档开始&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;文档结束&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开始标签&lt;&quot;</span>+qName+<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">           <span class="comment">//创建对象、集合、属性</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;结束标签&lt;/&quot;</span>+qName+<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">           <span class="comment">//把对象加入到集合中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">		<span class="comment">//文本内容</span></span><br><span class="line">		String text = <span class="keyword">new</span> String(ch,start,length);</span><br><span class="line">		System.out.println(<span class="string">&quot;文本内容&quot;</span>+text);</span><br><span class="line">           <span class="comment">//设置对象属性的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Xmlpull解析</strong><br>android SDK提供了xmlpullapi,xmlpull和sax类似,是基于流（stream）操作文件,后者根据节点事件回调开发者编写的处理程序.因为是基于流的处理,因此xmlpull和sax都比较节约内存资源,不会像dom那样要把所有节点以对象树的形式展现在内存中.xmpull比sax更简明,而且不需要扫描完整个流.</p>
<p>原理：调用next方法 解析下一个元素 每调用一次 解析一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	ArrayList&lt;Book&gt; books = <span class="keyword">null</span>;</span><br><span class="line">	Book book  = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 获取工厂</span></span><br><span class="line">	XmlPullParserFactory parserFactory = XmlPullParserFactory.newInstance();</span><br><span class="line">	<span class="comment">// 获取到xml的解析器</span></span><br><span class="line">	XmlPullParser parser = parserFactory.newPullParser();</span><br><span class="line">	<span class="comment">// 给解析器设置一个输入源</span></span><br><span class="line">	<span class="comment">// 第一个参数输入流 第二个参数 文档用到的字符编码集</span></span><br><span class="line">	parser.setInput(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;book.xml&quot;</span>)), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取当前事件类型</span></span><br><span class="line">	<span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">	<span class="keyword">boolean</span> flag  = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT &amp;&amp; flag) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_TAG:</span><br><span class="line">			<span class="comment">//开始标签</span></span><br><span class="line">			<span class="comment">//parser.getName 获取当前事件对应的元素名字</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="string">&quot;书架&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">				<span class="comment">//创建一个集合</span></span><br><span class="line">				books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;书&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">				<span class="comment">//创建一个book 对象</span></span><br><span class="line">				book = <span class="keyword">new</span> Book();</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;书名&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">				<span class="comment">//给book 对象设置书名的属性</span></span><br><span class="line">				book.setTitle(parser.nextText()); <span class="comment">//parser.nextText()获取当前节点的下一个文本内容</span></span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;作者&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">				<span class="comment">//给book 对象设置作者的属性</span></span><br><span class="line">				book.setAuthor(parser.nextText());</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;售价&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">				<span class="comment">//给book 对象设置售价的属性</span></span><br><span class="line">				book.setPrice(parser.nextText());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.END_TAG:</span><br><span class="line">			<span class="comment">//结束标签</span></span><br><span class="line">			 <span class="keyword">if</span>(<span class="string">&quot;书&quot;</span>.equals(parser.getName()))&#123;</span><br><span class="line">					<span class="comment">//把book 对象添加到集合中</span></span><br><span class="line">				 books.add(book);</span><br><span class="line">				 flag = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用parser.next方法解析下一个元素 用这个结果来更新eventType 如果解析到文档结束那么就会推出循环</span></span><br><span class="line">		<span class="comment">// 如果不更新这个eventType 就是死循环</span></span><br><span class="line">		eventType = parser.next();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历集合</span></span><br><span class="line">	<span class="keyword">for</span>(Book book1:books)&#123;</span><br><span class="line">		System.out.println(book1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="13、Jar和Aar的区别"><a href="#13、Jar和Aar的区别" class="headerlink" title="13、Jar和Aar的区别"></a>13、Jar和Aar的区别</h3><p>Jar包里面只有代码，aar里面不光有代码还包括资源文件，比如 drawable 文件，xml资源文件。对于一些不常变动的 Android Library，我们可以直接引用 aar，加快编译速度。</p>
<p>打包aar的方式，build.gradle文件中<code>apply plugin: &#39;com.android.application&#39;</code>改为<code>apply plugin: &#39;com.android.library&#39;</code>，去掉applicationId，让后在gradle中执行assemble任务,将自动打包出release和debug版本的aar，输出路径:<code>build/outputs/aar</code></p>
<h3 id="14、Android为每个应用程序分配的内存大小是多少"><a href="#14、Android为每个应用程序分配的内存大小是多少" class="headerlink" title="14、Android为每个应用程序分配的内存大小是多少"></a>14、Android为每个应用程序分配的内存大小是多少</h3><p>android程序内存一般限制在16M，也有的是24M。近几年手机发展较快，一般都会分配两百兆左右，和具体机型有关。</p>
<h3 id="15、更新UI方式"><a href="#15、更新UI方式" class="headerlink" title="15、更新UI方式"></a>15、更新UI方式</h3><ul>
<li>Activity.runOnUiThread(Runnable)</li>
<li>View.post(Runnable)，View.postDelay(Runnable, long)（可以理解为在当前操作视图UI线程添加队列）</li>
<li>Handler</li>
<li>AsyncTask</li>
<li>Rxjava</li>
<li>LiveData</li>
</ul>
<h3 id="16、ContentProvider使用方法。"><a href="#16、ContentProvider使用方法。" class="headerlink" title="16、ContentProvider使用方法。"></a>16、ContentProvider使用方法。</h3><p><strong>进行跨进程通信</strong>，实现进程间的数据交互和共享。通过Context 中 <code>getContentResolver() </code>获得实例，通过 Uri匹配进行数据的增删改查。ContentProvider使用表的形式来组织数据，无论数据的来源是什么，ConentProvider 都会认为是一种表，然后把数据组织成表格。</p>
<p>ContentProvider内容提供者实现步骤</p>
<p>1.写一个类继承ContentProvider 重写 onCreate query delete update insert getType</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//URI 统一资源标识符  url 子父类 URI 爹  url儿子 http:// ftp:// https://</span></span><br><span class="line">	<span class="comment">//URI 可以自定义协议  cn.demo.provider/update1</span></span><br><span class="line">	<span class="keyword">private</span> MyOpenHelper openHelper;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sURIMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATCH_QUERY = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATCH_UPDATE = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATCH_INSERT = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MATCH_DELETE = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="comment">//通过uri匹配器 添加匹配的路径规则 cn.demo.provider/query </span></span><br><span class="line">        <span class="comment">//如果调用match方法匹配上了这个规则 那么就会返回MATCH_UPDATE </span></span><br><span class="line">		<span class="comment">//如果传入的uri没有匹配任何预先加入的uri 就会返回NO_MATCH</span></span><br><span class="line">		sURIMatcher.addURI(<span class="string">&quot;cn.demo.provider&quot;</span>, <span class="string">&quot;query&quot;</span>, MATCH_QUERY);</span><br><span class="line">		sURIMatcher.addURI(<span class="string">&quot;cn.demo.provider&quot;</span>, <span class="string">&quot;update&quot;</span>, MATCH_UPDATE);</span><br><span class="line">		sURIMatcher.addURI(<span class="string">&quot;cn.demo.provider&quot;</span>, <span class="string">&quot;insert&quot;</span>, MATCH_INSERT);</span><br><span class="line">		sURIMatcher.addURI(<span class="string">&quot;cn.demo.provider&quot;</span>, <span class="string">&quot;delete&quot;</span>, MATCH_DELETE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = sURIMatcher.match(uri);</span><br><span class="line">		<span class="keyword">if</span>(result == MATCH_DELETE)&#123;</span><br><span class="line">			SQLiteDatabase db = openHelper.getReadableDatabase();</span><br><span class="line">			<span class="keyword">int</span> delete = db.delete(<span class="string">&quot;info&quot;</span>, selection, selectionArgs);</span><br><span class="line">			<span class="keyword">return</span> delete;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = sURIMatcher.match(uri);</span><br><span class="line">		<span class="keyword">if</span>(result==MATCH_INSERT)&#123;</span><br><span class="line">			SQLiteDatabase db = openHelper.getReadableDatabase();</span><br><span class="line">			<span class="keyword">long</span> insert = db.insert(<span class="string">&quot;info&quot;</span>, <span class="keyword">null</span>, values);</span><br><span class="line">			<span class="comment">//通过内容解析者 发送通知 告知内容发生变化 第一个参数 uri 通过这个uri确定是哪个内容提供者对应数据发生了改变 </span></span><br><span class="line">			<span class="comment">//第二个 参数 ContentObserver 如果传入了一个内容观察者对象 那么 只有这个内容观察者能收到变化的消息</span></span><br><span class="line">			<span class="comment">//如果传了null 只要观察着第一个参数传入的uri的内容观察者都能收到变化的消息</span></span><br><span class="line">			getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> Uri.parse(String.valueOf(insert));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		openHelper = <span class="keyword">new</span> MyOpenHelper(getContext());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一个参数 就是用来匹配具体路径 决定是否让对方访问相应方法</span></span><br><span class="line">		<span class="keyword">int</span> result = sURIMatcher.match(uri);</span><br><span class="line">		<span class="keyword">if</span>(result == MATCH_QUERY)&#123;</span><br><span class="line">			SQLiteDatabase db = openHelper.getReadableDatabase();</span><br><span class="line">			Cursor cursor = db.query(<span class="string">&quot;info&quot;</span>, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">			<span class="keyword">return</span> cursor;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;口令不正确&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = sURIMatcher.match(uri);</span><br><span class="line">		<span class="keyword">if</span>(result == MATCH_UPDATE)&#123;</span><br><span class="line">			SQLiteDatabase db = openHelper.getReadableDatabase();</span><br><span class="line">			<span class="keyword">int</span> update = db.update(<span class="string">&quot;info&quot;</span>, values, selection, selectionArgs);</span><br><span class="line">			<span class="keyword">return</span> update;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, <span class="string">&quot;itcast.db&quot;</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">		db.execSQL(<span class="string">&quot;create table info(_id integer primary key autoincrement,name varchar(20),phone varchar(20))&quot;</span>);</span><br><span class="line">		db.execSQL(<span class="string">&quot;insert into info(name,phone) values(&#x27;王五&#x27;,&#x27;13777777&#x27;)&quot;</span>);</span><br><span class="line">		db.execSQL(<span class="string">&quot;insert into info(name,phone) values(&#x27;赵四&#x27;,&#x27;13888888&#x27;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.在清单文件中声明对应的provider节点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--authorities:通过这个字符串来决定访问的是哪个内容提供者  高版本的设备 还需要配置一个参数 exported = true; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;com.demo.contentproviderdemo.MyProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;com.demo.provider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.通过URIMatch添加URi的匹配规则</p>
<p>ContentResolver内容解析者实现步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver contentResolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.demo.provider/query&quot;</span>);</span><br><span class="line">Cursor cursor = ContentResolver.query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>



<h3 id="17、Thread、AsyncTask、IntentService的使用场景与特点。"><a href="#17、Thread、AsyncTask、IntentService的使用场景与特点。" class="headerlink" title="17、Thread、AsyncTask、IntentService的使用场景与特点。"></a>17、Thread、AsyncTask、IntentService的使用场景与特点。</h3><p>1.Thread线程，独立运行与于 Activity 的，当Activity 被 finish 后，如果没有主动停止 Thread或者 run 方法没有执行完，其会一直执行下去。</p>
<p>2.AsyncTask 封装了两个线程池和一个Handler（SerialExecutor用于排队，THREAD_POOL_EXECUTOR为真正的执行任务，Handler将工作线程切换到主线程），其必须在 UI线程中创建，execute 方法必须在 UI线程中执行，一个任务实例只允许执行一次，执行多次抛出异常，用于网络请求或者简单数据处理。</p>
<p>3.IntentService：处理异步请求，实现多线程，在onHandleIntent中处理耗时操作，多个耗时任务会依次执行，执行完毕自动结束。</p>
<h3 id="18、Merge、ViewStub-的作用。"><a href="#18、Merge、ViewStub-的作用。" class="headerlink" title="18、Merge、ViewStub 的作用。"></a>18、Merge、ViewStub 的作用。</h3><p>Merge: 减少视图层级，可以删除多余的层级。<br>ViewStub: 按需加载，减少内存使用量、加快渲染速度、不支持 merge 标签。</p>
<h3 id="19、activity的startActivity和context的startActivity区别？"><a href="#19、activity的startActivity和context的startActivity区别？" class="headerlink" title="19、activity的startActivity和context的startActivity区别？"></a>19、activity的startActivity和context的startActivity区别？</h3><p>(1)、从Activity中启动新的Activity时可以直接mContext.startActivity(intent)就好<br>(2)、如果从其他Context中启动Activity则必须给intent设置Flag:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK) ; </span><br><span class="line">mContext.startActivity(intent);</span><br></pre></td></tr></table></figure>

<h3 id="20、怎么在Service中创建Dialog对话框？"><a href="#20、怎么在Service中创建Dialog对话框？" class="headerlink" title="20、怎么在Service中创建Dialog对话框？"></a>20、怎么在Service中创建Dialog对话框？</h3><p>1.在我们取得Dialog对象后，需给它设置类型，即：<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</code></p>
<p>2.在Manifest中加上权限:<br><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINOW&quot; /&gt;</code></p>
<h3 id="21、Asset目录与res目录的区别？"><a href="#21、Asset目录与res目录的区别？" class="headerlink" title="21、Asset目录与res目录的区别？"></a>21、Asset目录与res目录的区别？</h3><p>assets：不会在 R 文件中生成相应标记，存放到这里的资源在打包时会打包到程序安装包中。（通过 AssetManager 类访问这些文件）</p>
<p>res：会在 R 文件中生成 id 标记，资源在打包时如果使用到则打包到安装包中，未用到不会打入安装包中。<br>res/anim：存放动画资源。<br>res/raw：和 asset 下文件一样，打包时直接打入程序安装包中（会映射到 R 文件中）。</p>
<h3 id="22、Android怎么加速启动Activity？"><a href="#22、Android怎么加速启动Activity？" class="headerlink" title="22、Android怎么加速启动Activity？"></a>22、Android怎么加速启动Activity？</h3><ul>
<li><code>onCreate()</code> 中不执行耗时操作<br>把页面显示的 View 细分一下，放在 AsyncTask 里逐步显示，用 Handler 更好。这样用户的看到的就是有层次有步骤的一个个的 View 的展示，不会是先看到一个黑屏，然后一下显示所有 View。最好做成动画，效果更自然。</li>
<li>利用多线程的目的就是尽可能的减少 <code>onCreate()</code> 和 <code>onReume()</code> 的时间，使得用户能尽快看到页面，操作页面。</li>
<li>减少主线程阻塞时间。</li>
<li>提高 Adapter 和 AdapterView 的效率。</li>
<li>优化布局文件。</li>
</ul>
<h3 id="23、Handler机制"><a href="#23、Handler机制" class="headerlink" title="23、Handler机制"></a>23、Handler机制</h3><p>Android消息循环流程图如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/14601315-3d147d11ab67e075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>主要涉及的角色如下所示：</p>
<ul>
<li>message：消息。</li>
<li>MessageQueue：消息队列，负责消息的存储与管理，负责管理由 Handler 发送过来的 Message。读取会自动删除消息，单链表维护，插入和删除上有优势。在其<code>next()</code>方法中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</li>
<li>Looper：消息循环器，负责关联线程以及消息的分发，在该线程下从 MessageQueue获取 Message，分发给Handler，Looper创建的时候会创建一个MessageQueue，调用<code>loop()</code>方法的时候消息循环开始，其中会不断调用messageQueue的<code>next()</code>方法，当有消息就处理，否则阻塞在messageQueue的<code>next()</code>方法中。当Looper的<code>quit()</code>被调用的时候会调用messageQueue的<code>quit()</code>，此时<code>next()</code>会返回null，然后<code>loop()</code>方法也就跟着退出。</li>
<li>Handler：消息处理器，负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。</li>
</ul>
<p>整个消息的循环流程还是比较清晰的，具体说来：</p>
<ul>
<li>1、Handler通过<code>sendMessage()</code>发送消息Message到消息队列MessageQueue。</li>
<li>2、Looper通过<code>loop()</code>不断从MessageQueue提取Message，并将Message交给对应的target handler来处理。</li>
<li>3、target handler调用自身的<code>handleMessage()</code>方法来处理Message。</li>
</ul>
<p>事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。<br><img src="https://upload-images.jianshu.io/upload_images/14601315-e7043716da007c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注：虚线表示关联关系，实线表示调用关系。</p>
<p>在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有直接调用的关系，它们发生关联的桥梁是MessageQueue。</p>
<p><strong>总结</strong></p>
<ul>
<li>Handler 发送的消息由 MessageQueue 存储管理，并由 Looper 负责回调消息到 <code>handleMessage()</code>。</li>
<li>线程的转换由 Looper 完成，<code>handleMessage()</code> 所在线程由 <code>Looper.loop()</code> 调用者所在线程决定。</li>
</ul>
<p><strong>Handler 引起的内存泄露原因以及最佳解决方案</strong><br>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p>
<p>解决：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在Acitivity的<code>onDestroy()</code>中调用<code>handler.removeCallbacksAndMessages(null)</code>及时移除所有消息。</p>
<p><strong>为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</strong><br>通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者。在 <code>ActivityThread.main()</code> 方法中调用了 <code>Looper.prepareMainLooper()</code> 方法创建了 主线程的 Looper ,并且调用了 <code>loop()</code> 方法，所以我们就可以直接使用 Handler 了。<br>因此我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息。如大部分插件化框架中Hook ActivityThread.mH 的处理。</p>
<p><strong>主线程的 Looper 不允许退出</strong><br>主线程不允许退出，退出就意味 APP 要挂。</p>
<p><strong>Handler 里藏着的 Callback 能干什么？</strong><br>Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。</p>
<p><strong>创建 Message 实例的最佳方式</strong><br>为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗：</p>
<ul>
<li>通过 Message 的静态方法 <code>Message.obtain()</code>；</li>
<li>通过 Handler 的公有方法 ``handler.obtainMessage()`。</li>
</ul>
<p><strong>子线程里弹 Toast 的正确姿势</strong></p>
<p>本质上是因为 Toast 的实现依赖于 Handler，按子线程使用 Handler 的要求修改即可，同理的还有 Dialog。</p>
<p><strong>妙用 Looper 机制</strong></p>
<ul>
<li>  将 Runnable post 到主线程执行；</li>
<li>  利用 Looper 判断当前线程是否是主线程。</li>
</ul>
<p><strong>主线程的死循环一直运行是不是特别消耗CPU资源呢？</strong></p>
<p>并不是，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的<code>queue.next()</code>中的<code>nativePollOnce()</code>方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质是同步I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<p><strong>handler postDelay这个延迟是怎么实现的？</strong></p>
<p><code>handler.postDelay()</code>并不是先等待一定的时间再放入到MessageQueue中，而是直接进入MessageQueue，以MessageQueue的时间顺序排列和唤醒的方式结合实现的。</p>
<p><strong>如何保证在msg.postDelay情况下保证消息次序？</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903783139393550#heading-7">Handler 都没搞懂，拿什么去跳槽啊？</a></p>
<h3 id="24、程序A能否接收到程序B的广播？"><a href="#24、程序A能否接收到程序B的广播？" class="headerlink" title="24、程序A能否接收到程序B的广播？"></a>24、程序A能否接收到程序B的广播？</h3><p>能，使用<strong>全局</strong>的BroadCastRecevier能进行跨进程通信，但是注意它只能被动接收广播。此外，LocalBroadCastRecevier只限于本进程的广播间通信。</p>
<h3 id="25、数据加载更多涉及到分页，你是怎么实现的？"><a href="#25、数据加载更多涉及到分页，你是怎么实现的？" class="headerlink" title="25、数据加载更多涉及到分页，你是怎么实现的？"></a>25、数据加载更多涉及到分页，你是怎么实现的？</h3><p>分页加载就是一页一页加载数据，当滑动到底部、没有更多数据加载的时候，我们可以手动调用接口，重新刷新RecyclerView。</p>
<h3 id="26、通过google提供的Gson解析json时，定义JavaBean的规则是什么？"><a href="#26、通过google提供的Gson解析json时，定义JavaBean的规则是什么？" class="headerlink" title="26、通过google提供的Gson解析json时，定义JavaBean的规则是什么？"></a>26、通过google提供的Gson解析json时，定义JavaBean的规则是什么？</h3><p>1). 实现序列化 Serializable<br>2). 属性私有化，并提供get，set方法<br>3). 提供无参构造<br>4). 属性名必须与json串中属性名保持一致 （因为Gson解析json串底层用到了Java的反射原理）</p>
<h3 id="27、json解析方式的两种区别？"><a href="#27、json解析方式的两种区别？" class="headerlink" title="27、json解析方式的两种区别？"></a>27、json解析方式的两种区别？</h3><p>1，SDK提供JSONArray，JSONObject<br>2，Google提供的 Gson 通过<code>fromJson()</code>实现对象的反序列化（即将json串转换为对象类型）通过<code>toJson()</code>实现对象的序列化 （即将对象类型转换为json串）</p>
<h3 id="28、线程池的相关知识。"><a href="#28、线程池的相关知识。" class="headerlink" title="28、线程池的相关知识。"></a>28、线程池的相关知识。</h3><p>Android中的线程池都是直接或间接通过配置ThreadPoolExecutor来实现不同特性的线程池.Android中最常见的类具有不同特性的线程池分别为FixThreadPool、CachedThreadPool、SingleThreadPool、ScheduleThreadExecutor.</p>
<p>1).FixThreadPool<br>只有核心线程,并且数量固定的,也不会被回收,所有线程都活动时,因为队列没有限制大小,新任务会等待执行.</p>
<p>优点:更快的响应外界请求.</p>
<p>2).SingleThreadPool<br>只有一个核心线程,确保所有的任务都在同一线程中按序完成.因此不需要处理线程同步的问题.</p>
<p>3).CachedThreadPool<br>只有非核心线程,最大线程数非常大,所有线程都活动时会为新任务创建新线程,否则会利用空闲线程(60s空闲时间,过了就会被回收,所以线程池中有0个线程的可能)处理任务.</p>
<p>优点:任何任务都会被立即执行(任务队列SynchronousQueue相当于一个空集合);比较适合执行大量的耗时较少的任务.</p>
<p>4).ScheduledThreadPool<br>核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.</p>
<p>优点:执行定时任务以及有固定周期的重复任务</p>
<h3 id="29、内存泄露，怎样查找，怎么产生的内存泄露？"><a href="#29、内存泄露，怎样查找，怎么产生的内存泄露？" class="headerlink" title="29、内存泄露，怎样查找，怎么产生的内存泄露？"></a>29、内存泄露，怎样查找，怎么产生的内存泄露？</h3><p><strong>1.资源对象没关闭造成的内存泄漏</strong></p>
<p>描述： 资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象(在<code>finalize()</code>中可以恢复)，比如SQLiteCursor，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。</p>
<p>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。</p>
<p><strong>2.构造Adapter时，没有使用缓存的convertView</strong></p>
<p>描述： 以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：<code>public View getView(int position, ViewconvertView, ViewGroup parent)</code> 来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由<code>getView()</code>方法完成的，<code>getView()</code>的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看: android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, ViewconvertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">	View view = <span class="keyword">new</span> Xxx(...); </span><br><span class="line">	... ... </span><br><span class="line">	<span class="keyword">return</span> view; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, ViewconvertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">	View view = <span class="keyword">null</span>; </span><br><span class="line">	<span class="keyword">if</span> (convertView != <span class="keyword">null</span>) &#123; </span><br><span class="line">		view = convertView; </span><br><span class="line">		populate(view, getItem(position)); </span><br><span class="line">		... </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		view = <span class="keyword">new</span> Xxx(...); </span><br><span class="line">		... </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> view; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.Bitmap对象不在使用时调用recycle()释放内存</strong></p>
<p>描述： 有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用<code>Bitmap.recycle()</code>方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">• Free up the memory associated with thisbitmap&#39;s pixels, and mark the</span><br><span class="line">• bitmap as &quot;dead&quot;, meaning itwill throw an exception if getPixels() or </span><br><span class="line">• setPixels() is called, and will drawnothing. This operation cannot be </span><br><span class="line">• reversed, so it should only be called ifyou are sure there are no </span><br><span class="line">• further uses for the bitmap. This is anadvanced call, and normally need </span><br><span class="line">• not be called, since the normal GCprocess will free up this memory when </span><br><span class="line">• there are no more references to thisbitmap.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>4.试着使用关于application的context来替代和activity相关的context</strong></p>
<p>这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 <code>Context.getApplicationContext()</code> or <code>Activity.getApplication()</code>来获得。</p>
<p><strong>5.注册没取消造成的内存泄漏</strong></p>
<p>一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用<code>registerReceivr()</code>后未调用<code>unregisterReceiver()</code>。 比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。 但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。 虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p>
<p><strong>6.集合中对象没清理造成的内存泄漏</strong></p>
<p>我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p>
<p>查找内存泄漏可以使用Android Studio 自带的<strong>AndroidProfiler</strong>工具或<strong>MAT</strong>，也可以使用Square产品的<strong>LeakCanary.</strong></p>
<ul>
<li><p><strong>1、使用AndroidProfiler的MEMORY工具：</strong><br>运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面5次，然后收到GC（点击Profile MEMORY左上角的垃圾桶图标），如果此时total内存还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击Profile MEMORY左上角的垃圾桶图标旁的heap dump按钮查看当前的内存堆栈情况，选择按包名查找，找到当前测试的Activity，如果引用了多个实例，则表明发生了内存泄露。</p>
</li>
<li><p><strong>2、使用MAT：</strong><br>运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发GC，然后使用<code>adb shell dumpsys meminfo packagename -d</code>命令查看退出界面后Objects下的Views和Activities数目是否为0，如果不是则通过Leakcanary检查可能存在内存泄露的地方，最后通过MAT分析，如此反复，改善满意为止。</p>
<p>1、在使用MAT之前，先使用as的Profile中的Memory去获取要分析的堆内存快照文件.hprof，如果要测试某个页面是否产生内存泄漏，可以先dump出没进入该页面的内存快照文件.hprof，然后，通常执行5次进入/退出该页面，然后再dump出此刻的内存快照文件.hprof，最后，将两者比较，如果内存相除明显，则可能发生内存泄露。（注意:MAT需要标准的.hprof文件，因此在as的Profiler中GC后dump出的内存快照文件.hprof必须手动使用android sdk platform-tools下的hprof-conv程序进行转换才能被MAT打开）</p>
<p>2、然后，使用MAT打开前面保存的2份.hprof文件，打开Overview界面，在Overview界面下面有4中action，其中最常用的就是<strong>Histogram</strong>和<strong>Dominator Tree</strong>。</p>
<p><strong>Dominator Tree</strong>：支配树，按对象大小降序列出对象和其所引用的对象，注重引用关系分析。选择Group by package，找到当前要检测的类（或者使用顶部的Regex直接搜索），查看它的Object数目是否正确，如果多了，则判断发生了内存泄露。然后，右击该类，选择Merge Shortest Paths to GC Root中的exclude all phantom/weak/soft etc.references选项来查看该类的GC强引用链。最后，通过引用链即可看到最终强引用该类的对象。</p>
<p><strong>Histogram</strong>：直方图注重量的分析。使用方式与Dominator Tree类似。</p>
<p>3、对比hprof文件，检测出复杂情况下的内存泄露：<br>通用对比方式：在Navigation History下面选择想要对比的dominator_tree/histogram，右击选择Add to Compare Basket，然后在Compare Basket一栏中点击红色感叹号（Compare the results）生成对比表格（Compared Tables），在顶部Regex输入要检测的类，查看引用关系或对象数量去进行分析即可。</p>
</li>
</ul>
<p>针对于Historam的快速对比方式：直接选择Histogram上方的Compare to another Heap Dump选择要比较的hprof文件的Historam即可。</p>
<h3 id="30、类的初始化顺序依次是？"><a href="#30、类的初始化顺序依次是？" class="headerlink" title="30、类的初始化顺序依次是？"></a>30、类的初始化顺序依次是？</h3><p>（静态变量、静态代码块）&gt;（变量、代码块）&gt;构造方法</p>
<h3 id="31、JSON的结构？"><a href="#31、JSON的结构？" class="headerlink" title="31、JSON的结构？"></a>31、JSON的结构？</h3><p>json是一种轻量级的数据交换格式，json简单说就是对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构</p>
<p>1、对象：对象表示为“{}”扩起来的内容，数据结构为 {key：value,key：value,…}的键值对的结构，在面向对象的语言中，key为对象的属性，value为对应的属性值，所以很容易理解，取值方法为 对象.key 获取属性值，这个属性值的类型可以是 数字、字符串、数组、对象几种。</p>
<p>2、数组：数组在json中是中括号“[]”扩起来的内容，数据结构为 [“java”,”javascript”,”vb”,…]，取值方式和所有语言中一样，使用索引获取，字段值的类型可以是 数字、字符串、数组、对象几种。经过对象、数组2种结构就可以组合成复杂的数据结构了。</p>
<h3 id="32、ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化（提示：Fragment懒加载）？"><a href="#32、ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化（提示：Fragment懒加载）？" class="headerlink" title="32、ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化（提示：Fragment懒加载）？"></a>32、ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化（提示：Fragment懒加载）？</h3><p>自定义一个 LazyLoadFragment 基类，利用 <code>setUserVisibleHint()</code> 和 生命周期方法，通过对 Fragment 状态判断，进行数据加载，并将数据加载的接口提供开放出去，供子类使用。然后在子类 Fragment 中实现<code> requestData()</code> 方法即可。这里添加了一个 isDataLoaded 变量，目的是避免重复加载数据。考虑到有时候需要刷新数据的问题，便提供了一个用于强制刷新的参数判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoadFragment</span> <span class="keyword">extends</span> <span class="title">BaseFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isViewInitiated;<span class="comment">//View是否初始化</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isDataLoaded;<span class="comment">//是否已经加载数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        isViewInitiated = <span class="keyword">true</span>;<span class="comment">//View初始化完成</span></span><br><span class="line">        prepareRequestData();<span class="comment">//准备加载数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置的是否可见 true:可见     false:不可见*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="comment">//准备加载数据</span></span><br><span class="line">        prepareRequestData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载数据接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">requestData</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*准备加载数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepareRequestData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不强制准备加载数据，返回是否，</span></span><br><span class="line">        <span class="keyword">return</span> prepareRequestData(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*准备加载数据，forceUpdate：是否强制刷新*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepareRequestData</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*如果可见 true，并且View初始化完成 true，并且数据未加载 false或者强制刷新数据 true ：加载数据*/</span></span><br><span class="line">        <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; isViewInitiated &amp;&amp; (!isDataLoaded || forceUpdate)) &#123;</span><br><span class="line">            requestData();<span class="comment">//加载数据</span></span><br><span class="line">            isDataLoaded = <span class="keyword">true</span>;<span class="comment">//已加载数据标志</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="35、Android为什么引入Parcelable？"><a href="#35、Android为什么引入Parcelable？" class="headerlink" title="35、Android为什么引入Parcelable？"></a>35、Android为什么引入Parcelable？</h3><p>可以肯定的是，两者都是支持序列化和反序列化的操作。</p>
<p>两者最大的区别在于 存储媒介的不同，Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。</p>
<p>Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &amp;unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多。</p>
<h3 id="36、有没有尝试简化Parcelable的使用？"><a href="#36、有没有尝试简化Parcelable的使用？" class="headerlink" title="36、有没有尝试简化Parcelable的使用？"></a>36、有没有尝试简化Parcelable的使用？</h3><p>使用Parcelable插件（Android Parcelable code generator）进行实体类的序列化的实现。</p>
<h3 id="37、Bitmap-使用时候注意什么？"><a href="#37、Bitmap-使用时候注意什么？" class="headerlink" title="37、Bitmap 使用时候注意什么？"></a>37、Bitmap 使用时候注意什么？</h3><p>1、要选择合适的图片规格（bitmap类型）：<br>| 类型      | 占用大小                      |<br>| ——— | —————————– |<br>| ALPHA_8   | 每个像素占用1byte内存         |<br>| ARGB_4444 | 每个像素占用2byte内存         |<br>| ARGB_8888 | 每个像素占用4byte内存（默认） |<br>| RGB_565   | 每个像素占用2byte内存         |</p>
<p>2、降低采样率。BitmapFactory.Options 参数inSampleSize的使用，先把<code>options.inJustDecodeBounds</code>设为true，只是去读取图片的大小，在拿到图片的大小之后和要显示的大小做比较通过<code>calculateInSampleSize()</code>函数计算inSampleSize的具体值，得到值之后。<code>options.inJustDecodeBounds</code>设为false读图片资源。</p>
<p>3、复用内存。即，通过软引用(内存不够的时候才会回收掉)，复用内存块，不需要再重新给这个bitmap申请一块新的内存，避免了一次内存的分配和回收，从而改善了运行效率。</p>
<p>4、使用<code>recycle()</code>方法及时回收内存。</p>
<p>5、压缩图片。</p>
<h3 id="38、Oom-是否可以try-catch-？"><a href="#38、Oom-是否可以try-catch-？" class="headerlink" title="38、Oom 是否可以try catch ？"></a>38、Oom 是否可以try catch ？</h3><p>只有在一种情况下，这样做是可行的：</p>
<p>在try语句中声明了很大的对象，导致OOM，并且可以确认OOM是由try语句中的对象声明导致的，那么在catch语句中，可以释放掉这些对象，解决OOM的问题，继续执行剩余语句。</p>
<p>但是这通常不是合适的做法。</p>
<p>Java中管理内存除了显式地catch OOM之外还有更多有效的方法：比如SoftReference, WeakReference, 硬盘缓存等。<br>在JVM用光内存之前，会多次触发GC，这些GC会降低程序运行的效率。<br>如果OOM的原因不是try语句中的对象（比如内存泄漏），那么在catch语句中会继续抛出OOM。</p>
<h3 id="39、多进程场景遇见过么？"><a href="#39、多进程场景遇见过么？" class="headerlink" title="39、多进程场景遇见过么？"></a>39、多进程场景遇见过么？</h3><p>1、在新的进程中，启动前台Service，播放音乐。<br>2、一个成熟的应用一定是多模块化的。首先多进程开发能为应用解决了OOM问题，因为Android对内存的限制是针对于进程的，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。而且假如图片浏览进程打开了一个过大的图片，java heap 申请内存失败，该进程崩溃并不影响我主进程的使用。</p>
<h3 id="40、Canvas-save-跟Canvas-restore-的调用时机"><a href="#40、Canvas-save-跟Canvas-restore-的调用时机" class="headerlink" title="40、Canvas.save()跟Canvas.restore()的调用时机"></a>40、Canvas.save()跟Canvas.restore()的调用时机</h3><p>save：用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。</p>
<p>restore：用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。</p>
<p>save和restore要配对使用（restore可以比save少，但不能多），如果restore调用次数比save多，会引发Error。save和restore操作执行的时机不同，就能造成绘制的图形不同。</p>
<h3 id="41、数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示："><a href="#41、数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：" class="headerlink" title="41、数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示："></a>41、数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：</h3><ol>
<li>将现有表命名为临时表。</li>
<li>创建新表。</li>
<li>将临时表的数据导入新表。</li>
<li>删除临时表。</li>
</ol>
<p>如果是跨版本数据库升级，可以有两种方式，如下所示：</p>
<p>逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。</p>
<p>跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBservice</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建表SQL语句</span></span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK = <span class="string">&quot;create table book(bookId integer primarykey,bookName text);&quot;</span>;</span><br><span class="line">    <span class="comment">//将现有表命名为临时表SQL语句</span></span><br><span class="line">    <span class="keyword">private</span> String CREATE_TEMP_BOOK = <span class="string">&quot;alter table book rename to _temp_book&quot;</span>;</span><br><span class="line">    <span class="comment">//从临时表插入数据到book表</span></span><br><span class="line">    <span class="keyword">private</span> String INSERT_DATA = <span class="string">&quot;insert into book select *,&#x27;&#x27; from _temp_book&quot;</span>;</span><br><span class="line">    <span class="comment">//删除临时表</span></span><br><span class="line">    <span class="keyword">private</span> String DROP_BOOK = <span class="string">&quot;drop table _temp_book&quot;</span>;</span><br><span class="line">    <span class="comment">/*数据库服务：创建数据库*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBservice</span><span class="params">(Context context, String name, CursorFactory factory,<span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//context:上下文，name:数据库名称，factory:游标工厂null,version:数据库版本</span></span><br><span class="line">    	<span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*创建数据库首次执行*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行数据库SQL语句 建表语句</span></span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*数据库升级执行*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逐级升级</span></span><br><span class="line">        <span class="keyword">switch</span> (newVersion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">//数据库事务开始</span></span><br><span class="line">                db.beginTransaction();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//执行数据库SQL</span></span><br><span class="line">                db.execSQL(CREATE_TEMP_BOOK);</span><br><span class="line">                db.execSQL(CREATE_BOOK);</span><br><span class="line">                db.execSQL(INSERT_DATA);</span><br><span class="line">                db.execSQL(DROP_BOOK);</span><br><span class="line"></span><br><span class="line">                db.setTransactionSuccessful();</span><br><span class="line">                <span class="comment">//数据库事务结束</span></span><br><span class="line">                db.endTransaction();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42、编译期注解跟运行时注解"><a href="#42、编译期注解跟运行时注解" class="headerlink" title="42、编译期注解跟运行时注解"></a>42、编译期注解跟运行时注解</h3><p>运行期注解(RunTime)利用反射去获取信息还是比较损耗性能的，对应<code>@Retention（RetentionPolicy.RUNTIME）</code>。</p>
<p>编译期(Compile time)注解，以及处理编译期注解的手段<strong>APT</strong>和<strong>Javapoet</strong>，对应<code>@Retention(RetentionPolicy.CLASS)</code>。其中apt+javaPoet目前也是应用比较广泛，在一些大的开源库，如EventBus3.0+,页面路由 ARouter、Dagger、Retrofit等均有使用的身影，注解不仅仅是通过反射一种方式来使用，也可以使用APT在编译期处理</p>
<h3 id="43、bitmap-recycler-相关"><a href="#43、bitmap-recycler-相关" class="headerlink" title="43、bitmap recycler 相关"></a>43、bitmap recycler 相关</h3><p>在Android中，Bitmap的存储分为两部分，一部分是Bitmap的<strong>数据</strong>，一部分是Bitmap的<strong>引用</strong>。<br>在Android2.3时代，Bitmap的引用是放在堆中的，而Bitmap的数据部分是放在栈中的，需要用户调用<code>recycle()</code>方法手动进行内存回收，而在Android2.3之后，整个Bitmap，包括数据和引用，都放在了堆中，这样，整个Bitmap的回收就全部交给GC了，这个<code>recycle()</code>方法就再也不需要使用了。</p>
<p>bitmap recycler引发的问题：当图像的旋转角度小余两个像素点之间的夹角时，图像即使旋转也无法显示，因此，系统完全可以认为图像没有发生变化。这时系统就直接引用同一个对象来进行操作，避免内存浪费。</p>
<h3 id="44、强引用置为null，会不会被回收？"><a href="#44、强引用置为null，会不会被回收？" class="headerlink" title="44、强引用置为null，会不会被回收？"></a>44、强引用置为null，会不会被回收？</h3><p>不会立即释放对象占用的内存。 如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当用户线程运行到<strong>安全点(safe point)<strong>或者</strong>安全区域</strong>才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是<strong>可恢复的（在 finalize方法中恢复引用 ）</strong>。只有确定了对象无法恢复引用的时候才会清除对象内存。</p>
<h3 id="45、Bundle传递数据为什么需要序列化？"><a href="#45、Bundle传递数据为什么需要序列化？" class="headerlink" title="45、Bundle传递数据为什么需要序列化？"></a>45、Bundle传递数据为什么需要序列化？</h3><p>序列化，表示将一个对象转换成**可存储或可传输的状态(字节流)**。序列化的原因基本三种情况：<br>1.永久性保存对象，保存对象的字节序列到本地文件中；<br>2.对象在网络中传递；<br>3.对象在IPC(跨进程通信)间传递。</p>
<h3 id="46、广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#46、广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="46、广播传输的数据是否有限制，是多少，为什么要限制？"></a>46、广播传输的数据是否有限制，是多少，为什么要限制？</h3><p>Intent在传递数据时是有大小限制的，大约限制在1MB之内，你用Intent传递数据，实际上走的是<strong>跨进程通信（IPC）</strong>，跨进程通信需要把数据从内核copy到进程中，每一个进程有一个接收内核数据的缓冲区，默认是1M；如果一次传递的数据超过限制，就会出现异常。</p>
<p>不同厂商表现不一样有可能是厂商修改了此限制的大小，也可能同样的对象在不同的机器上大小不一样。</p>
<p><strong>传递大数据</strong>，不应该用Intent；考虑使用<strong>ContentProvider</strong>或者<strong>直接匿名共享内存</strong>。简单情况下可以考虑分段传输。</p>
<h3 id="47、是否了解硬件加速？"><a href="#47、是否了解硬件加速？" class="headerlink" title="47、是否了解硬件加速？"></a>47、是否了解硬件加速？</h3><p>硬件加速就是运用GPU优秀的运算能力来加快渲染的速度，而通常的基于软件的绘制渲染模式是完全利用CPU来完成渲染。</p>
<p>1.硬件加速是从API 11引入，API 14之后才<strong>默认开启</strong>。对于标准的绘制操作和控件都是支持的，但是对于自定义View的时候或者一些特殊的绘制函数就需要考虑是否需要关闭硬件加速。</p>
<p>2.我们面对不支持硬件加速的情况，就需要限制硬件加速，这个兼容性的问题是因为硬件加速是把View的绘制函数转化为使用OpenGL的函数来进完成实际的绘制的，那么必然会存在OpenGL中不支持原始回执函数的情况，对于这些绘制函数，就会失效。</p>
<p>3.硬件加速的消耗问题，因为是使用OpenGL，需要把系统中OpenGL加载到内存中，OpenGL API调用就会占用8MB，而实际上会占用更多内存，并且使用了硬件必然增加耗电量了。</p>
<p>4.硬件加速的优势还有display list的设计，使用这个我们不需要每次重绘都执行大量的代码，基于软件的绘制模式会重绘脏区域内的所有控件，而display只会更新列表，然后绘制列表内的控件。</p>
<p>CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。</p>
<h3 id="48、ContentProvider的权限管理-读写分离，权限控制-精确到表级，URL控制-。"><a href="#48、ContentProvider的权限管理-读写分离，权限控制-精确到表级，URL控制-。" class="headerlink" title="48、ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)。"></a>48、ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)。</h3><p> 对于ContentProvider暴露出来的数据，应该是存储在自己应用内存中的数据，对于一些存储在外部存储器上的数据，并不能限制访问权限，使用ContentProvider就没有意义了。对于ContentProvider而言，有很多权限控制，可以在AndroidManifest.xml文件中对节点的属性进行配置，一般使用如下一些属性设置：</p>
<ul>
<li><code>android:grantUriPermssions</code>:临时许可标志。</li>
<li><code>android:permission</code>:Provider读写权限。</li>
<li><code>android:readPermission</code>:Provider的读权限。</li>
<li><code>android:writePermission</code>:Provider的写权限。</li>
<li><code>android:enabled</code>:标记允许系统启动Provider。</li>
<li><code>android:exported</code>:标记允许其他应用程序使用这个Provider。</li>
<li><code>android:multiProcess</code>:标记允许系统启动Provider相同的进程中调用客户端。</li>
</ul>
<h3 id="49、Fragment状态保存"><a href="#49、Fragment状态保存" class="headerlink" title="49、Fragment状态保存"></a>49、Fragment状态保存</h3><p>Fragment状态保存入口:<br>1、Activity的状态保存, 在Activity的<code>onSaveInstanceState()</code>里, 调用了FragmentManger的<code>saveAllState()</code>方法, 其中会对mActive中各个Fragment的实例状态和View状态分别进行保存。</p>
<p>2、FragmentManager还提供了public方法: <code>saveFragmentInstanceState()</code>, 可以对单个Fragment进行状态保存, 这是提供给我们用的。</p>
<p>3、FragmentManager的<code>moveToState()</code>方法中, 当状态回退到ACTIVITY_CREATED, 会调用<code>saveFragmentViewState()</code>方法, 保存View的状态。</p>
<h3 id="50、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？"><a href="#50、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？" class="headerlink" title="50、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？"></a>50、直接在Activity中创建一个thread跟在service中创建一个thread之间的区别？</h3><p>在Activity中被创建：该Thread的就是为这个Activity服务的，完成这个特定的Activity交代的任务，主动通知该Activity一些消息和事件，Activity销毁后，该Thread也没有存活的意义了。</p>
<p>在Service中被创建：这是保证最长生命周期的Thread的唯一方式，只要整个Service不退出，Thread就可以一直在后台执行，一般在Service的<code>onCreate()</code>中创建，在<code>onDestroy()</code>中销毁。所以，在Service中创建的Thread，适合长期执行一些独立于APP的后台任务，比较常见的就是：在Service中保持与服务器端的长连接。</p>
<h3 id="51、如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？"><a href="#51、如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？" class="headerlink" title="51、如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？"></a>51、如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitamp 占用内存大小 &#x3D; 宽度像素 x （inTargetDensity &#x2F; inDensity） x 高度像素 x （inTargetDensity &#x2F; inDensity）x 一个像素所占的内存</span><br></pre></td></tr></table></figure>
<p>注：</p>
<p>inTargetDensity表示目标屏幕的dpi，</p>
<p>inDensity表示目标图片的dpi（放在哪个资源文件夹下），</p>
<p>所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高进行拉伸，进而改变Bitmap占用内存的大小。</p>
<p>在Bitmap里有两个获取内存占用大小的方法。<br><code>getByteCount()</code>：API12 加入，代表存储 Bitmap 的像素需要的最少内存。<br><code>getAllocationByteCount()</code>：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 <code>getByteCount()</code> 方法。在不复用 Bitmap 时，<code>getByteCount()</code> 和 <code>getAllocationByteCount()</code>返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 <code>getByteCount()</code> 表示<strong>新解码图片占用内存的大 小</strong>，<code>getAllocationByteCount()</code> 表示<strong>被复用 Bitmap 真实占用的内存大小</strong>（即 mBuffer 的长度）。</p>
<p>为了保证在加载Bitmap的时候不产生内存溢出，可以使用BitmapFactory进行图片压缩，主要有以下几个参数：<br><code>BitmapFactory.Options.inPreferredConfig</code>：将ARGB_8888改为RGB_565，改变编码方式，节约内存。<br><code>BitmapFactory.Options.inSampleSize</code>：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。<br><code>BitmapFactory.Options.inPurgeable</code>：让系统可以内存不足时回收内存。</p>
<h3 id="52、对于应用更新这块是如何做的？-灰度，强制更新，分区域更新"><a href="#52、对于应用更新这块是如何做的？-灰度，强制更新，分区域更新" class="headerlink" title="52、对于应用更新这块是如何做的？(灰度，强制更新，分区域更新)"></a>52、对于应用更新这块是如何做的？(灰度，强制更新，分区域更新)</h3><p><strong>应用更新：</strong><br>1、通过接口获取线上版本号，versionCode<br>2、比较线上的versionCode 和本地的versionCode，弹出更新窗口<br>3、下载APK文件（文件下载）<br>4、安装APK</p>
<p><strong>灰度：</strong><br>(1)找单一渠道投放特别版本。<br>(2)做升级平台的改造，允许针对部分用户推送升级通知甚至版本强制升级。<br>(3)开放单独的下载入口。<br>(4)是两个版本的代码都打到app包里，然后在app端植入测试框架，用来控制显示哪个版本。测试框架负责与服务器端api通信，由服务器端控制app上A/B版本的分布，可以实现指定的一组用户看到A版本，其它用户看到B版本。服务端会有相应的报表来显示A/B版本的数量和效果对比。最后可以由服务端的后台来控制，全部用户在线切换到A或者B版本~</p>
<p>无论哪种方法都需要做好版本管理工作，分配特别的版本号以示区别。<br>当然，既然是做灰度，数据监控（常规数据、新特性数据、主要业务数据）还是要做到位，该打的数据桩要打。还有，灰度版最好有收回的能力，一般就是强制升级下一个正式版。</p>
<p><strong>强制更新：</strong><br>一般的处理就是进入应用就弹窗通知用户有版本更新，弹窗可以没有取消按钮并不能取消。这样用户就只能选择更新或者关闭应用了，当然也可以添加取消按钮，但是如果用户选择取消则直接退出应用。</p>
<p><strong>增量更新：</strong><br>bsdiff：二进制差分工具<strong>bsdiff</strong>是相应的补丁合成工具,根据两个不同版本的二进制文件，生成补丁文件.patch文件。通过bspatch使旧的apk文件与不定文件合成新的apk。 注意通过apk文件的md5值进行区分版本。</p>
<h3 id="53、请解释安卓为啥要加签名机制。"><a href="#53、请解释安卓为啥要加签名机制。" class="headerlink" title="53、请解释安卓为啥要加签名机制。"></a>53、请解释安卓为啥要加签名机制。</h3><p>1、发送者的身份认证<br>由于开发商可能通过使用相同的 Package Name 来混淆替换已经安装的程序，以此<strong>保证签名不同的包不被替换</strong>。<br>2、保证信息传输的完整性<br>签名对于包中的每个文件进行处理，以此<strong>确保包中内容不被替换</strong>。<br>3、防止交易中的抵赖发生， Market 对软件的要求。</p>
<h3 id="54、为什么bindService可以跟Activity生命周期联动？"><a href="#54、为什么bindService可以跟Activity生命周期联动？" class="headerlink" title="54、为什么bindService可以跟Activity生命周期联动？"></a>54、为什么bindService可以跟Activity生命周期联动？</h3><p>1、bindService 方法执行时，LoadedApk 会记录 ServiceConnection 信息。</p>
<p>2、Activity 执行 finish 方法时，会通过 LoadedApk 检查 Activity 是否存在未注销/解绑的 BroadcastReceiver 和 ServiceConnection，如果有，那么会通知 AMS 注销/解绑对应的 BroadcastReceiver 和 Service，并打印异常信息，告诉用户应该主动执行注销/解绑的操作。</p>
<h3 id="55、如何通过Gradle配置多渠道包？"><a href="#55、如何通过Gradle配置多渠道包？" class="headerlink" title="55、如何通过Gradle配置多渠道包？"></a>55、如何通过Gradle配置多渠道包？</h3><p>用于生成不同渠道的包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;  </span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;        <span class="comment">// 或“&quot;360&quot;&#123;&#125;”，数字需下划线开头或加上双引号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>./gradlew assembleRelease</code>，将会打出所有渠道的release包；</p>
<p>执行<code>./gradlew assembleWandoujia</code>，将会打出豌豆荚渠道的release和debug版的包；</p>
<p>执行<code>./gradlew assembleWandoujiaRelease</code>，将生成豌豆荚的release包。</p>
<p>因此，可以结合buildType和productFlavor生成不同的Build Variants，即类型与渠道不同的组合。</p>
<h3 id="56、activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信？"><a href="#56、activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信？" class="headerlink" title="56、activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信？"></a>56、activty和Fragmengt之间怎么通信，Fragmengt和Fragmengt怎么通信？</h3><p>（一）Handler<br>（二）广播<br>（三）事件总线：EventBus、RxBus、Otto<br>（四）接口回调<br>（五）Bundle和setArguments(bundle)</p>
<h3 id="57、自定义view效率高于xml定义吗？说明理由。"><a href="#57、自定义view效率高于xml定义吗？说明理由。" class="headerlink" title="57、自定义view效率高于xml定义吗？说明理由。"></a>57、自定义view效率高于xml定义吗？说明理由。</h3><p>自定义view效率高于xml定义：<br>1、少了解析xml。<br>2.、自定义View 减少了ViewGroup与View之间的测量,包括父量子,子量自身,子在父中位置摆放,当子view变化时,父的某些属性都会跟着变化。</p>
<h3 id="58、广播注册一般有几种，各有什么优缺点？"><a href="#58、广播注册一般有几种，各有什么优缺点？" class="headerlink" title="58、广播注册一般有几种，各有什么优缺点？"></a>58、广播注册一般有几种，各有什么优缺点？</h3><p>第一种是常驻型(<strong>静态注册</strong>)：当应用程序关闭后如果有信息广播来，程序也会被系统调用，自己运行。<br>第二种不常驻(**动态注册)**：广播会跟随程序的生命周期。</p>
<p>动态注册<br>优点：在android的广播机制中，动态注册优先级高于静态注册优先级，因此在必要情况下，是需要动态注册广播接收者的。</p>
<p>缺点：当用来注册的 Activity 关掉后，广播也就失效了。</p>
<p>静态注册<br>优点：无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器就是打开着的。<br>注：由于Android系统限制，很多广播Action监听只能使用动态注册的方式实现监听。</p>
<h3 id="59、服务启动一般有几种，服务和activity之间怎么通信，服务和服务之间怎么通信"><a href="#59、服务启动一般有几种，服务和activity之间怎么通信，服务和服务之间怎么通信" class="headerlink" title="59、服务启动一般有几种，服务和activity之间怎么通信，服务和服务之间怎么通信"></a>59、服务启动一般有几种，服务和activity之间怎么通信，服务和服务之间怎么通信</h3><p>服务启动方式：<br>1、startService：<br><strong>onCreate()—&gt;onStartCommand() —&gt; onDestory()</strong></p>
<p>如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStartCommand()。一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。</p>
<p>2、bindService：<br><strong>onCreate() —&gt;onBind()—&gt;onunbind()—&gt;onDestory()</strong></p>
<p>bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。</p>
<p>服务和activity通信：</p>
<p>1、通过Binder对象。</p>
<p>2、通过broadcast(广播)。</p>
<h3 id="60、ddms-和-traceView-的区别？"><a href="#60、ddms-和-traceView-的区别？" class="headerlink" title="60、ddms 和 traceView 的区别？"></a>60、ddms 和 traceView 的区别？</h3><p>ddms 原意是：davik debug monitor service。简单的说 ddms 是一个程序执行查看器，在里面可以看见线程和堆栈等信息，traceView 是程序性能分析器。traceview 是 ddms 中的一部分内容。</p>
<p>Traceview 是 Android 平台特有的数据采集和分析工具，它主要用于分析 Android 中应用程序的 hotspot（瓶颈）。Traceview 本身只是一个数据分析工具，而数据的采集则需要使用 Android SDK 中的 Debug 类或者利用DDMS 工具。二者的用法如下：开发者在一些关键代码段开始前调用 Android SDK 中 Debug 类的 startMethodTracing 函数，并在关键代码段结束前调用 stopMethodTracing 函数。这两个函数运行过程中将采集运行时间内该应用所有线程（注意，只能是 Java线程） 的函数执行情况， 并将采集数据保存到/mnt/sdcard/下的一个文件中。 开发者然后需要利用 SDK 中的 Traceview工具来分析这些数据。</p>
<h3 id="61、ListView卡顿原因"><a href="#61、ListView卡顿原因" class="headerlink" title="61、ListView卡顿原因"></a>61、ListView卡顿原因</h3><p>Adapter的<code>getView()</code>方法里面convertView没有使用<code>setTag()</code>和<code>getTag()</code>方式；</p>
<p>在<code>getView()</code>方法里面ViewHolder初始化后的赋值或者是多个控件的显示状态和背景的显示没有优化好，抑或是里面含有复杂的计算和耗时操作；</p>
<p>在<code>getView()</code>方法里面 inflate的row 嵌套太深（布局过于复杂）或者是布局里面有大图片或者背景所致；</p>
<p>Adapter多余或者不合理的notifySetDataChanged；</p>
<p>listview 被多层嵌套，多次的onMessure导致卡顿，如果多层嵌套无法避免，建议把listview的高和宽设置为match_parent. 如果是代码继承的listview，那么也请你别忘记为你的继承类添加上LayoutPrams，注意高和宽都mactch_parent的；</p>
<h3 id="62、AndroidManifest的作用与理解"><a href="#62、AndroidManifest的作用与理解" class="headerlink" title="62、AndroidManifest的作用与理解"></a>62、AndroidManifest的作用与理解</h3><p>AndroidManifest.xml文件，也叫清单文件，来获知应用中是否包含该组件，如果有会直接启动该组件。可以理解是一个应用的配置文件。</p>
<p>作用：</p>
<ul>
<li>为应用的 Java 软件包命名。软件包名称充当应用的唯一标识符。</li>
<li>描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。</li>
<li>确定托管应用组件的进程。</li>
<li>声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限</li>
<li>列出 Instrumentation类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。</li>
<li>声明应用所需的最低 Android API 级别</li>
<li>列出应用必须链接到的库</li>
</ul>
<h3 id="63、LaunchMode应用场景"><a href="#63、LaunchMode应用场景" class="headerlink" title="63、LaunchMode应用场景"></a>63、LaunchMode应用场景</h3><p>standard，创建一个新的Activity。</p>
<p>singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。</p>
<p>singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。</p>
<p>注意:<br>设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值<strong>affinity</strong>等于它的属性值<strong>taskAffinity</strong>的Task存在；如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个<strong>独立的taskAffinity属性值</strong>。</p>
<p>如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。<br><strong>在一个任务栈中只有一个”singleTask”启动模式的Activity存在</strong>。他的上面可以有其他的Activity。这点与singleInstance是有区别的。</p>
<p>singleInstance，回退栈中，只有这一个Activity，没有其他Activity。</p>
<p>singleTop适合接收通知启动的内容显示页面。<br>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>
<p>singleTask适合作为程序入口点。<br>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<p>singleInstance应用场景：<br>闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>
<h3 id="64、说说Activity、Intent、Service-是什么关系"><a href="#64、说说Activity、Intent、Service-是什么关系" class="headerlink" title="64、说说Activity、Intent、Service 是什么关系"></a>64、说说Activity、Intent、Service 是什么关系</h3><p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件之一。他俩都是 Context 类的子类 ContextWrapper 的子类，因此他俩可以算是兄弟关系吧。不过兄弟俩各有各自的本领，<strong>Activity 负责用户界面的显示和交互，Service 负责后台任务的处理</strong>。Activity 和 Service 之间可以通过 Intent 传递数据，因此可以把 Intent 看作是通信使者。</p>
<h3 id="65、ApplicationContext和ActivityContext的区别"><a href="#65、ApplicationContext和ActivityContext的区别" class="headerlink" title="65、ApplicationContext和ActivityContext的区别"></a>65、ApplicationContext和ActivityContext的区别</h3><p>这是两种不同的对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次。至于用哪种context，得看应用场景。还有就是，在使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：</p>
<ul>
<li>不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的。</li>
<li>对于生命周期长的对象，可以使用application context。</li>
<li>避免非静态的内部类，尽量使用静态类，避免生命周期问题，<strong>注意内部类对外部对象引用导致的生命周期变化</strong>。</li>
</ul>
<h3 id="66、Handler、Thread和HandlerThread的差别"><a href="#66、Handler、Thread和HandlerThread的差别" class="headerlink" title="66、Handler、Thread和HandlerThread的差别"></a>66、Handler、Thread和HandlerThread的差别</h3><p>1、Handler：在android中负责发送和处理消息，通过它可以实现子线程与主线程之间的消息通讯。</p>
<p>2、Thread：Java进程中执行运算的最小单位，亦即执行处理机调度的基本单位。某一进程中一路单独运行的程序。</p>
<p>3、HandlerThread：一个继承自Thread的类HandlerThread，Android中没有对Java中的Thread进行任何封装，而是提供了一个继承自Thread的类HandlerThread类，这个类对Java的Thread做了很多便利的封装。HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，它在<strong>内部直接实现了Looper的实现</strong>，这是Handler消息机制必不可少的。有了自己的looper，可以让我们<strong>在自己的线程中分发和处理消息</strong>。如果不用HandlerThread的话，需要手动去调用Looper.prepare()和Looper.loop()这些方法。</p>
<h3 id="67、ThreadLocal的原理"><a href="#67、ThreadLocal的原理" class="headerlink" title="67、ThreadLocal的原理"></a>67、ThreadLocal的原理</h3><p>ThreadLocal是一个关于<strong>创建线程局部变量的类</strong>。使用场景如下所示：</p>
<ul>
<li><p><strong>实现单个线程单例</strong>以及单个线程上下文信息存储，比如交易id等。</p>
</li>
<li><p><strong>实现线程安全</strong>，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例。 承载一些线程相关的数据，避免在方法中来回传递参数。</p>
</li>
</ul>
<p>当需要使用多线程时，有个变量恰巧不需要共享，此时就不必使用synchronized这么麻烦的关键字来锁住，每个线程都相当于在堆内存中开辟一个空间，线程中带有对共享变量的缓冲区，通过缓冲区将堆内存中的共享变量进行读取和操作，<strong>ThreadLocal相当于线程内的内存，一个局部变量</strong>。每次可以对线程自身的数据读取和操作，并不需要通过缓冲区与 主内存中的变量进行交互。并不会像synchronized那样修改主内存的数据，再将主内存的数据复制到线程内的工作内存。ThreadLocal可以让线程独占资源，存储于线程内部，避免线程堵塞造成CPU吞吐下降。</p>
<p>在每个Thread中包含一个ThreadLocalMap，ThreadLocalMap的key是ThreadLocal的对象，value是独享数据。</p>
<h3 id="68、计算一个view的嵌套层级"><a href="#68、计算一个view的嵌套层级" class="headerlink" title="68、计算一个view的嵌套层级"></a>68、计算一个view的嵌套层级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getParents</span><span class="params">(ViewParents view)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(view.getParents() == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + getParents(view.getParents));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="69、MVP，MVVM，MVC解释和实践"><a href="#69、MVP，MVVM，MVC解释和实践" class="headerlink" title="69、MVP，MVVM，MVC解释和实践"></a>69、MVP，MVVM，MVC解释和实践</h3><p><strong>MVC</strong>:</p>
<ul>
<li>视图层(View) 对应于xml布局文件和java代码动态view部分</li>
<li>控制层(Controller) MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。</li>
<li>模型层(Model) 针对业务模型，建立数据结构和相关的类，它主要负责网络请求，数据库处理，I/O的操作。</li>
</ul>
<p><strong>总结</strong></p>
<p>具有一定的分层，model彻底解耦，controller和view并没有解耦 层与层之间的交互尽量使用回调或者去使用消息机制去完成，尽量避免直接持有 controller和view，在android中无法做到彻底分离，但在代码逻辑层面一定要分清，业务逻辑被放置在model层，能够更好的复用和修改增加业务。</p>
<p><strong>MVP</strong></p>
<p>通过引入接口BaseView，让相应的视图组件如Activity，Fragment去实 BaseView，实现了视图层的独立，通过中间层Preseter实现了Model和View的完全解耦。MVP彻底解决了MVC中View和Controller傻傻分不清楚的问题，但是随着业务逻辑的增加，一个页面可能会非常复杂，UI的改变是非常多，会有非常多的case，这样就会造成View的接口会很庞大。</p>
<p><strong>MVVM</strong></p>
<p>MVP中我们说过随着业务逻辑的增加，UI的改变多的情况下，会有非常多的跟UI相关的case，这样就会造成View的接口会很庞大。而MVVM就解决了这个问题，通过<strong>双向绑定</strong>的机制，实现数据和UI内容，只要想改其中一方，另一方都能够及时更新的一种设计理念，这样就省去了很多在View层中写很多case的情况，只需要改变数据就行。</p>
<p><strong>MVVM与DataBinding的关系？</strong></p>
<p>MVVM是一种思想，DataBinding是谷歌推出的方便实现MVVM的工具。</p>
<p>看起来MVVM很好的解决了MVC和MVP的不足，但是由于数据和视图的双向绑定，导致出现问题时不太好定位来源，有可能数据问题导致，也有可能业务逻辑中对视图属性的修改导致。如果项目中打算用MVVM的话可以考虑使用官方的架构组件ViewModel、LiveData、DataBinding去实现MVVM。</p>
<p><strong>三者如何选择？</strong></p>
<ul>
<li>如果项目简单，没什么复杂性，未来改动也不大的话，那就不要用设计模式或者架构方法，只需要将每个模块封装好，方便调用即可，不要为了使用设计模式或架构方法而使用。</li>
<li>对于偏向展示型的app，绝大多数业务逻辑都在后端，app主要功能就是展示数据，交互等，建议使用mvvm。</li>
<li>对于工具类或者需要写很多业务逻辑app，使用mvp或者mvvm都可。</li>
</ul>
<h3 id="70、SharedPrefrences的apply和commit有什么区别？"><a href="#70、SharedPrefrences的apply和commit有什么区别？" class="headerlink" title="70、SharedPrefrences的apply和commit有什么区别？"></a>70、SharedPrefrences的apply和commit有什么区别？</h3><p>这两个方法的区别在于：</p>
<ol>
<li><p> <strong>apply没有返回值</strong>而<strong>commit返回boolean表明修改是否提交成功</strong>。</p>
</li>
<li><p> apply是将修改数据原子提交到内存, 而后<strong>异步</strong>真正提交到硬件磁盘。 而commit是<strong>同步</strong>的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接<strong>覆盖</strong>前面的内存数据，这样从一定程度上提高了很多效率。</p>
</li>
<li><p> apply方法不会提示任何失败的提示。 由于在一个进程中，sharedPreference是单实例，一般不会出现并发冲突，如果对提交的结果不关心的话，建议使用apply，当然需要确保提交成功且有后续操作的话，还是需要用commit的。</p>
</li>
</ol>
<h3 id="71、Base64、MD5是加密方法么？"><a href="#71、Base64、MD5是加密方法么？" class="headerlink" title="71、Base64、MD5是加密方法么？"></a>71、Base64、MD5是加密方法么？</h3><p><strong>Base64 是什么？</strong></p>
<p>Base64是用文本表示二进制的编码方式，它使<strong>用4个字节的文本来表示3个字节的原始二进制数据</strong>。 它将二进制数据转换成一个由64个可打印的字符组成的序列：A-Za-z0-9+/。<strong>注意：Base64绝对不会压缩文件大小，反而会增加文件大小</strong></p>
<p><strong>MD5是什么？</strong></p>
<p>MD5是哈希算法的一种，可以将任意数据产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。我们常在注册登录模块使用MD5，用户密码可以使用MD5加密的方式进行存储。如：md5(hello world,32) =5eb63bbbe01eeed093cb22bb8f5acdc3</p>
<p>加密，指的是对数据进行转换以后，数据变成了另一种格式，并且除了拿到解密方法的人，没人能把数据转换回来。 MD5是一种信息摘要算法，它是<strong>不可逆的，不可以解密</strong>。所以它只能算的上是一种单向加密算法。 Base64也不是加密算法，它是一种数据编码方式，虽然是可逆的，但是它的编码方式是公开的，无所谓加密。</p>
<h3 id="72、HttpClient和HttpConnection的区别？"><a href="#72、HttpClient和HttpConnection的区别？" class="headerlink" title="72、HttpClient和HttpConnection的区别？"></a>72、HttpClient和HttpConnection的区别？</h3><p>HttpClient适用于web浏览器，拥有大量灵活的API，实现起来比较稳定，且其功能比较丰富，提供了很多工具，封装了http的请求头，参数，内容体，响应，还有一些高级功能，代理、COOKIE、鉴权、压缩、连接池的处理。但是，正因此，在不破坏兼容性的前提下，其庞大的API也使人难以改进，因此Android团队对于修改优化Apache HttpClient并不积极。(并在Android 6.0中抛弃了HttpClient，替换成OkHttp)</p>
<p>HttpURLConnection对于大部分功能都进行了包装，HttpClient的高级功能代码会较复杂，另外，HttpURLConnection在Android 2.3中增加了一些Https方面的改进(包括HttpClient，两者都支持https)。且在Android 4.0中增加了response cache。当缓存被安装后(调用HttpResponseCache的<code>install()</code>方法)，所有的HTTP请求都会满足以下三种情况：</p>
<ul>
<li>所有的缓存响应都由本地存储来提供。因为没有必要去发起任务的网络连接请求，所有的响应都可以立刻获取到。</li>
<li> 视情况而定的缓存响应必须要有服务器来进行更新检查。比如说客户端发起了一条类似于 “如果/foo.png这张图片发生了改变，就将它发送给我” 这样的请求，服务器需要将更新后的数据进行返回，或者返回一个304 Not Modified状态。如果请求的内容没有发生，客户端就不会下载任何数据。</li>
<li> 没有缓存的响应都是由服务器直接提供的。这部分响应会在稍后存储到响应缓存中。</li>
</ul>
<p>在Android 2.2版本之前，HttpClient拥有较少的bug，因此使用它是最好的选择。 而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择。它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。对于新的应用程序应该更加偏向于使用HttpURLConnection，因为在以后的工作当中Android官方也会将更多的时间放在优化HttpURLConnection上面。</p>
<h3 id="73、ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A与B均不透明。"><a href="#73、ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A与B均不透明。" class="headerlink" title="73、ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A与B均不透明。"></a>73、ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A与B均不透明。</h3><p><strong>ActivityA跳转到ActivityB：1-3-1</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Activity A：onPause</span><br><span class="line">Activity B：onCreate</span><br><span class="line">Activity B：onStart</span><br><span class="line">Activity B：onResume</span><br><span class="line">Activity A：onStop</span><br></pre></td></tr></table></figure>

<p><strong>ActivityB返回ActivityA：1-3-2</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Activity B：onPause</span><br><span class="line">Activity A：onRestart</span><br><span class="line">Activity A：onStart</span><br><span class="line">Activity A：onResume</span><br><span class="line">Activity B：onStop</span><br><span class="line">Activity B：onDestroy</span><br></pre></td></tr></table></figure>

<h3 id="74、如何通过广播拦截和abort一条短信？"><a href="#74、如何通过广播拦截和abort一条短信？" class="headerlink" title="74、如何通过广播拦截和abort一条短信？"></a>74、如何通过广播拦截和abort一条短信？</h3><p>可以监听这条信号，在传递给真正的接收程序时，我们将自定义的广播接收程序的<strong>优先级大于它</strong>，并且<strong>取消广播的传播</strong>，这样就可以实现拦截短信的功能了。</p>
<h3 id="75、BroadcastReceiver，LocalBroadcastReceiver-区别？"><a href="#75、BroadcastReceiver，LocalBroadcastReceiver-区别？" class="headerlink" title="75、BroadcastReceiver，LocalBroadcastReceiver 区别？"></a>75、BroadcastReceiver，LocalBroadcastReceiver 区别？</h3><p><strong>1、应用场景</strong></p>
<p>1、BroadcastReceiver用于<strong>应用之间</strong>的传递消息；</p>
<p>2、而LocalBroadcastManager用于<strong>应用内部</strong>传递消息，比broadcastReceiver更加高效。</p>
<p><strong>2、安全</strong></p>
<p>1、BroadcastReceiver使用的Content API，所以本质上它是<strong>跨应用</strong>的，所以在使用它时必须要考虑到不要被别的应用滥用；</p>
<p>2、LocalBroadcastManager不需要考虑安全问题，因为它只在应用内部有效。</p>
<p><strong>3、原理方面</strong></p>
<p>(1) 与<strong>BroadcastReceiver是以 Binder 通讯方式为底层实现的机制</strong>不同，LocalBroadcastManager 的核心实现实际还是 <strong>Handler</strong>，只是利用到了 **IntentFilter 的 match **功能，至于 BroadcastReceiver 换成其他接口也无所谓，顺便利用了现成的类和概念而已。</p>
<p>(2) LocalBroadcastManager因为是 Handler 实现的应用内的通信，自然安全性更好，效率更高。</p>
<h3 id="76、如何选择第三方，从那些方面考虑？"><a href="#76、如何选择第三方，从那些方面考虑？" class="headerlink" title="76、如何选择第三方，从那些方面考虑？"></a>76、如何选择第三方，从那些方面考虑？</h3><p><strong>大方向：从软件环境做判断</strong></p>
<p>性能是开源软件第一解决的问题。</p>
<p>一个好的生态，是一个优秀的开源库必备的，取决标准就是观察它是否一直在持续更新迭代，是否能及时处理github上用户提出来的问题。大家在社区针对这个开源库是否有比较活跃的探讨。</p>
<p>背景，该开源库由谁推出，由哪个公司推出来的。</p>
<p>用户数和有哪些知名的企业落地使用</p>
<p><strong>小方向：从软件开发者的角度做判断</strong></p>
<p>是否解决了我们现有问题或长期来看带来的维护成本。</p>
<p>公司有多少人会。</p>
<p>学习成本。</p>
<h3 id="77、简单说下接入支付的流程，是否自己接入过支付功能？"><a href="#77、简单说下接入支付的流程，是否自己接入过支付功能？" class="headerlink" title="77、简单说下接入支付的流程，是否自己接入过支付功能？"></a>77、简单说下接入支付的流程，是否自己接入过支付功能？</h3><p>Alipay支付功能：</p>
<p>1.首先登录支付宝开放<strong>平台创建应用</strong>，并给应用添加App支付功能， 由于App支付功能需要<strong>签约</strong>，因此需要上传公司信息和证件等资料进行签约。</p>
<p>2.签约成功后，需要<strong>配置秘钥</strong>。使用支付宝提供的工具生成RSA公钥和私钥，公钥需要设置到管理后台。</p>
<p>3.android studio<strong>集成SDK</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）copy jar包；</span><br><span class="line">（2）发起支付请求，处理支付请求。</span><br></pre></td></tr></table></figure>

<h3 id="78、单例实现线程的同步的要求："><a href="#78、单例实现线程的同步的要求：" class="headerlink" title="78、单例实现线程的同步的要求："></a>78、单例实现线程的同步的要求：</h3><p>1.单例类确保自己只有一个实例(构造函数私有:不被外部实例化,也不被继承)。</p>
<p>2.单例类必须自己创建自己的实例。</p>
<p>3.单例类必须为其他对象提供唯一的实例。</p>
<h3 id="79、如何保证Service不被杀死？（保活）"><a href="#79、如何保证Service不被杀死？（保活）" class="headerlink" title="79、如何保证Service不被杀死？（保活）"></a>79、如何保证Service不被杀死？（保活）</h3><p>Android 进程不死从3个层面入手：</p>
<p><strong>A.提供进程优先级，降低进程被杀死的概率</strong></p>
<p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台service。</p>
<p>方法三：提升service优先级：</p>
<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
<p><strong>B. 在进程被杀死后，进行拉活</strong></p>
<p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等</p>
<p>方法二：双进程相互唤起。</p>
<p>方法三：依靠系统唤起。</p>
<p>方法四：<code>onDestroy()</code>方法里重启service：service + broadcast 方式，就是当service走onDestory()的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>
<p><strong>C. 依靠第三方</strong></p>
<p>根据不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<h3 id="80、说说ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#80、说说ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="80、说说ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>80、说说ContentProvider、ContentResolver、ContentObserver 之间的关系？</h3><p>ContentProvider：内容提供者，管理数据，<strong>提供数据的增删改查操作</strong>，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做<strong>进程间数据共享</strong>。</p>
<p>ContentResolver：内容解析者，ContentResolver可以为不同URI操作不同的ContentProvider中的数据，<strong>外部进程可以通过ContentResolver与ContentProvider进行交互。</strong></p>
<p>ContentObserver：内容观察者，<strong>观察ContentProvider中的数据变化，并将变化通知给外界</strong>。</p>
<h3 id="81、如何导入外部数据库"><a href="#81、如何导入外部数据库" class="headerlink" title="81、如何导入外部数据库?"></a>81、如何导入外部数据库?</h3><p>把原数据库包括在项目源码的 <code>res/raw</code>。</p>
<p>android系统下数据库应该存放在<code>/data/data/com.(package name)/</code>目录下，所以我们需要做的是把已有的数据库传入那个目录下。操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录。</p>
<h4 id="82、LinearLayout、FrameLayout、RelativeLayout性能对比，为什么？"><a href="#82、LinearLayout、FrameLayout、RelativeLayout性能对比，为什么？" class="headerlink" title="82、LinearLayout、FrameLayout、RelativeLayout性能对比，为什么？"></a>82、LinearLayout、FrameLayout、RelativeLayout性能对比，为什么？</h4><p>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子 View 2次onMeasure</p>
<p>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。</p>
<p>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</p>
<p><strong>为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout？</strong></p>
<p>因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</p>
<h3 id="83、scheme跳转协议"><a href="#83、scheme跳转协议" class="headerlink" title="83、scheme跳转协议"></a>83、scheme跳转协议</h3><p>Android中的scheme是一种<strong>页面内跳转协议</strong>，通过定义自己的scheme协议，可以跳转到app中的各个页面</p>
<p>服务器可以定制化告诉app跳转哪个页面</p>
<p>App可以通过scheme跳转到另一个App页面</p>
<p>可以通过H5页面跳转页面</p>
<h3 id="84、HandlerThread"><a href="#84、HandlerThread" class="headerlink" title="84、HandlerThread"></a>84、HandlerThread</h3><p>1、HandlerThread原理</p>
<p>当系统有多个耗时任务需要执行时，每个任务都会开启个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能。为了解决这一问题，Google提出了HandlerThread，HandlerThread本质上是一个线程类，它继承了Thread。HandlerThread有自己的内部Looper对象，可以进行loopr循环。通过获取HandlerThread的looper对象传递给Handler对象，可以在<code>handleMessage()</code>方法中<strong>执行异步任务</strong>。创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用<code>run()</code>方法，创建Looper对象。当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞。它在Android中的一个具体的使用场景是IntentService。由于HanlderThread的<code>run()</code>方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的<code>quit()</code>或者<code>quitSafely()</code>方法来终止线程的执行。</p>
<p>2、HanlderThread的优缺点</p>
<ul>
<li><p>HandlerThread优点是异步不会堵塞，减少对性能的消耗。</p>
</li>
<li><p>HandlerThread缺点是不能同时继续进行多任务处理，要等待进行处理，处理效率较低。</p>
</li>
<li><p>HandlerThread与线程池不同，HandlerThread是一个串队列，背后只有一个线程。</p>
</li>
</ul>
<h3 id="85、IntentService"><a href="#85、IntentService" class="headerlink" title="85、IntentService"></a>85、IntentService</h3><p>IntentService是一种特殊的Service，它继承了Service并且它是一个<strong>抽象类</strong>，因此必须创建它的子类才能使用IntentService。</p>
<p><strong>原理</strong></p>
<p>在实现上，IntentService封装了HandlerThread和Handler。当IntentService被第一次启动时，它的<code>onCreate()</code>方法会被调用，<code>onCreate()</code>方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。</p>
<p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至<code>onStartCommand()</code>方法的Intetnt。</p>
<p>生成一个工作队列来传送Intent对象给<code>onHandleIntent()</code>方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用<code>stopSelf()</code>方法来停止。</p>
<p>该服务提供了一个<code>onBind()</code>方法的默认实现，它返回null。</p>
<p>提供了一个<code>onStartCommand()</code>方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至<code>onHandleIntent()</code>方法，在该方法中对Intent做相应的处理。</p>
<p><strong>为什么在mServiceHandler的handleMessage()回调方法中执行完onHandlerIntent()方法后要使用带参数的stopSelf()方法？</strong></p>
<p>因为<code>stopSel()</code>方法会立即停止服务，而<code>stopSelf(int startId)</code>会等待所有的消息都处理完毕后才终止服务，一般来说，<code>stopSelf(int startId)</code>在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务。</p>
<h3 id="86、如何将一个Activity设置成窗口的样式。"><a href="#86、如何将一个Activity设置成窗口的样式。" class="headerlink" title="86、如何将一个Activity设置成窗口的样式。"></a>86、如何将一个Activity设置成窗口的样式。</h3><p>中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme&#x3D;&quot;@android:style&#x2F;Theme.Dialog&quot;</span><br></pre></td></tr></table></figure>

<p>另外</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme&#x3D;&quot;@android:style&#x2F;Theme.Transparent&quot;</span><br></pre></td></tr></table></figure>

<p>是设置透明。</p>
<h3 id="87、Android中跨进程通讯的几种方式"><a href="#87、Android中跨进程通讯的几种方式" class="headerlink" title="87、Android中跨进程通讯的几种方式"></a>87、Android中跨进程通讯的几种方式</h3><p>1：访问其他应用程序的Activity 如调用系统通话应用(<strong>隐式意图</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent callIntent &#x3D; new Intent(Intent.ACTION_CALL,Uri.parse(&quot;tel:12345678&quot;);</span><br><span class="line">startActivity(callIntent);</span><br></pre></td></tr></table></figure>

<p>2：<strong>ContentProvider</strong> 如访问系统相册</p>
<p>3：广播（<strong>Broadcast</strong>） 如显示系统时间</p>
<p>4：<strong>AIDL服务</strong></p>
<h3 id="88、显示Intent与隐式Intent的区别"><a href="#88、显示Intent与隐式Intent的区别" class="headerlink" title="88、显示Intent与隐式Intent的区别"></a>88、显示Intent与隐式Intent的区别</h3><p>对明确指出了目标组件名称的Intent，我们称之为“显式Intent”。</p>
<p>对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。</p>
<p>对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到：</p>
<p>动作(Action)</p>
<p>类别(Category [‘kætɪg(ə)rɪ] )</p>
<p>数据(Data )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name&#x3D;&quot;.MainActivity&quot;  android:label&#x3D;&quot;@string&#x2F;app_name&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;com.wpc.test&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:mimeType&#x3D;&quot;image&#x2F;gif&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure>

<h3 id="89、Android-Holo主题与MD主题的理念，以及你的看法"><a href="#89、Android-Holo主题与MD主题的理念，以及你的看法" class="headerlink" title="89、Android Holo主题与MD主题的理念，以及你的看法"></a>89、Android Holo主题与MD主题的理念，以及你的看法</h3><p>Holo Theme</p>
<p>Holo Theme 是 Android Design 的最基础的呈现方式。因为是最为基础的 Android Design 呈现形式，每一台 Android 4.X 的手机系统内部都有集成 Holo Theme 需要的控件，即开发者不需要自己设计控件，而是直接从系统里调用相应的控件。在 UI 方面没有任何的亮点，和 Android4.X 的设置/电话的视觉效果极度统一。由此带来的好处显而易见，这个应用作为 Android 应用的辨识度极高，且完全不可能与系统风格产生冲突。</p>
<p>Material Design</p>
<p>Material design其实是单纯的一种设计语言，它包含了系统界面风格、交互、UI,更加专注拟真,更加大胆丰富的用色,更加丰富的交互形式,更加灵活的布局形式</p>
<p>1.鲜明、形象的界面风格，</p>
<p>2.色彩搭配使得应用看起来非常的大胆、充满色彩感，凸显内容</p>
<p>3.Material design对于界面的排版非常的重视</p>
<p>4.Material design的交互设计上采用的是响应式交互，这样的交互设计能把一个应用从简单展现用户所请求的信息，提升至能与用户产生更强烈、更具体化交互的工具。</p>
<h3 id="90、如何让程序自动启动？"><a href="#90、如何让程序自动启动？" class="headerlink" title="90、如何让程序自动启动？"></a>90、如何让程序自动启动？</h3><p>定义一个Braodcastreceiver，action为BOOT_COMPLETE，接受到广播后启动程序。</p>
<h3 id="91、Fragment-在-ViewPager-里面的生命周期，滑动-ViewPager-的页面时-Fragment-的生命周期的变化。"><a href="#91、Fragment-在-ViewPager-里面的生命周期，滑动-ViewPager-的页面时-Fragment-的生命周期的变化。" class="headerlink" title="91、Fragment 在 ViewPager 里面的生命周期，滑动 ViewPager 的页面时 Fragment 的生命周期的变化。"></a>91、Fragment 在 ViewPager 里面的生命周期，滑动 ViewPager 的页面时 Fragment 的生命周期的变化。</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310134117654.png" alt="image-20210310134117654"></p>
<p>可以看到,MainAcitivity按照常规顺序调用后，FirstFragment和SecondFragment先后调用了onAttach和onCreate实例化了Fragment,并且在FirstFragment调用onResume之后，SecondFragment也调用了onResume，也就是是说SecondFragment已经加载好了，随时准备变为可见，接下来滑动到SecondFragment,可以看到：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310134218406.png" alt="image-20210310134218406"></p>
<p>没错,加载的是第三个Fragment，然后再滑到第三个Fragment，可以看到：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310134333084.png" alt="image-20210310134333084"></p>
<p>第一个Fragment已经DestroyView了，FragmentPagerAdapter默认的是会加载前后两个pager,这次在程序启动时调用pager的setCurrentItem(1)方法，嗯，心里面已经知道会输出什么了，来验证一下，：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210310134502042.png" alt="image-20210310134502042"></p>
<p>输出了这么多，和心里想的一样，第一个pager里的Fragment和第二个pager里的Fragment都已经加载了。<br> 我在这里的理解<strong>是onResume()调用后，不一样像网上讲得那样，一定会从不可见变得可见，有可能是把自己加载到了内存，随时准备着和用户交互。</strong></p>
<h3 id="92、屏幕适配的处理技巧都有哪些"><a href="#92、屏幕适配的处理技巧都有哪些" class="headerlink" title="92、屏幕适配的处理技巧都有哪些?"></a>92、屏幕适配的处理技巧都有哪些?</h3><p><strong>一、为什么要适配</strong></p>
<p>为了保证用户获得一致的用户体验效果,使得某一元素在Android不同尺寸、不同分辨率的、不同系统的手机上具备相同的显示效果，能够保持界面上的效果一致,我们需要对各种手机屏幕进行适配！</p>
<ul>
<li>Android系统碎片化：基于Google原生系统，小米定制的MIUI、魅族定制的flyme、华为定制的EMUI等等；</li>
<li>Android机型屏幕尺寸碎片化：5寸、5.5寸、6寸等等；</li>
<li>Android屏幕分辨率碎片化：320x480、480x800、720x1280、1080x1920等。</li>
</ul>
<p><strong>二、基本概念</strong></p>
<ul>
<li>像素（px）：像素就是手机屏幕的最小构成单元，px = 1像素点 一般情况下UI设计师的设计图会以px作为统一的计量单位。</li>
<li>分辨率：手机在横向、纵向上的像素点数总和 一般描述成 宽*高 ，即横向像素点个数 * 纵向像素点个数（如1080 x 1920），单位：px。</li>
<li>屏幕尺寸：手机对角线的物理尺寸。单位 英寸（inch），一英寸大约2.54cm 常见的尺寸有4.7寸、5寸、5.5寸、6寸。</li>
<li>屏幕像素密度（dpi）：每英寸的像素点数，例如每英寸内有160个像素点，则其像素密度为160dpi，单位：dpi（dots per inch）。</li>
<li>标准屏幕像素密度（mdpi）： 每英寸长度上还有160个像素点（160dpi），即称为标准屏幕像素密度（mdpi）。</li>
<li>密度无关像素（dp）：与终端上的实际物理像素点无关，可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位，dp与px的转换：1dp = （dpi / 160 ） * 1px。</li>
<li>独立比例像素（sp）：字体大小专用单位 Android开发时用此单位设置文字大小，推荐使用12sp、14sp、18sp、22sp作为字体大小。</li>
</ul>
<p><strong>三、适配方案</strong></p>
<p>适配的最多的3个分辨率：1280x720,1920x1080,800x480。</p>
<p>解决方案：</p>
<p>对于Android的屏幕适配，我认为可以从以下4个方面来做：</p>
<p>1、布局组件适配</p>
<ul>
<li>请务必使用密度无关像素 dp 或独立比例像素 sp 单位指定尺寸。</li>
<li>使用相对布局或线性布局，不要使用绝对布局</li>
<li>使用wrap_content、match_parent、权重</li>
<li>使用minWidth、minHeight、lines等属性</li>
</ul>
<p>dimens使用：</p>
<p>不同的屏幕尺寸可以定义不同的数值，或者是不同的语言显示我们也可以定义不同的数值，因为翻译后的长度一般都不会跟中文的一致。此外，也可以使用百分比布局或者AndroidStudio2.2的新特性约束布局。</p>
<p>2、布局适配</p>
<p>使用限定符（屏幕密度限定符、尺寸限定符、最小宽度限定符、布局别名、屏幕方向限定符)根据屏幕的配置来加载相应的UI布局。</p>
<p>3、图片资源适配</p>
<p>使用自动拉伸图.9png图片格式使图片资源自适应屏幕尺寸。</p>
<p>普通图片和图标：</p>
<p>建议按照官方的密度类型进行切图即可，但一般我们只需xxhdpi或xxxhdpi的切图即可满足我们的需求；</p>
<p>4、代码适配：</p>
<p>在代码中使用Google提供的API对设备的屏幕宽度进行测量，然后按照需求进行设置。</p>
<p>5、接口配合：</p>
<p>本地加载图片前判断手机分辨率或像素密度，向服务器请求对应级别图片。</p>
<h3 id="93、断点续传实现？"><a href="#93、断点续传实现？" class="headerlink" title="93、断点续传实现？"></a>93、断点续传实现？</h3><p>在本地下载过程中要使用数据库实时存储到底存储到文件的哪个位置了，这样点击开始继续传递时，才能通过HTTP的GET请求中的<code>setRequestProperty(&quot;Range&quot;,&quot;bytes=startIndex-endIndex&quot;);</code>方法可以告诉服务器，数据从哪里开始，到哪里结束。同时在本地的文件写入时，RandomAccessFile的<code>seek()</code>方法也支持在文件中的任意位置进行写入操作。最后通过广播或事件总线机制将子线程的进度告诉Activity的进度条。关于断线续传的HTTP状态码是206，即<code>HttpStatus.SC_PARTIAL_CONTENT</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String path = <span class="string">&quot;http://10.0.2.2:8080/FeiQ.exe&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> EditText et_url;</span><br><span class="line">	<span class="keyword">private</span> EditText et_count;</span><br><span class="line">	<span class="keyword">private</span> Button btn_down;</span><br><span class="line">	<span class="keyword">private</span> LinearLayout ll_progress;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> blockSize;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        et_url = (EditText) findViewById(R.id.et_url);</span><br><span class="line">        et_count = (EditText) findViewById(R.id.et_count);</span><br><span class="line">        btn_down = (Button) findViewById(R.id.btn_download);</span><br><span class="line">        ll_progress = (LinearLayout) findViewById(R.id.ll_progress);</span><br><span class="line">        </span><br><span class="line">        btn_down.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//给线性布局中添加进度条</span></span><br><span class="line">		ll_progress.removeAllViews();</span><br><span class="line">		String temp = et_count.getText().toString().trim();</span><br><span class="line">		<span class="keyword">int</span> count = Integer.parseInt(temp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">			<span class="comment">//把xml布局文件转换为View对象 并且塞到ViewGroup中</span></span><br><span class="line">			View.inflate(getApplicationContext(), R.layout.item, ll_progress);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//①联网获取要下载的文件长度</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">					HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">					connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">					connection.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">					<span class="keyword">int</span> code = connection.getResponseCode();</span><br><span class="line">					<span class="keyword">if</span>(code==<span class="number">200</span>)&#123;</span><br><span class="line">						<span class="comment">//获取要下载的文件长度</span></span><br><span class="line">						<span class="keyword">int</span> length = connection.getContentLength();</span><br><span class="line">						<span class="comment">//在本地创建一个一样大的文件</span></span><br><span class="line">						RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(getFileName(path), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">						file.setLength(length);</span><br><span class="line">						blockSize = length/threadCount;</span><br><span class="line">						<span class="comment">//计算每一个线程要下载的数据范围</span></span><br><span class="line">						<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">							<span class="keyword">int</span> startIndex = i*blockSize;</span><br><span class="line">						    <span class="keyword">int</span> endIndex = (i+<span class="number">1</span>)*blockSize-<span class="number">1</span>;</span><br><span class="line">						    <span class="keyword">if</span>(i == threadCount-<span class="number">1</span>)&#123;</span><br><span class="line">						    	<span class="comment">//说明是最后一个线程</span></span><br><span class="line">						    	endIndex = length-<span class="number">1</span>;</span><br><span class="line">						    &#125;</span><br><span class="line">						    ProgressBar pb = (ProgressBar) ll_progress.getChildAt(i);</span><br><span class="line">						    <span class="comment">//给进度条设置显示的最大进度</span></span><br><span class="line">						    pb.setMax(endIndex-startIndex);</span><br><span class="line">						    <span class="keyword">new</span> DownLoadThread(startIndex, endIndex, i).start();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownLoadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> startIndex;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> endIndex;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> threadID;</span><br><span class="line">		<span class="keyword">private</span> ProgressBar pb;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">DownLoadThread</span><span class="params">(<span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex, <span class="keyword">int</span> threadID)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">			<span class="keyword">this</span>.endIndex = endIndex;</span><br><span class="line">			<span class="keyword">this</span>.threadID = threadID;</span><br><span class="line">			<span class="keyword">this</span>.pb = (ProgressBar) ll_progress.getChildAt(threadID);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//读取出记录下来的位置</span></span><br><span class="line">				File temp = <span class="keyword">new</span> File(getFileName(path)+threadID+<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span>(temp!=<span class="keyword">null</span> &amp;&amp; temp.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="comment">//说明日志文件有内容</span></span><br><span class="line">					FileInputStream fis = <span class="keyword">new</span> FileInputStream(temp);</span><br><span class="line">					BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">					String result = reader.readLine();</span><br><span class="line">					<span class="comment">//读出记录下来的位置更新下载请求数据的起始位置</span></span><br><span class="line">					startIndex = Integer.parseInt(result);</span><br><span class="line">				&#125;</span><br><span class="line">				URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">				HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br><span class="line">				connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">				connection.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">				<span class="comment">//设置Range头 用计算好的开始索引 和结束索引到服务端请求数据</span></span><br><span class="line">				connection.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span>+startIndex+<span class="string">&quot;-&quot;</span>+endIndex);</span><br><span class="line">				<span class="keyword">if</span>(connection.getResponseCode()==<span class="number">206</span>)&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;线程&quot;</span>+threadID+<span class="string">&quot;开始下载&quot;</span>+startIndex);</span><br><span class="line">					InputStream inputStream = connection.getInputStream();</span><br><span class="line">					<span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">500</span>];</span><br><span class="line">					RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(getFileName(path), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">					<span class="comment">//一定不要忘记  要seek到startIndex位置 写入数据</span></span><br><span class="line">					file.seek(startIndex);</span><br><span class="line">					<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">while</span>((len=inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">						file.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">						<span class="comment">//计算当前线程下载了多少</span></span><br><span class="line">						count+=len;</span><br><span class="line">						<span class="comment">//计算当前线程总共下载了多少</span></span><br><span class="line">						<span class="keyword">int</span> position = count+startIndex;</span><br><span class="line">						<span class="comment">//用一个文件记录这个位置</span></span><br><span class="line">						pb.setProgress(position-threadID*blockSize);</span><br><span class="line">						RandomAccessFile tempFile = <span class="keyword">new</span> RandomAccessFile(getFileName(path)+threadID+<span class="string">&quot;.log&quot;</span>, <span class="string">&quot;rwd&quot;</span>);</span><br><span class="line">						tempFile.write(String.valueOf(position).getBytes());</span><br><span class="line">					&#125;</span><br><span class="line">					file.close();</span><br><span class="line">					inputStream.close();</span><br><span class="line">					System.out.println(<span class="string">&quot;线程&quot;</span>+threadID+<span class="string">&quot;下载结束&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">						<span class="comment">//删除对应的日志文件</span></span><br><span class="line">						temp.delete();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">		String[] result = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> getCacheDir().getAbsolutePath()+<span class="string">&quot;/&quot;</span>+result[result.length-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="95、Activity正常和异常情况下的生命周期"><a href="#95、Activity正常和异常情况下的生命周期" class="headerlink" title="95、Activity正常和异常情况下的生命周期"></a>95、<a target="_blank" rel="noopener" href="http://blog.csdn.net/geekerhw/article/details/48749935">Activity正常和异常情况下的生命周期</a></h3><p>Android系统根据生命周期的不同阶段唤起对应的回调函数来执行代码。系统存在启动与销毁一个activity的一套有序的回调函数。下面就简要分析一下各个过程的回调函数。</p>
<p>(1)onCreate方法，Activity被启动时的第一个方法，表示Activity正在被创建，在这个方法中一般做一些初始化的工作，比如调用setContentView方法加载界面布局，并且可以做一些初始化数据的工作：声明UI元素，定义成员变量，配置UI等。<br>Note:onCreate尽量少做一些不必要的操作，避免Activity启动太久，使用户半天看不到Activity</p>
<p>(2)onStart方法，表示Activity正在被启动，其实这时Activity已经可见了，正如上图所表示的Visible,但并不能被用户所见，我们可以这样理解，Activity现在运行到了后台，还没有准备好到前台和用户交互。</p>
<p>(3)onResume方法，此时Activity来到前台和用户进行交互，用户真正的看到了Activity.<br>Note:往往程序在onCreate执行完成之后会迅速调用onStart方法和onResume方法。</p>
<p>(4)onPause方法,表示Activity正在停止，该状态下，activity的部分被另外一个activity所遮盖：另外的activity来到前台，但是半透明的，不会覆盖整个屏幕。被暂停的activity不再接受用户的输入且不再执行任何代码。</p>
<p>(5)onStop方法，该状态下, activity完全被隐藏，对用户不可见。可以认为是在后台。当stopped, activity实例与它的所有状态信息（如成员变量等）都会被保留，但activity不能执行任何代码。<br>Note:整个生命周期方法中，只有onResume,onPause,onStop方法是“静态”的，既可以存在较长的时间的。其它状态 (Created与Started)都是短暂的，系统快速的执行那些回调函数并通过执行下一阶段的回调函数移动到下一个状态。也就是说，在系统调用onCreate(), 之后会迅速调用onStart(), 之后再迅速执行onResume()。。</p>
<p>(6)onRestart方法，Activity从不可见又变为可见时会调用。此时调用顺序为:onRestart -&gt; onStart -&gt; onResume</p>
<p>(7)onDestroy方法:表示Activity即将被销毁，当收到需要将该activity彻底移除的信号时，系统会调用这个方法。<br>Note:大多数 app并不需要实现这个方法，因为局部类的references会随着activity的销毁而销毁，并且我们的activity应该在onPause()与onStop()中执行清除activity资源的操作。然而，如果activity含有在onCreate调用时创建的后台线程，或者是其他有可能导致内存泄漏的资源，则应该在OnDestroy()时进行资源清理，杀死后台线程。<br>Note: 除非程序在onCreate()方法里面就调用了finish()方法，系统通常是在执行了onPause()与onStop() 之后再调用onDestroy() 。在某些情况下，例如我们的activity只是做了一个临时的逻辑跳转的功能，它只是用来决定跳转到哪一个activity，这样的话，需要在onCreate里面调用finish方法，这样系统会直接调用onDestory，跳过生命周期中的其他方法。<br>Note:至于为什么当我们的activity只是做了一个临时的逻辑跳转的功能，决定跳转到哪一个activity，需要在onCreate里面调用finish方法，我的理解是，因为当从Activity a跳转到Activity b时，a的onPause方法执行过后，b的onResume方法才会执行，如果不在a的onCreate方法中finish(),启动b可能会很费时，所以我们宁可在onStop做一些操作也不要在onPause中做，并且完全没必要不finish().,并且此时注意在a的onDestroy做资源回收工作，避免造成内存泄露</p>
<p>二：异常情况下的生命周期分析<br>(1)情况一：资源相关的<strong>系统配置发生改变</strong>导致Activity被杀死并重新创建<br>当系统配置发生改变后，如从横屏手机切换到了竖屏，Activity会被销毁，其onPause(),onStop(),onDestroy()方法均会被调用，同时由于是在异常情况下被终止的，系统会调用onSavedInstanceState()来保存当前Activity的状态(正常情况下不会调用此方法)，这个方法的调用时机是在onStop()之前，当Activity重新被创建后，系统调用会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法，并且把Activity销毁时onSavedInstanceState()方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState()和onCreate()方法，onRestoreInstanceState()是在onStart()之后调用。<br>Note:我们知道，当Activity被异常终止后被恢复时，系统会自动的帮我们恢复数据和一些状态，如文本框用户输入的数据，listview的滚动位置等，关于保存和恢复View的层次结构和数据，系统的工作流程是这样的，首先Activity被意外终止时，Activity会调用onSavedInstanceState去保存数据，然后Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据，顶层容器是一个ViewGroup，一般来说它很可能是一个DecorView。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了，可以发现，这是一种典型的委托思想，上层委托下层，父容器委托子容器去处理一些事情。</p>
<p>(2)情况二：资源<strong>内存不足</strong>导致低优先级的Activity被杀死<br>Activity按照优先级我们可以分为以下的三种：<br>a.前台Activity—正在和用户交互的Activity，优先级最高。<br>b.可见但非前台Activity,如处于onPause状态的Activity，Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。<br>c.后台Activity—已经被暂停的Activity,比如执行了onStop()方法，优先级最低。<br>当系统内存不足时，系统就会按照上述的优先级顺序选择杀死Activity所在的进程，并在后续通过onSaveInstanceState()缓存数据和onRestoreInstanceState()恢复数据。<br>Note:如果一个进程中没有四大组件在执行，那么这个进程将很快被杀死，因此，一些后台工作不适合脱离了四大组件工作，比较好的方法是将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易的被系统杀死。<br>Note:系统只恢复那些被开发者指定过id的控件，如果没有为控件指定id,则系统就无法恢复了</p>
<h3 id="96、关于-lt-include-gt-lt-merge-gt-lt-ViewStub-gt-三者的使用场景"><a href="#96、关于-lt-include-gt-lt-merge-gt-lt-ViewStub-gt-三者的使用场景" class="headerlink" title="96、关于&lt; include &gt;&lt; merge &gt;&lt; ViewStub&gt;三者的使用场景"></a>96、<a target="_blank" rel="noopener" href="http://www.trinea.cn/android/layout-performance/">关于&lt; include &gt;&lt; merge &gt;&lt; ViewStub&gt;三者的使用场景</a></h3><p><strong>(1) <include>标签</strong><br>include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写方便提供了大大的便利。<br>下面以在一个布局main.xml中用include引入另一个布局foot.xml为例。main.mxl代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=&quot;@+id/simple_list_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_marginBottom=&quot;@dimen/dp_80&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/foot.xml&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>其中include引入的foot.xml为公用的页面底部，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/button&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;@dimen/dp_40&quot;</span><br><span class="line">        android:layout_above=&quot;@+id/text&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;@dimen/dp_40&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:text=&quot;@string/app_name&quot; /&gt;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><include>标签唯一需要的属性是layout属性，指定需要包含的布局文件。可以定义android:id和android:layout_*属性来覆盖被引入布局根节点的对应属性值。注意重新定义android:id后，子布局的顶结点i就变化了。</p>
<p><strong>(2) <viewstub>标签</strong><br>viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。<br>viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。<br>下面以在一个布局main.xml中加入网络错误时的提示页面network_error.xml为例。main.mxl代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span> &gt;</span><br><span class="line"> </span><br><span class="line">	……</span><br><span class="line">    &lt;ViewStub</span><br><span class="line">        android:id=<span class="string">&quot;@+id/network_error_layout&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout=<span class="string">&quot;@layout/network_error&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>



<p>其中network_error.xml为只有在网络错误时才需要显示的布局，默认不会被解析，示例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/network_setting&quot;</span><br><span class="line">        android:layout_width=&quot;@dimen/dp_160&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">        android:text=&quot;@string/network_setting&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/network_refresh&quot;</span><br><span class="line">        android:layout_width=&quot;@dimen/dp_160&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_below=&quot;@+id/network_setting&quot;</span><br><span class="line">        android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">        android:layout_marginTop=&quot;@dimen/dp_10&quot;</span><br><span class="line">        android:text=&quot;@string/network_refresh&quot; /&gt;</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在java中通过(ViewStub)findViewById(id)找到ViewStub，通过stub.inflate()展开ViewStub，然后得到子View，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> View networkErrorView;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showNetError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// not repeated infalte</span></span><br><span class="line">	<span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		networkErrorView.setVisibility(View.VISIBLE);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout);</span><br><span class="line">	networkErrorView = stub.inflate();</span><br><span class="line">	Button networkSetting = (Button)networkErrorView.findViewById(R.id.network_setting);</span><br><span class="line">	Button refresh = (Button)findViewById(R.id.network_refresh);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</span><br><span class="line">		networkErrorView.setVisibility(View.GONE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面showNetError()中展开了ViewStub，同时我们对networkErrorView进行了保存，这样下次不用继续inflate。减少不必要的infalte。</p>
<p>viewstub标签大部分属性同include标签类似。只是不用显示的转换为ViewStub。通过viewstub的原理我们可以知道将一个view设置为GONE不会被解析，从而提高layout解析速度，而VISIBLE和INVISIBLE这两个可见性属性会被正常解析。</p>
<p><strong>(3) <merge>标签</strong><br>在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢，不必要的节点和嵌套可通过hierarchy viewer(下面布局调优工具中有具体介绍)或设置-&gt;开发者选项-&gt;显示布局边界查看。</p>
<p>merge标签可用于两种典型情况：<br>a.  布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。<br>b.  某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hzp201314.github.io/2021/03/09/Android%E5%9F%BA%E7%A1%80%E7%AF%87/" data-id="ckm26cgkx0000gouf55foev1m" data-title="Android基础篇" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/10/Android%E9%AB%98%E7%BA%A7%E7%AF%87/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android高级篇
        
      </div>
    </a>
  
  
    <a href="/2021/03/09/%E5%89%8D%E7%AB%AF-CSS-%E4%B8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前端-CSS-下</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag">Android架构师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" style="font-size: 10px;">Android架构师</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/26/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96-%E9%AB%98%E7%BA%A7%E7%AF%87/">网络优化-高级篇</a>
          </li>
        
          <li>
            <a href="/2021/03/26/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96-%E5%9F%BA%E7%A1%80%E7%AF%87/">网络优化-基础篇</a>
          </li>
        
          <li>
            <a href="/2021/03/24/%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/">绘制优化</a>
          </li>
        
          <li>
            <a href="/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">卡顿优化</a>
          </li>
        
          <li>
            <a href="/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">布局优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Hzp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>