<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>布局优化 | Hzp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="前言Android的绘制优化其实可以分为两个部分，即布局(UI)优化和卡顿优化，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。">
<meta property="og:type" content="article">
<meta property="og:title" content="布局优化">
<meta property="og:url" content="https://hzp201314.github.io/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hzp&#39;s Blog">
<meta property="og:description" content="前言Android的绘制优化其实可以分为两个部分，即布局(UI)优化和卡顿优化，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-015e0543a8c1b2f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-b678a7b1b21e6293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-effffa32d38fdec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-56ede6775a736a76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-898a346811a9e3fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-78951749125c8e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-ee8ba300a8aa3ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-380aa9b7fa6cf4b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-db2fe1b07c3ac51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-e5f918d9804a35b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-f83732929d51acca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-54c562a5f0abb95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-03af1362d104987f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-2aac7dca71d07137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-314f00318d13d15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-9cb2ddca78a41b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-b7533d1c546de560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-943f826a56d2ac0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-a24122548380bbde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-3be183ec60e3f190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-1d7072ce6db170b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-1a0b8b768b3aeaa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-46387b41d8106624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-df1e2d42fed03778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-c734a954eb92ad9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-d72c223fc75a66f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-86df33c81e36ca76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-14f3cec2b9c9fd83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-06860f37097b7022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-39283a6ace31dc69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-2fcd6fd373a1bdfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-3a77bc2cb936399c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-6a20b6e21d4d6a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-a6a1cde01dbfa649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2021-03-22T03:18:36.000Z">
<meta property="article:modified_time" content="2021-03-23T08:24:49.124Z">
<meta property="article:author" content="Hzp">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/14601315-015e0543a8c1b2f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hzp's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hzp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hzp201314.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-布局优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T03:18:36.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      布局优化
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Android的绘制优化其实可以分为两个部分，即<strong>布局(UI)优化和卡顿优化</strong>，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。</p>
<span id="more"></span>

<p>由于布局优化这一主题包含的内容太多，因此，笔者将它分为了上、中、下三篇，本篇，即为深入探索Android布局优化的上篇。本篇包含的主要内容如下所示：</p>
<ul>
<li>  1、绘制原理</li>
<li>  2、屏幕适配</li>
<li>  3、优化工具</li>
</ul>
<p>说到Android的布局绘制，那么我们就不得不先从布局的绘制原理开始说起。</p>
<h1 id="一、绘制原理"><a href="#一、绘制原理" class="headerlink" title="一、绘制原理"></a>一、绘制原理</h1><p><strong>Android的绘制实现主要是借助CPU与GPU结合刷新机制共同完成的。</strong></p>
<h2 id="1、CPU与GPU"><a href="#1、CPU与GPU" class="headerlink" title="1、CPU与GPU"></a>1、CPU与GPU</h2><ul>
<li>  CPU负责计算显示内容，包括Measure、Layout、Record、Execute等操作。在UI绘制上的缺陷在于容易显示重复的视图组件，这样不仅带来重复的计算操作，而且会占用额外的GPU资源。</li>
<li>  GPU负责栅格化（<strong>用于将UI元素绘制到屏幕上，即将UI组件拆分到不同的像素上显示</strong>）。</li>
</ul>
<p>这里举两个栗子来讲解一些CPU和GPU的作用：</p>
<ul>
<li>  1、文字的显示首先经过CPU换算成纹理，然后再传给GPU进行渲染。</li>
<li>  2、而图片的显示首先是经过CPU的计算，然后加载到内存当中，最后再传给GPU进行渲染。</li>
</ul>
<p>那么，软件绘制和硬件绘制有什么区别呢？我们先看看下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-015e0543a8c1b2f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这里软件绘制使用的是<strong>Skia库</strong>（一款在低端设备如手机上呈现高质量的 2D 图形的 跨平台图形框架)进行绘制的，而硬件绘制本质上是使用的<strong>OpenGl ES</strong>接口去利用<strong>GPU</strong>进行绘制的。OpenGL是一种跨平台的图形API，它为2D/3D图形处理硬件指定了标准的软件接口。而OpenGL ES是用于嵌入式设备的，它是OpenGL规范的一种形式，也可称为其子集。</p>
<p>并且，由于OpenGl ES系统版本的限制，有很多 绘制API 都有相应的 Android API level 的限制，此外，在Android 7.0 把 OpenGL ES 升级到最新的 3.2 版本的时候，还添加了对<strong>Vulkan</strong>（一套适用于高性能 3D 图形的低开销、跨平台 API）的支持。Vulkan作为下一代图形API以及OpenGL的继承者，它的优势在于大幅优化了CPU上图形驱动相关的性能。</p>
<h2 id="2、Android-图形系统的整体架构"><a href="#2、Android-图形系统的整体架构" class="headerlink" title="2、Android 图形系统的整体架构"></a>2、Android 图形系统的整体架构</h2><p>Android官方的架构图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-b678a7b1b21e6293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>为了比较好的描述它们之间的作用，我们可以把应用程序图形渲染过程当作一次绘画过程，那么绘画过程中 Android 的各个图形组件的作用分别如下：</p>
<ul>
<li>  画笔：Skia 或者 OpenGL。我们可以用 Skia去绘制 2D 图形，也可以用 OpenGL 去绘制 2D/3D 图形。</li>
<li>  画纸：Surface。<strong>所有的元素都在 Surface 这张画纸上进行绘制和渲染</strong>。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 WindowManager 则负责管理这些窗口，并且把它们的数据传递给 SurfaceFlinger。</li>
<li>  画板：Graphic Buffer。<strong>Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双缓冲机制，而在 Android 4.1 之后使用的是三缓冲机制。</strong></li>
<li>  显示：SurfaceFlinger。它将 WindowManager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</li>
</ul>
<p>在了解完Android图形系统的整体架构之后，我们还需要了解下Android系统的显示原理，关于这块内容可以参考我之前写的<a href="">Android性能优化之绘制优化</a>的Android系统显示原理一节。</p>
<h2 id="3、RenderThread"><a href="#3、RenderThread" class="headerlink" title="3、RenderThread"></a>3、RenderThread</h2><p>在Android系统的显示过程中，虽然我们利用了GPU的图形高性能计算的能力，但是从计算Display到通过GPU绘制到Frame Buffer都在UI线程中完成，此时如果能让GPU在不同的线程中进行绘制渲染图形，那么绘制将会更加地流畅。</p>
<p>于是，在Android 5.0之后,引入了RenderNode和RenderThread的概念，它们的作用如下：</p>
<ul>
<li>  RenderNode：进一步封装了Display和某些View的属性。</li>
<li>  RenderThread：渲染线程，负责执行所有的OpenGl命令，其中的RenderNode保存有渲染帧的所有信息，能在主线程有耗时操作的前提下保证动画流畅。</li>
</ul>
<p>CPU将数据同步给GPU之后，通常不会阻塞等待RenderThread去利用GPU去渲染完视图，而是通知结束之后就返回。加入ReaderThread之后的整个显示调用流程图如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-effffa32d38fdec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在Android 6.0之后，其在<code>adb shell dumpsys gxinfo</code>命令中添加了更加详细的信息，在优化工具一节中我将详细分析下它的使用。</p>
<p>在Android 7.0之后，对HWUI进行了重构，它是用于2D硬件绘图并负责硬件加速的主要模块，其使用了OpenGl ES来进行GPU硬件绘图。此外，Android 7.0还支持了Vulkan，并且，Vulkan 1.1在Android 被引入。</p>
<h3 id="硬件加速存在哪些问题？"><a href="#硬件加速存在哪些问题？" class="headerlink" title="硬件加速存在哪些问题？"></a>硬件加速存在哪些问题？</h3><p>我们都知道，硬件加速的原理就是将CPU不擅长的图形计算转换成GPU专用指令。</p>
<ul>
<li>  1、其中的OpenGl API调用和Graphic Buffer缓冲区至少会占用几MB以上的内存，<strong>内存消耗较大</strong>。</li>
<li>  2、有些OpenGl的绘制API还没有支持，特别是比较低的Android系统版本，并且由于Android每一个版本都会对渲染模块进行一些重构，导致了在硬件加速绘制过程中会出现一些不可预知的Bug。如在<strong>Android 5.0~7.0机型上出现的libhwui.so崩溃问题</strong>，需要使用inline Hook、GOT Hook等native调试手段去进行分析定位，可能的原因是<strong>ReaderThread与UI线程的sync同步过程出现了差错，而这种情况一般都是有多个相同的视图绘制而导致的，比如View的复用、多个动画同时播放</strong>。</li>
</ul>
<h2 id="4、刷新机制"><a href="#4、刷新机制" class="headerlink" title="4、刷新机制"></a>4、刷新机制</h2><p>16ms发出VSync信号触发UI渲染，大多数的Android设备屏幕刷新频率为60HZ，如果16ms内不能完成渲染过程，则会产生掉帧现象。</p>
<h1 id="二、屏幕适配"><a href="#二、屏幕适配" class="headerlink" title="二、屏幕适配"></a>二、屏幕适配</h1><p>我们都知道，Android手机屏幕的差异化导致了严重的碎片化问题，并且屏幕材质也是用户比较关注的一个重要因素。</p>
<p>首先，我们来了解下主流Android屏幕材质，目前主要有两类：</p>
<ul>
<li>  LCD（Liquid Crystal Display）：液晶显示器。</li>
<li>  OLED（Organic Light-Emitting Diode ）:有机发光二极管。</li>
</ul>
<p>早在20世纪60年代，随着半导体集成电路的发展，美国人成功研发出了第一块液晶显示屏LCD，而现在大部分最新的高端机使用的都是OLED材质，这是因为相比于LCD屏幕，OLED屏幕在色彩、可弯曲程度、厚度和耗电等方面都有一定的优势。正因为如此，现在主流的全面屏、曲面屏与未来的柔性折叠屏，使用的几乎都是 OLED 材质。当前，好的材质，它的成本也必然会比较昂贵。</p>
<h2 id="1、OLED-屏幕和-LCD-屏幕的区别"><a href="#1、OLED-屏幕和-LCD-屏幕的区别" class="headerlink" title="1、OLED 屏幕和 LCD 屏幕的区别"></a>1、OLED 屏幕和 LCD 屏幕的区别</h2><p>如果要明白OLED 屏幕和LCD屏幕的区别，需要了解它们的运行原理，下面，我将分别进行讲解。</p>
<h3 id="屏幕的成像原理"><a href="#屏幕的成像原理" class="headerlink" title="屏幕的成像原理"></a>屏幕的成像原理</h3><p><strong>屏幕由无数个点组成，并且，每个点由红绿蓝三个子像素组成，每个像素点通过调节红绿蓝子像素的颜色配比来显示不同的颜色，最终所有的像素点就会形成具体的画面。</strong></p>
<h3 id="LCD背光源与OLED自发光"><a href="#LCD背光源与OLED自发光" class="headerlink" title="LCD背光源与OLED自发光"></a>LCD背光源与OLED自发光</h3><p>下面，我们来看下LCD和OLED的总体结构图，如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-56ede6775a736a76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>LCD的发光原理主要在于<strong>背光层Back-light</strong>，它通常都会由大量的LED背光灯组成以用于显示白光，之后，<strong>为了显示出彩色，在其上面加了一层有颜色的薄膜</strong>，白色的背光穿透了有颜色的薄膜后就可以显示出彩色了。但是，<strong>为了实现调整红绿蓝光的比例，需要在背光层和颜色薄膜之间加入一个控制阀门，即液晶层liquid crystal，它可以通过改变电压的大小来控制开合的程度，开合大则光多，开合小则光少</strong>。</p>
<p>对于OLED来说，它不需要LCD屏幕的背光层和用于控制出光量的液晶层，它就像一个有着无数个小的彩色灯泡组成的屏幕，只需要给它通电就能发光。</p>
<h3 id="LCD的致命缺陷"><a href="#LCD的致命缺陷" class="headerlink" title="LCD的致命缺陷"></a>LCD的致命缺陷</h3><p>它的液晶层不能完全关合，如果LCD显示黑色，会有部分光穿过颜色层，所以LCD的黑色实际上是白色和黑色混合而成的灰色。而OLED不一样，OLED显示黑色的时候可以直接关闭区域的像素点。</p>
<p>此外，由于背光层的存在，所以LCD显示器的背光非常容易从屏幕与边框之间的缝隙泄漏出去，即会产生显示器漏光现象。</p>
<h3 id="OLED屏幕的优势"><a href="#OLED屏幕的优势" class="headerlink" title="OLED屏幕的优势"></a>OLED屏幕的优势</h3><ul>
<li>  1、由于没有有背光层和液晶层的存在，所以它的**厚度更薄，其弯曲程度可以达到180%**。</li>
<li>  2、对比度（白色比黑色的比值）更高，使其画面颜色越浓；相较于LCD来说，<strong>OLED是油画，色彩纯而细腻，而LCD是水彩笔画，色彩朦胧且淡</strong>。</li>
<li>  3、OLED每个像素点都是独立的，所以OLED可以单独点亮某些像素点，即能实现<strong>单独点亮</strong>。而LCD只能控制整个背光层的开关。并且，由于OLED单独点亮的功能，使其<strong>耗电程度大大降低</strong>。</li>
<li>  4、OLED的<strong>屏幕响应时间很快</strong>，不会造成画面残留以致造成视觉上的拖影现象。而LCD则会有严重的拖影现象。</li>
</ul>
<h3 id="OLED屏幕的劣势"><a href="#OLED屏幕的劣势" class="headerlink" title="OLED屏幕的劣势"></a>OLED屏幕的劣势</h3><ul>
<li>  1、由于OLED是<strong>有机材料</strong>，导致其寿命是不如LCD的 有机材料的。并且，由于OLED单独点亮的功能，会使每个像素点工作的时间不一样，这样，在屏幕老化时就会导致色彩显示不均匀，即产生<strong>烧屏</strong>现象。</li>
<li>  2、由于OLED就不能采取控制电压的方式去调整亮度，所以目前只能通过不断的开关开关开关去进行调光。</li>
<li>  3、OLED的屏幕像素点排列方式不如LCD的紧凑，所以在分辨率相同的情况下，OLED的屏幕是不如LCD清楚的。即OLED的<strong>像素密度较低</strong>。</li>
</ul>
<h2 id="2、屏幕适配方案"><a href="#2、屏幕适配方案" class="headerlink" title="2、屏幕适配方案"></a>2、屏幕适配方案</h2><p>我们都知道，Android 的 系统碎片化、机型以及屏幕尺寸碎片化、屏幕分辨率碎片化非常地严重。所以，一个好的屏幕适配方案是很重要的。接下来，我将介绍目前主流的屏幕适配方案。</p>
<h3 id="1、最原始的Android适配方案：dp-自适应布局或weight比例布局"><a href="#1、最原始的Android适配方案：dp-自适应布局或weight比例布局" class="headerlink" title="1、最原始的Android适配方案：dp + 自适应布局或weight比例布局"></a>1、最原始的Android适配方案：dp + 自适应布局或weight比例布局</h3><p>首先，我们来回顾一下px、dp、dpi、ppi、density等概念：</p>
<ul>
<li>  px：像素点，px = density * dp。</li>
<li>  ppi：像素密度，每英寸所包含的像素数目，屏幕物理参数，不可调整，dpi没有人为调整时 = ppi。</li>
<li>  dpi：像素密度，在系统软件上指定的单位尺寸的像素数量，可人为调整，dpi没有人为调整时 = ppi。</li>
<li>  dp：density-independent pixels，即密度无关像素，基于屏幕物理分辨率的一个抽象的单位，以dp为尺寸单位的控件，在不同分辨率和尺寸的手机上代表了不同的真实像素，比如在分辨率较低的手机中，可能1dp = 1px,而在分辨率较高的手机中，可能1dp=2px，这样的话，一个64 * 64dp的控件，在不同的手机中就能表现出差不多的大小了，px = dp * (dpi /160)。</li>
<li>  density：密度，屏幕上每平方英寸所包含的像素点个数，density = dpi / 160。</li>
</ul>
<p>通常情况下，我们只需要使用dp + 自适应布局（如鸿神的AutoLayout、ConstraintLayout等等）或weight比例布局即可基本解决碎片化问题，当然，这种方式也存在一些问题，比如<strong>dpi和ppi的差异所导致在同一分辨率手机上控件大小的不同</strong>。</p>
<h3 id="2、宽高限定符适配方案"><a href="#2、宽高限定符适配方案" class="headerlink" title="2、宽高限定符适配方案"></a>2、宽高限定符适配方案</h3><p>它就是穷举市面上所有的Android手机的宽高像素值，通过设立一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-898a346811a9e3fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>比如以480x320为基准分辨率：</p>
<ul>
<li>  宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320。</li>
<li>  高度为480，将任何分辨率的高度整分为480份，取值为y1-y480。</li>
</ul>
<p>那么对于800*480的分辨率的dimens文件来说：</p>
<ul>
<li>  x1=(480/320)*1=1.5px</li>
<li>  x2=(480/320)*2=3px</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-78951749125c8e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>此时，如果UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens去引用，而当APP运行在不同分辨率的手机中时，系统会根据这些dimens去引用该分辨率对应的文件夹下面去寻找对应的值。但是这个方案由一个缺点，就是无法做到向下兼容去使用更小的dimens，比如说800x480的手机就一定要找到800x480的限定符，否则就只能用统一默认的dimens文件了。</p>
<h3 id="3、UI适配框架AndroidAutoLayout的适配方案"><a href="#3、UI适配框架AndroidAutoLayout的适配方案" class="headerlink" title="3、UI适配框架AndroidAutoLayout的适配方案"></a>3、UI适配框架AndroidAutoLayout的适配方案</h3><p>因宽高限定符方案的启发，鸿神出品了一款能使用UI适配更加开发高效和适配精准的项目。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hongyangAndroid/AndroidAutoLayout">项目地址</a></p>
<p>基本使用步骤如下：</p>
<p>第一步：在你的项目的AndroidManifest中注明你的设计稿的尺寸：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;design_width&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;768&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;design_height&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;1280&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：让你的Activity继承自AutoLayoutActivity。如果你不希望继承AutoLayoutActivity，可以在编写布局文件时，直接使用AutoLinearLayout、Auto***等适配布局即可。</p>
<p>接下来，直接在布局文件里面使用具体的像素值就可以了，因为在APP运行时，AndroidAutoLayout会帮助我们根据不同手机的具体尺寸按比例伸缩。</p>
<p>AndroidAutoLayout在宽高限定符适配的基础上，解决了其dimens不能向下兼容的问题，但是它在运行时会在onMeasure里面对dimens去做变换，所以对于自定义控件或者某些特定的控件需要进行单独适配；并且，整个UI的适配过程都是由框架完成的，以后想替换成别的UI适配方案成本会比较高，而且，不幸的是，项目已经停止维护了。</p>
<h3 id="4、smallestWidth适配方案（sw限定符适配）"><a href="#4、smallestWidth适配方案（sw限定符适配）" class="headerlink" title="4、smallestWidth适配方案（sw限定符适配）"></a>4、smallestWidth适配方案（sw限定符适配）</h3><p>smallestWidth即最小宽度，系统会根据当前设备屏幕的 最小宽度 来匹配 values-swdp。</p>
<p>我们都知道，移动设备都是允许屏幕可以旋转的，当屏幕旋转时，屏幕的高宽就会互换，加上 最小 这两个字，是因为这个方案是不区分屏幕方向的，它只会把屏幕的高度和宽度中值最小的一方认为是 最小宽度。</p>
<p>并且它跟宽高限定符适配原理上是一样，都是系统通过特定的规则来选择对应的文件。<strong>它与AndroidAutoLayout一样，同样解决了其dimens不能向下兼容的问题，如果该屏幕的最小宽度是360dp，但是项目中没有values-sw360dp文件夹的话，它就可能找到values-sw320dp这个文件夹</strong>，其尺寸规则命名如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-ee8ba300a8aa3ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>假如加入我们的设计稿的像素宽度是375，那么其对应的values-sw360dp和values-sw400dp宽度如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/14601315-380aa9b7fa6cf4b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-db2fe1b07c3ac51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。虽然多个dimens文件可能导致apk变大，但是其增加大小范围也只是在300kb-800kb这个区间，这还是可以接受的。这套方案唯一的变数就是选择需要适配哪些最小宽度限定符的文件，如果您生成的 values-swdp 与设备实际的 最小宽度 差别不大，那误差也就在能接受的范围内，如果差别很大，那效果就会很差。最后，总结一下这套方案的优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>  1、稳定且无性能损耗。</li>
<li>  2、可通过选择需要哪些最小宽度限定符文件去控制适配范围。</li>
<li>  3、在自动生成values-sw的插件基础下，学习成本较低。</li>
</ul>
<p>插件地址为<a target="_blank" rel="noopener" href="https://github.com/ladingwu/dimens_sw">自动生成values-sw的项目代码</a>。生成需要的values-swdp文件夹的步骤如下：</p>
<ul>
<li>  1、clone该项目到本地,以Android项目打开。</li>
<li>  2、DimenTypes文件中写入你希望适配的sw尺寸，默认的这些尺寸能够覆盖几乎所有手机适配需求。</li>
<li>  3、DimenGenerator文件中填写设计稿的尺寸(DESIGN_WIDTH是设计稿宽度，DESIGN_HEIGHT是设计稿高度)。</li>
<li>  4、执行lib module中的DimenGenerator.main()方法，当前地址下会生成相应的适配文件,把相应的文件连带文件夹拷贝到正在开发的项目中。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>  1、侵入性高，后续切换其他屏幕适配方案需修改大量 dimens 引用。</li>
<li>  2、覆盖更多不同屏幕的机型需要生成更多的资源文件，使APK体积变大。</li>
<li>  3、不能自动支持横竖屏切换时的适配，如要支持需使用 values-wdp 或 屏幕方向限定符 再生成一套资源文件，又使APK体积变大。</li>
</ul>
<p><strong>如果想让屏幕宽度随着屏幕的旋转而做出改变该怎么办呢？</strong></p>
<p>此时根据 values-wdp (去掉 sw 中的 s) 去生成一套资源文件即可。</p>
<p><strong>如果想区分屏幕的方向来做适配该怎么办呢？</strong></p>
<p>去根据 屏幕方向限定符 生成一套资源文件，后缀加上 -land 或 -port 即可，如：values-sw360dp-land (最小宽度 360 dp 横向)，values-sw400dp-port (最小宽度 720 dp 纵向)。</p>
<p><strong>注意：</strong></p>
<p>如果UI设计上明显更适合使用wrap_content,match_parent,layout_weight等,我们就要毫不犹豫的使用，毕竟，上述都是仅仅针对不得不使用固定宽高的情况，我相信基础的UI适配知识大部分开发者还是具备的。如果不具备的话，请看下方：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-e5f918d9804a35b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="5、今日头条适配方案"><a href="#5、今日头条适配方案" class="headerlink" title="5、今日头条适配方案"></a>5、今日头条适配方案</h3><p>它的原理是<strong>根据屏幕的宽度或高度动态调整每个设备的 density (每 dp 占当前设备屏幕多少像素)，通过修改density值的方式，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就可以解决所有的适配问题</strong>。其对应的重要公式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">density = 当前设备屏幕总宽度（单位为像素）/  设计图总宽度（单位为 dp)</span><br></pre></td></tr></table></figure>

<p><strong>今日头条适配方案默认项目中只能以高或宽中的一个作为基准来进行适配，并不像 AndroidAutoLayout 一样，高以高为基准，宽以宽为基准，来同时进行适配，为什么？</strong></p>
<p>因为，现在中国大部分市面上的 Android 设备的屏幕高宽比都不一致，特别是现在的全面屏、刘海屏、弹性折叠屏，使这个问题更加严重，不同厂商推出的手机的屏幕高宽比都可能不一致。所以，我们只能以高或宽其中的一个作为基准进行适配，以此避免布局在高宽比不一致的屏幕上出现变形。</p>
<p>它有以下优势：</p>
<ul>
<li>  1、使用成本低，操作简单，使用该方案后在页面布局时不需要额外的代码和操作。</li>
<li>  2、侵入性低，和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，试错成本接近于 0。</li>
<li>  3、可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益。</li>
<li>  4、不会有任何性能的损耗。</li>
<li>  5、不涉及私有API。</li>
</ul>
<p>它的缺点如下所示：</p>
<ul>
<li>  1、适配范围不可控，只能一刀切的将整个项目进行适配，这种将所有控件都强行使用我们项目自身的设计图尺寸进行适配的方案会有问题：当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距越大时，该系统控件或三方库控件的适配效果就越差。比较好的解决方案就是按 Activity 为单位，取消当前 Activity 的适配效果，改用其他的适配方案。</li>
<li>  2、对旧项目的UI适配兼容性不够。</li>
</ul>
<p><strong>注意：</strong></p>
<p>千万不要在此方案上使用smallestWidth适配方案中直接填写设计图上标注的 px 值的做法，这样会使项目强耦合于这个方案，后续切换其它方案都不得不将所有的 layout 文件都改一遍。</p>
<p>这里推荐一下JessYanCoding的<a target="_blank" rel="noopener" href="https://github.com/JessYanCoding/AndroidAutoSize">AndroidAutoSize</a>项目，用法如下：</p>
<p>1、首先在项目的build.gradle中添加该库的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;me.jessyan:autosize:1.1.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、接着 AndroidManifest 中填写全局设计图尺寸 (单位 dp)，如果使用副单位，则可以直接填写像素尺寸，不需要再将像素转化为 dp：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span>            </span><br><span class="line">        &lt;meta-data</span><br><span class="line">            android:name=&quot;design_width_in_dp&quot;</span><br><span class="line">            android:value=&quot;360&quot;/&gt;</span><br><span class="line">        &lt;meta-data</span><br><span class="line">            android:name=&quot;design_height_in_dp&quot;</span><br><span class="line">            android:value=&quot;640&quot;/&gt;           </span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span>           </span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么只需在AndroidManifest.xml 中填写一下 meta-data 标签就可实现自动运行？</strong></p>
<p>在 App 启动时，系统会在 App 的主进程中自动实例化声明的 ContentProvider，并调用它的 onCreate 方法，<strong>执行时机比 Application#onCreate 还靠前，可以做一些初始化的工作，这个时候我们就可以利用它的 onCreate 方法在其中启动框架</strong>。如果项目使用了多进程，调用Application#onCreate 中调用下 ContentProvider#query 就能够使用 ContentProvider 在当前进程中进行实例化。</p>
<h3 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h3><p>上述介绍的所有方案并没有哪一个是十分完美的，但我们能清晰的认识到不同方案的优缺点，并将它们的优点相结合，这样才能应付更加复杂的开发需求，创造出最卓越的产品。比如<strong>SmallestWidth 限定符适配方案 主打的是稳定性，在运行过程中极少会出现安全隐患，适配范围也可控，不会产生其他未知的影响，而 今日头条适配方案 主打的是降低开发成本、提高开发效率，使用上更灵活，也能满足更多的扩展需求</strong>。所以，具体情况具体分析，到底选择哪一个屏幕适配方案还是需要去根据我们项目自身的需求去选择。</p>
<h1 id="三、优化工具"><a href="#三、优化工具" class="headerlink" title="三、优化工具"></a>三、优化工具</h1><h2 id="1、Systrace"><a href="#1、Systrace" class="headerlink" title="1、Systrace"></a>1、Systrace</h2><p>早在<a href="">深入探索Android启动速度优化</a>一文中我们就了解过Systrace的使用、原理及它作为启动速度分析的用法。而它其实主要是用来分析绘制性能方面的问题。下面我就详细介绍下Systrace作为绘制优化工具有哪些必须关注的点。</p>
<h3 id="1）、关注Frames"><a href="#1）、关注Frames" class="headerlink" title="1）、关注Frames"></a>1）、关注Frames</h3><p>首先，先在左边栏选中我们当前的应用进程，在应用进程一栏下面有一栏Frames，我们可以看到<strong>有绿、黄、红三种不同的小圆圈</strong>，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-f83732929d51acca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>图中每一个小圆圈代表着当前帧的状态，大致的对应关系如下：</p>
<ul>
<li>  正常：绿色。</li>
<li>  丢帧：黄色。</li>
<li>  严重丢帧：红色。</li>
</ul>
<p>并且，<strong>选中其中某一帧</strong>，我们还可以在视图最下方的详情框看到<strong>该帧对应的相关的Alerts报警信息</strong>，以帮助我们去排查问题；此外，如果是大于等于Android 5.0的设备（即API Level21），创建帧的工作工作分为UI线程和render线程。而在Android 5.0之前的版本中，创建帧的所有工作都是在UI线程上完成的。接下来，我们看看该帧对应的详情图，如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-54c562a5f0abb95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>对应到此帧，我们发现这里可能有两个绘制问题：Bitmap过大、布局嵌套层级过多导致的measure和layout次数过多，这就需要我们去在项目中找到该帧对应的Bitmap进行相应的优化，针对布局嵌套层级过多的问题去选择更高效的布局方式，这块后面我们会详细介绍。</p>
<h3 id="2）、关注Alerts栏"><a href="#2）、关注Alerts栏" class="headerlink" title="2）、关注Alerts栏"></a>2）、关注Alerts栏</h3><p>此外，Systrace的显示界面还在在右边侧栏提供了一栏Alert框去显示出它所检测出所有可能有绘制性能问题的地方及对应的数量，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-03af1362d104987f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在这里，我们可以<strong>将Alert框看做是一个是待修复的Bug列表</strong>，通常一个区域的改进可以消除应用程序中的所有类中该类型的警报，所以，不要为这里的警报数量所担忧。</p>
<h2 id="2、Layout-Inspector"><a href="#2、Layout-Inspector" class="headerlink" title="2、Layout Inspector"></a>2、Layout Inspector</h2><p>Layout Inspector是AndroidStudio自带的工具，它的主要作用就是用来查看视图层级结构的。</p>
<p>具体的操作路径为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击Tools工具栏 -&gt;第三栏的Layout Inspector -&gt; 选中当前的进程</span><br></pre></td></tr></table></figure>

<p>下面为操作之后打开的<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a>首页图，如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-2aac7dca71d07137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>其中，<strong>最左侧的View Tree就是用来查看视图的层级结构的</strong>，非常方便，这是它最主要的功能，中间的是一个屏幕截图，最右边的是一个属性表格，比如我在截图中选中某一个TextView（Kotlin/入门及知识点一栏），在属性表格的text中就可以显示相关的信息，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-314f00318d13d15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="3、Choreographer"><a href="#3、Choreographer" class="headerlink" title="3、Choreographer"></a>3、Choreographer</h2><p>Choreographer是用来获取FPS的，并且可以用于线上使用，具备实时性，但是仅能在Api 16之后使用，具体的调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback();</span><br></pre></td></tr></table></figure>

<p>使用Choreographer获取FPS的完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mStartFrameTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mFrameCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单次计算FPS使用160毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_INTERVAL = <span class="number">160L</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONITOR_INTERVAL_NANOS = MONITOR_INTERVAL * <span class="number">1000L</span> * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置计算fps的单位时间间隔1000ms,即fps/s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_INTERVAL = <span class="number">1000L</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.JELLY_BEAN)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFPS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mStartFrameTime == <span class="number">0</span>) &#123;</span><br><span class="line">                mStartFrameTime = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> interval = frameTimeNanos - mStartFrameTime;</span><br><span class="line">            <span class="keyword">if</span> (interval &gt; MONITOR_INTERVAL_NANOS) &#123;</span><br><span class="line">                <span class="keyword">double</span> fps = (((<span class="keyword">double</span>) (mFrameCount * <span class="number">1000L</span> * <span class="number">1000L</span>)) / interval) * MAX_INTERVAL;</span><br><span class="line">                <span class="comment">// log输出fps</span></span><br><span class="line">                LogUtils.i(<span class="string">&quot;当前实时fps值为： &quot;</span> + fps);</span><br><span class="line">                mFrameCount = <span class="number">0</span>;</span><br><span class="line">                mStartFrameTime = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++mFrameCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上方式我们就可以实现实时获取应用的界面的FPS了。但是我们需要排除掉页面没有操作的情况，即只在界面存在绘制的时候才做统计。我们可以通过 addOnDrawListener 去监听界面是否存在绘制行为，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().getViewTreeObserver().addOnDrawListener</span><br></pre></td></tr></table></figure>

<p>当出现丢帧的时候，我们可以获取应用当前的页面信息、View 信息和操作路径上报至 APM后台，以降低二次排查的难度。此外，我们将连续丢帧超过 700 毫秒定义为冻帧，也就是连续丢帧 42 帧以上。这时用户会感受到比较明显的卡顿现象，因此，我们可以统计更有价值的冻帧率。冻帧率就是计算发生冻帧时间在所有时间的占比。通过解决应用中发生冻帧的地方我们就可以大大提升应用的流畅度。</p>
<h2 id="4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）"><a href="#4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）" class="headerlink" title="4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）"></a>4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）</h2><p>Tracer for OpenGL ES 是 Android 4.1 新增加的工具，它可逐帧、逐函数的记录 App 使用 OpenGL ES 的绘制过程，并且，它可以记录每个 OpenGL 函数调用的消耗时间。当使用Systrace还找不到渲染问题时，就可以去尝试使用它。</p>
<p>而GAPID是 Android Studio 3.1 推出的工具，可以认为是Tracer for OpenGL ES的进化版，它不仅实现了跨平台，而且支持Vulkan与回放。由于它们主要是用于OpenGL相关开发的使用，这里我就不多介绍了。</p>
<h2 id="5、自动化测量-UI-渲染性能的方式"><a href="#5、自动化测量-UI-渲染性能的方式" class="headerlink" title="5、自动化测量 UI 渲染性能的方式"></a>5、自动化测量 UI 渲染性能的方式</h2><p><strong>在自动化测试中，我们通常希望通过执行性能测试的自动化脚本来进行线下的自动化检测，那么，有哪些命令可以用于测量UI渲染的性能呢？</strong></p>
<p>我们都知道，<strong>dumpsys是一款输出有关系统服务状态信息的Android工具</strong>，利用它我们可以获取当前设备的UI渲染性能信息，目前常用的有如下两种命令：</p>
<h3 id="1）、gfxinfo"><a href="#1）、gfxinfo" class="headerlink" title="1）、gfxinfo"></a>1）、gfxinfo</h3><p>gfxinfo的主要作用是<strong>输出各阶段发生的动画与帧相关的信息</strong>，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PackageName&gt;</span><br></pre></td></tr></table></figure>

<p>这里我以<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a>项目为例，输出其对应的gfxinfo信息如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroid</span><br><span class="line">Applications Graphics Acceleration Info:</span><br><span class="line">Uptime: 549887348 Realtime: 549887348</span><br><span class="line"></span><br><span class="line">** Graphics info for pid 1722     [json.chao.com.wanandroid] **</span><br><span class="line"></span><br><span class="line">Stats since: 549356564232951ns</span><br><span class="line">Total frames rendered: 5210</span><br><span class="line">Janky frames: 193 (3.70%)</span><br><span class="line">50th percentile: 5ms</span><br><span class="line">90th percentile: 9ms</span><br><span class="line">95th percentile: 13ms</span><br><span class="line">99th percentile: 34ms</span><br><span class="line">Number Missed Vsync: 31</span><br><span class="line">Number High input latency: 0</span><br><span class="line">Number Slow UI thread: 153</span><br><span class="line">Number Slow bitmap uploads: 6</span><br><span class="line">Number Slow issue draw commands: 51</span><br><span class="line">HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87 9ms=80 10ms=83 11ms=108 12ms=57 13ms=29 14ms=17 15ms=17 16ms=14 17ms=20 18ms=15 19ms=15 20ms=17 21ms=9 22ms=14 23ms=8 24ms=9 25ms=4 26ms=5 27ms=4 28ms=4 29ms=1 30ms=2 31ms=4 32ms=3 34ms=6 36ms=5 38ms=7 40ms=8 42ms=0 44ms=3 46ms=3 48ms=5 53ms=2 57ms=0 61ms=3 65ms=0 69ms=1 73ms=1 77ms=0 81ms=0 85ms=0 89ms=1 93ms=1 97ms=0 101ms=0 105ms=0 109ms=0 113ms=1 117ms=0 121ms=0 125ms=0 129ms=0 133ms=0 150ms=2 200ms=0 250ms=2 300ms=1 350ms=1 400ms=0 450ms=1 500ms=0 550ms=1 600ms=0 650ms=0 700ms=0 750ms=0 800ms=0 850ms=0 900ms=0 950ms=0 1000ms=0 1050ms=0 1100ms=0 1150ms=0 1200ms=0 1250ms=0 1300ms=0 1350ms=0 1400ms=0 1450ms=0 1500ms=0 1550ms=0 1600ms=0 1650ms=0 1700ms=0 1750ms=0 1800ms=0 1850ms=0 1900ms=0 1950ms=0 2000ms=0 2050ms=0 2100ms=0 2150ms=0 2200ms=0 2250ms=0 2300ms=0 2350ms=0 2400ms=0 2450ms=0 2500ms=0 2550ms=0 2600ms=0 2650ms=0 2700ms=0 2750ms=0 2800ms=0 2850ms=0 2900ms=0 2950ms=0 3000ms=0 3050ms=0 3100ms=0 3150ms=0 3200ms=0 3250ms=0 3300ms=0 3350ms=0 3400ms=0 3450ms=0 3500ms=0 3550ms=0 3600ms=0 3650ms=0 3700ms=0 3750ms=0 3800ms=0 3850ms=0 3900ms=0 3950ms=0 4000ms=0 4050ms=0 4100ms=0 4150ms=0 4200ms=0 4250ms=0 4300ms=0 4350ms=0 4400ms=0 4450ms=0 4500ms=0 4550ms=0 4600ms=0 4650ms=0 4700ms=0 4750ms=0 4800ms=0 4850ms=0 4900ms=0 4950ms=0</span><br><span class="line">Caches:</span><br><span class="line">Current memory usage / total memory usage (bytes):</span><br><span class="line">TextureCache          5087048 / 59097600</span><br><span class="line">Layers total          0 (numLayers = 0)</span><br><span class="line">RenderBufferCache           0 /  4924800</span><br><span class="line">GradientCache           20480 /  1048576</span><br><span class="line">PathCache                   0 /  9849600</span><br><span class="line">TessellationCache           0 /  1048576</span><br><span class="line">TextDropShadowCache         0 /  4924800</span><br><span class="line">PatchCache                  0 /   131072</span><br><span class="line">FontRenderer A8        184219 /  1478656</span><br><span class="line">    A8   texture 0       184219 /  1478656</span><br><span class="line">FontRenderer RGBA           0 /        0</span><br><span class="line">FontRenderer total     184219 /  1478656</span><br><span class="line">Other:</span><br><span class="line">FboCache                    0 /        0</span><br><span class="line">Total memory usage:</span><br><span class="line">6586184 bytes, 6.28 MB</span><br><span class="line"></span><br><span class="line">Pipeline=FrameBuilder</span><br><span class="line">Profile data in ms:</span><br><span class="line"></span><br><span class="line">    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e (visibility=8)</span><br><span class="line">    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf (visibility=8)</span><br><span class="line">View hierarchy:</span><br><span class="line"></span><br><span class="line">json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e</span><br><span class="line">151 views, 154.02 kB of display lists</span><br><span class="line"></span><br><span class="line">json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf</span><br><span class="line">19 views, 18.70 kB of display lists</span><br><span class="line"></span><br><span class="line">Total ViewRootImpl: 2</span><br><span class="line">Total Views:        170</span><br><span class="line">Total DisplayList:  172.73 kB</span><br></pre></td></tr></table></figure>

<p>下面，我将对其中的关键信息进行分析。</p>
<p><strong>帧的聚合分析数据</strong></p>
<p>开始的一栏是统计的当前界面所有帧的聚合分析数据，主要作用是<strong>综合查看App的渲染性能以及帧的稳定性。</strong></p>
<ul>
<li>  Graphics info for pid 1722 [json.chao.com.wanandroid] -&gt; 说明了当前提供的是Awesome-WanAndroid应用界面的帧信息，对应的进程id为1722。</li>
<li>  Total frames rendered 5210 -&gt; 本次dump的数据搜集了5210帧的信息。</li>
<li>  Janky frames: 193 (3.70%) -&gt; 5210帧中有193帧发生了Jank，即单帧耗时时间超过了16ms，卡顿的概率为3.70%。</li>
<li>  50th percentile: 5ms -&gt; 所有帧耗时排序后，其中前50%最大的耗时帧的耗时为5ms。</li>
<li>  90th percentile: 9ms -&gt; 同上，依次类推。</li>
<li>  95th percentile: 13ms -&gt; 同上，依次类推。</li>
<li>  99th percentile: 34ms -&gt; 同上，依次类推。</li>
<li>  Number Missed Vsync: 31 -&gt; 垂直同步失败的帧数为31。</li>
<li>  Number High input latency: 0 -&gt; 处理input耗时的帧数为0。</li>
<li>  Number Slow UI thread: 153 -&gt; 因UI线程的工作而导致耗时的帧数为153。</li>
<li>  Number Slow bitmap uploads: 6 -&gt; 因bitmap加载导致耗时的帧数为6。</li>
<li>  Number Slow issue draw commands: 51 -&gt; 因绘制问题导致耗时的帧数为51。</li>
<li>  HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87… -&gt; 直方图数据列表，说明了耗时0<del>5ms的帧数为4254，耗时5</del>6ms的帧数为131，后续的数据依次类推即可。</li>
</ul>
<p>后续的log数据表明了不同组件的缓存占用信息，帧的建立路径信息以及总览信息等等，参考意义不大。</p>
<p>可以看到，上述的数据只能让我们总体感受到绘制性能的好坏，并不能去定位具体帧的问题，那么，还有更好的方式去获取具体帧的信息吗？</p>
<p><strong>添加framestats去获取最后120帧的详细信息</strong></p>
<p>该命令的格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PackageName&gt; framestats</span><br></pre></td></tr></table></figure>

<p>这里还是以Awesome-WanAndroid项目为例，输出项目标签页的帧详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroid framestats</span><br><span class="line">Applications Graphics Acceleration Info:</span><br><span class="line">Uptime: 603118462 Realtime: 603118462</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Window: json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity</span><br><span class="line">Stats since: 603011709157414ns</span><br><span class="line">Total frames rendered: 3295</span><br><span class="line">Janky frames: 117 (3.55%)</span><br><span class="line">50th percentile: 5ms</span><br><span class="line">90th percentile: 9ms</span><br><span class="line">95th percentile: 14ms</span><br><span class="line">99th percentile: 32ms</span><br><span class="line">Number Missed Vsync: 17</span><br><span class="line">Number High input latency: 3</span><br><span class="line">Number Slow UI thread: 97</span><br><span class="line">Number Slow bitmap uploads: 13</span><br><span class="line">Number Slow issue draw commands: 20</span><br><span class="line">HISTOGRAM: 5ms=2710 6ms=75 7ms=81 8ms=70...</span><br><span class="line"></span><br><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">0,603111579233508,603111579233508,9223372036854775807,0,603111580203105,603111580207688,603111580417688,603111580651698,603111580981282,603111581033157,603111581263417,603111583942011,603111584638678,1590000,259000,</span><br><span class="line">0,603111595904553,603111595904553,9223372036854775807,0,603111596650344,603111596692428,603111596828678,603111597073261,603111597301386,603111597362376,603111597600292,603111600584667,603111601288261,1838000,278000,</span><br><span class="line">...,</span><br><span class="line">---PROFILEDATA---</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我们只需关注其中的PROFILEDATA一栏，因为它表明了最近120帧每个帧的状态信息。</p>
<p>因为其中的数据是以csv格式显示的，我们将PROFILEDATA中的数据全部拷贝过来，然后放入一个txt文件中，接着，把.txt后缀改为.csv，使用WPS表格工具打开，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-9cb2ddca78a41b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>从上图中，我们看到输出的第一行是对应的输出数据列的格式，下面我将详细进行分析。</p>
<p><strong>Flags:</strong></p>
<ul>
<li>  Flags为0则可计算得出该帧耗时：FrameCompleted - IntendedVsync。</li>
<li>  Flags为非0则表示绘制时间超过16ms，为异常帧。</li>
</ul>
<p><strong>IntendedVsync：</strong></p>
<ul>
<li>  帧的预期Vsync时刻，如果预期的Vsync时刻与现实的Vsync时刻不一致，则表明UI线程中有耗时工作导致其无法响应Vsync信号。</li>
</ul>
<p><strong>Vsync：</strong></p>
<ul>
<li>  花费在Vsync监听器和帧绘制的时间，比如Choreographer frame回调、动画、View.getDrawingTime等待。</li>
<li>  理解Vsync：Vsync避免了在屏幕刷新时，把数据从后台缓冲区复制到帧缓冲区所消耗的时间。</li>
</ul>
<p><strong>OldestInputEvent：</strong></p>
<ul>
<li>  输入队列中最旧输入事件的时间戳，如果没有输入事件，则此列数据都为Long.MAX_VALUE。</li>
<li>  通常用于framework层开发。</li>
</ul>
<p><strong>NewestInputEvent：</strong></p>
<ul>
<li>  输入队列中最新输入时间的时间戳，如果没有输入事件，则此列数据都为0。</li>
<li>  计算App大致的延迟添加时间：FrameCompleted - NewestInputEvent。</li>
<li>  通常用于framework层开发。</li>
</ul>
<p><strong>HandleInputStart：</strong></p>
<ul>
<li>  将输入事件分发给App对应的时间戳时刻。</li>
<li>  用于测量App处理输入事件的时间：AnimationStart - HandleInputStart。当值大于2ms时，说明程序花费了很长的时间来处理输入事件，比如View.onTouchEvent等事件。注意在Activity切换或产生点击事件时此值一般都比较大，此时是可以接受的。</li>
</ul>
<p><strong>AnimationStart：</strong></p>
<ul>
<li>  运行Choreographer（舞蹈编排者）注册动画的时间戳。</li>
<li>  用来评估所有运行的所有动画器（ObjectAnimator、ViewPropertyAnimator、常用转换器）需要多长时间：AnimationStart - PerformTraversalsStart。当值大于2ms时，请查看此时是否执行的是自定义动画且动画是否有耗时操作。</li>
</ul>
<p><strong>PerformTraversalsStart：</strong></p>
<ul>
<li>  执行布局递归遍历开始的时间戳。</li>
<li>  用于获取measure、layout的时间：DrawStart - PerformTraversalsStart。（注意滚动或动画期间此值应接近于0）。</li>
</ul>
<p><strong>DrawStart：</strong></p>
<ul>
<li>  draw阶段开始的时间戳，它记录了任何无效视图的DisplayList的起点。</li>
<li>  用于获取视图数中所有无效视图调用View.draw方法所需的时间：SyncStart - DrawStart。</li>
<li>  在此过程中，硬件加速模块中的DisplayList发挥了重要作用，Android系统仍然使用invalidate()调用draw()方法请求屏幕更新和渲染视图，但是对实际图形的处理方式有所不同。<strong>Android系统并没有立即执行绘图命令，而是将它们记录在DisplayList中，该列表包含视图层次结构绘图所需的所有信息。相对于软件渲染的另一个优化是，Android系统仅需要记录和更新DispalyList，以显示被invalidate() 标记为dirty的视图。只需重新发布先前记录的Displaylist，即可重新绘制尚未失效的视图</strong>。此时的硬件绘制模型主要包括三个过程：<strong>刷新视图层级、记录和更新DisplayList、绘制DisplayList</strong>。相对于软件绘制模型的刷新视图层级、然后直接去绘制视图层级的两个步骤，虽然多了一个步骤，但是节省了很多不必要的绘制开销。</li>
</ul>
<p><strong>SyncQueued：</strong></p>
<ul>
<li>  sync请求发送到RenderThread线程的时间戳。</li>
<li>  获取sync就绪所花费的时间：SyncStart - SyncQueued。如果值大于0.1ms，则说明RenderThread正在忙于处理不同的帧。</li>
</ul>
<p><strong>SyncStart：</strong></p>
<ul>
<li>  绘图的sync阶段开始的时间戳。</li>
<li>  IssueDrawCommandsStart - SyncStart &gt; 0.4ms左右则表明有许多新的位图需要上传至GPU。</li>
</ul>
<p><strong>IssueDrawCommandsStart：</strong></p>
<ul>
<li>  硬件渲染器开始GPU发出绘图命令的时间戳。</li>
<li>  用于观察App此时绘制时消耗了多少GPU：FrameCompleted - IssueDrawCommandsStart。</li>
</ul>
<p><strong>SwapBuffers：</strong></p>
<ul>
<li>  eglSwapBuffers被调用时的时间戳。</li>
<li>  通常用于Framework层开发。</li>
</ul>
<p><strong>FrameCompleted：</strong></p>
<ul>
<li>  当前帧完成绘制的时间戳。</li>
<li>  获取当前帧绘制的总时间：FrameCompleted - IntendedVsync。</li>
</ul>
<p>综上，我们可以利用这些数据计算获取我们在自动化测试中想关注的因素，比如<strong>帧耗时、该帧调用View.draw方法所消耗的时间</strong>。framestats和帧耗时信息等一般2s收集一次，即一次120帧。为了精确控制收集数据的时间窗口，如将数据限制为特定的动画，可以重置计数器，重新聚合统计的信息，对应命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys gfxinfo &lt;PackageName&gt; reset</span><br></pre></td></tr></table></figure>

<h3 id="2）、SurfaceFlinger"><a href="#2）、SurfaceFlinger" class="headerlink" title="2）、SurfaceFlinger"></a>2）、SurfaceFlinger</h3><p>我们都知道，在Android 4.1以后，系统使用了三级缓冲机制，即此时有三个Graphic Buffer，那么<strong>如何查看每个Graphic Buffer占用的内存呢？</strong></p>
<p>答案是使用SurfaceFlinger，命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys SurfaceFlinger</span><br></pre></td></tr></table></figure>

<p>输出的结果非常多，因为包含很多系统应用和界面的相关信息，这里我们仅过滤出Awesome-WanAndroid应用对应的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ Layer 0x7f5a92f000 (json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0)</span><br><span class="line">  layerStack=   0, z=    21050, pos=(0,0), size=(1080,2280), crop=(   0,   0,1080,2280), finalCrop=(   0,   0,  -1,  -1), isOpaque=1, invalidate=0, dataspace=(deprecated) sRGB Linear Full range, pixelformat=RGBA_8888 alpha=0.000, flags=0x00000002, tr=[1.00, 0.00][0.00, 1.00]</span><br><span class="line">  client=0x7f5dc23600</span><br><span class="line">  format= 1, activeBuffer=[1080x2280:1088,  1], queued-frames=0, mRefreshPending=0</span><br><span class="line">        mTexName=386 mCurrentTexture=0</span><br><span class="line">        mCurrentCrop=[0,0,0,0] mCurrentTransform=0</span><br><span class="line">        mAbandoned=0</span><br><span class="line">        - BufferQueue mMaxAcquiredBufferCount=1 mMaxDequeuedBufferCount=2</span><br><span class="line">          mDequeueBufferCannotBlock=0 mAsyncMode=0</span><br><span class="line">          default-size=[1080x2280] default-format=1 transform-hint=00 frame-counter=51</span><br><span class="line">        FIFO(0):</span><br><span class="line">        Slots:</span><br><span class="line">          // 序号           // 表明是否使用的状态 // 对象地址 // 当前负责第几帧 // 手机屏幕分辨率大小</span><br><span class="line">         &gt;[00:0x7f5e05a5c0] state=ACQUIRED 0x7f5b1ca580 frame=51 [1080x2280:1088,  1]</span><br><span class="line">          [02:0x7f5e05a860] state=FREE     0x7f5b1ca880 frame=49 [1080x2280:1088,  1]</span><br><span class="line">          [01:0x7f5e05a780] state=FREE     0x7f5b052a00 frame=50 [1080x2280:1088,  1]</span><br></pre></td></tr></table></figure>

<p>在Slots中，显示的是缓冲区相关的信息，可以看到，此时App使用的是00号缓冲区，即第一个缓冲区。</p>
<p>接着，在SurfaceFlinger命令输出log的最下方有一栏Allocated buffers，这这里可以使用当前缓冲区对应的对象地址去查询其占用的内存大小。具体对应到我们这里的是0x7f5b1ca580，匹配到的结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7f5b052a00: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0</span><br><span class="line">0x7f5b1ca580: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0</span><br><span class="line">0x7f5b1ca880: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0</span><br></pre></td></tr></table></figure>

<p>可以看到，这里每一个Graphic Buffer都占用了9MB多的内存，通常分辨率越大，单个Graphic Buffer占用的内存就越多，如1080 x 1920的手机屏幕，一般占用8160kb的内存大小。此外，如果应用使用了其它的Surface，如SurfaceView或TextureView（两者一般用在opengl进行图像处理或视频处理的过程中），这个值会更大。如果当App退到后台，系统就会将这部分内存回收。</p>
<p>了解了常用布局优化常用的工具与命令之后，我们就应该开始着手进行优化了，但在开始之前，我们还得对Android的布局加载原理有比较深入的了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-b7533d1c546de560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="总结（上）"><a href="#总结（上）" class="headerlink" title="总结（上）"></a>总结（上）</h1><p>在本篇文章中，我们主要对Android的布局绘制以及加载原理、优化工具、全局监控布局和控件的加载耗时进行了全面的讲解，这为大家学习《深入探索Android布局优化（下）》打下了良好的基础。下面，总结一下本篇文章涉及的三大主题：</p>
<ul>
<li>  1、绘制原理：CPU\GPU、Android图形系统的整体架构、绘制线程、刷新机制。</li>
<li>  2、屏幕适配：OLED 屏幕和 LCD 屏幕的区别、屏幕适配方案。</li>
<li>  3、优化工具：使用Systrace来进行布局优化、利用Layout Inspector来查看视图层级结构、采用Choreographer来获取FPS以及自动化测量 UI 渲染性能的方式（gfxinfo、SurfaceFlinger等dumpsys命令）。</li>
</ul>
<h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>Android的绘制优化其实可以分为两个部分，即<strong>布局(UI)优化和卡顿优化</strong>，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。由于布局优化这一主题包含的内容太多，因此，笔者将它分为了上、中、下三篇，本篇，即为深入探索Android布局优化的中篇。本篇包含的主要内容如下所示：</p>
<ul>
<li>  4、布局加载原理</li>
<li>  5、获取界面布局耗时</li>
</ul>
<h1 id="四、布局加载原理"><a href="#四、布局加载原理" class="headerlink" title="四、布局加载原理"></a>四、布局加载原理</h1><h2 id="1、为什么要了解Android布局加载原理？"><a href="#1、为什么要了解Android布局加载原理？" class="headerlink" title="1、为什么要了解Android布局加载原理？"></a>1、为什么要了解Android布局加载原理？</h2><p>知其然知其所以然，不仅要明白在平时开发过程中是怎样对布局API进行调用，还要知道它内部的实现原理是什么。明白具体的实现原理与流程之后，我们可能会发现更多可优化的点。</p>
<h2 id="2、布局加载源码分析"><a href="#2、布局加载源码分析" class="headerlink" title="2、布局加载源码分析"></a>2、布局加载源码分析</h2><p>我们都知道，Android的布局都是通过<code>setContentView()</code>这个方法进行设置的，那么它的内部肯定实现了布局的加载，接下来，我们就详细分析下它内部的实现原理与流程。</p>
<p>以<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a>项目为例，我们在通用Activity基类的onCreate方法中进行了布局的设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setContentView(getLayoutId());</span><br></pre></td></tr></table></figure>

<p>点进去，发现是调用了AppCompatActivity的setContentView方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的setContentView其实是AppCompatDelegate这个代理类的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Should be called instead of &#123;<span class="doctag">@link</span> Activity#setContentView(int)&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resId)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>在这个抽象方法的左边，会有一个绿色的小圆圈，点击它就可以查看到对应的实现类与方法</strong>，这里的实现类是AppCompatDelegateImplV9，实现方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setContentView方法中主要是获取到了content父布局，移除其内部所有视图之后并<strong>最终调用了LayoutInflater对象的inflate去加载对应的布局</strong>。接下来，我们关注inflate内部的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是调用了inflate另一个的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">                + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，通过Resources的getLayout方法获取到了一个XmlResourceParser对象，继续跟踪下getLayout方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> XmlResourceParser <span class="title">getLayout</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadXmlResourceParser(id, <span class="string">&quot;layout&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里继续调用了loadXmlResourceParser方法，<strong>注意第二个参数传入的为layout，说明此时加载的是一个Xml资源布局解析器</strong>。我们继续跟踪loadXmlResourceParse方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function">XmlResourceParser <span class="title">loadXmlResourceParser</span><span class="params">(<span class="meta">@AnyRes</span> <span class="keyword">int</span> id, <span class="meta">@NonNull</span> String type)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TypedValue value = obtainTempTypedValue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResourcesImpl impl = mResourcesImpl;</span><br><span class="line">        impl.getValue(id, value, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.type == TypedValue.TYPE_STRING) &#123;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">return</span> impl.loadXmlResourceParser(value.string.toString(), id,</span><br><span class="line">                    value.assetCookie, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">&quot;Resource ID #0x&quot;</span> + Integer.toHexString(id)</span><br><span class="line">                + <span class="string">&quot; type #0x&quot;</span> + Integer.toHexString(value.type) + <span class="string">&quot; is not valid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseTempTypedValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，如果值类型为字符串的话，则调用了ResourcesImpl实例的loadXmlResourceParser方法。我们首先看看这个方法的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads an XML parser for the specified file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file the path for the XML file to parse</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id the resource identifier for the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> assetCookie the asset cookie for the file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type the type of resource (used for logging)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a parser for the specified XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NotFoundException if the file could not be loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function">XmlResourceParser <span class="title">loadXmlResourceParser</span><span class="params">(<span class="meta">@NonNull</span> String file, <span class="meta">@AnyRes</span> <span class="keyword">int</span> id, <span class="keyword">int</span> assetCookie,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> String type)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> block.newParser();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释的意思说明了这个方法是用于<strong>加载指定文件的Xml解析器</strong>，这里我们之间查看关键的mAssets.openXmlBlockAsset方法，这里的mAssets对象是AssetManager类型的，看看AssetManager实例的openXmlBlockAsset方法做了什么处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> * Retrieve a non-asset as a compiled XML file.  Not for use by</span></span><br><span class="line"><span class="comment"> * applications.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cookie Identifier of the package to be opened.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName Name of the asset to retrieve.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">final</span> XmlBlock <span class="title">openXmlBlockAsset</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mOpen) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Assetmanager has been closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">long</span> xmlBlock = openXmlAssetNative(cookie, fileName);</span><br><span class="line">        <span class="keyword">if</span> (xmlBlock != <span class="number">0</span>) &#123;</span><br><span class="line">            XmlBlock res = <span class="keyword">new</span> XmlBlock(<span class="keyword">this</span>, xmlBlock);</span><br><span class="line">            incRefsLocked(res.hashCode());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;Asset XML file: &quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终是调用了注释1处的openXmlAssetNative方法，这是定义在AssetManager中的一个Native方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">openXmlAssetNative</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与此同时，<strong>我们可以猜到读取Xml文件肯定是通过IO流的方式进行的，而openXmlBlockAsset方法后抛出的IOException异常也验证了我们的想法</strong>。因为涉及到IO流的读取，所以这里是Android布局加载流程一个耗时点 ，也有可能是我们后续优化的一个方向。</p>
<p>分析完Resources实例的getLayout方法的实现之后，我们继续跟踪inflate方法的注释2处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">                + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>infalte的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Look for the root node.</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                        + <span class="string">&quot;: No start tag found!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">                <span class="comment">// 2</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，infalte内部是通过XmlPull解析的方式对布局的每一个节点进行创建对应的视图的。首先，在注释1处会判断节点是否是merge标签，如果是，则对merge标签进行校验，如果merge节点不是当前布局的父节点，则抛出异常。然后，在注释2处，<strong>通过createViewFromTag方法去根据每一个标签创建对应的View视图</strong>。我们继续跟踪下createViewFromTag方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在createViewFromTag方法中，首先会判断mFactory2是否存在，存在就会使用mFactory2的onCreateView方法区创建视图，否则就会调用mFactory的onCreateView方法，接下来，如果此时的tag是一个Fragment，则会调用mPrivateFactory的onCreateView方法，否则的话，最终都会调用LayoutInflater实例的createView方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Class not found in the cache, see if it&#x27;s real, and try to add it</span></span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFilter != <span class="keyword">null</span> &amp;&amp; clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">            <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">            <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LayoutInflater的createView方法中，首先，在注释1处，使用类加载器创建了对应的Class实例，然后在注释2处根据Class实例获取到了对应的构造器实例，并最终在注释3处通过构造器实例constructor的newInstance方法创建了对应的View对象。可以看到，<strong>在视图节点的创建过程中采用到了反射</strong>，我们都知道反射是比较耗性能的，<strong>过多的反射可能会导致布局加载过程变慢</strong>，这个点可能是后续优化的一个方向。</p>
<p>最后，我们来总结下Android中的布局加载流程：</p>
<ul>
<li>  1、在setContentView方法中，会通过LayoutInflater的inflate方法去加载对应的布局。</li>
<li>  2、inflate方法中首先会调用Resources的getLayout方法去通过IO的方式去加载对应的Xml布局解析器到内存中。</li>
<li>  3、接着，会通过createViewFromTag根据每一个tag创建具体的View对象。</li>
<li>  4、它内部主要是按优先顺序为Factory2和Factory的onCreatView、createView方法进行View的创建，而createView方法内部采用了构造器反射的方式实现。</li>
</ul>
<p>从以上分析可知，在Android的布局加载流程中，性能瓶颈主要存在两个地方：</p>
<ul>
<li>  1、布局文件解析中的IO过程。</li>
<li>  2、创建View对象时的反射过程。</li>
</ul>
<h2 id="3、LayoutInflater-Factory分析"><a href="#3、LayoutInflater-Factory分析" class="headerlink" title="3、LayoutInflater.Factory分析"></a>3、LayoutInflater.Factory分析</h2><p><strong>在前面分析的View的创建过程中，我们明白系统会优先使用Factory2和Factory去创建对应的View，那么它们究竟是干什么的呢？</strong></p>
<p>其实LayoutInflater.Factory是layoutInflater中创建View的一个Hook，Hook即挂钩，我们可以利用它在创建View的过程中加入一些日志或进行其它更高级的定制化处理：比如可以<strong>全局替换自定义的TextView等等</strong>。</p>
<p>接下来，我们查看下Factory2的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Version of &#123;<span class="doctag">@link</span> #onCreateView(String, Context, AttributeSet)&#125;</span></span><br><span class="line"><span class="comment">     * that also supplies the parent that the view created view will be</span></span><br><span class="line"><span class="comment">     * placed in.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent The parent that the created view will be placed</span></span><br><span class="line"><span class="comment">     * in; &lt;em&gt;note that this may be null&lt;/em&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name Tag name to be inflated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context the view is being created in.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs Inflation attributes as specified in XML file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> View Newly created view. Return null for the default</span></span><br><span class="line"><span class="comment">     *         behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Factory2是直接继承于Factory,继续跟踪下Factory的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hook you can supply that is called when inflating from a LayoutInflater.</span></span><br><span class="line"><span class="comment">     * You can use this to customize the tag names available in your XML</span></span><br><span class="line"><span class="comment">     * layout files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that it is good practice to prefix these custom names with your</span></span><br><span class="line"><span class="comment">     * package (i.e., com.coolcompany.apps) to avoid conflicts with system</span></span><br><span class="line"><span class="comment">     * names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name Tag name to be inflated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context the view is being created in.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs Inflation attributes as specified in XML file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> View Newly created view. Return null for the default</span></span><br><span class="line"><span class="comment">     *         behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onCreateView方法中的第一个参数就是指的tag名字，比如TextView等等，我们还注意到Factory2比Factory的onCreateView方法多一个parent的参数，这是当前创建的View的父View。看来，Factory2比Factory功能要更强大一些。</p>
<p>最后，我们总结下Factory与Factory2的区别：</p>
<ul>
<li>  1、Factory2继承与Factory。</li>
<li>  2、Factory2比Factory的onCreateView方法多一个parent的参数，即当前创建View的父View。</li>
</ul>
<h1 id="五、获取界面布局耗时"><a href="#五、获取界面布局耗时" class="headerlink" title="五、获取界面布局耗时"></a>五、获取界面布局耗时</h1><h2 id="1、常规方式"><a href="#1、常规方式" class="headerlink" title="1、常规方式"></a>1、常规方式</h2><p>如果要获取每个界面的加载耗时，我们就必需在setContentView方法前后进行手动埋点。但是它有如下缺点：</p>
<ul>
<li>  1、不够优雅。</li>
<li>  2、代码有侵入性。</li>
</ul>
<h2 id="2、AOP"><a href="#2、AOP" class="headerlink" title="2、AOP"></a>2、AOP</h2><p>关于AOP的使用，我在<a href="">《深入探索Android启动速度优化》</a>一文的<strong>AOP(Aspect Oriented Programming)打点</strong>部分已经详细讲解过了，这里就不再赘述，还不了解的同学可以点击上面的链接先去学习下AOP的使用。</p>
<p>我们要使用AOP去获取界面布局的耗时，那么我们的切入点就是setContentView方法，声明一个@Aspect注解的PerformanceAop类，然后，我们就可以在里面实现对setContentView进行切面的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSetContentViewTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    String name = signature.toShortString();</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    LogHelper.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了获取方法的耗时，我们必须使用@Around注解，这样第一个参数ProceedingJoinPoint就可以提供proceed方法去执行我们的setContentView方法，在此方法的前后就可以获取setContentView方法的耗时。后面的execution表明了在setContentView方法执行内部去调用我们写好的getSetContentViewTime方法，后面括号内的*是通配符，表示匹配任何Activity的setContentView方法，并且方法参数的个数和类型不做限定。</p>
<p>完成AOP获取界面布局耗时的方法之后，重装应用，打开几个Activity界面，就可以看到如下的界面布局加载耗时日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">17.605</span> <span class="number">12297</span>-<span class="number">12297</span>/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | <span class="number">36</span> | getSetContentViewTime] AppCompatActivity.setContentView(..) cost <span class="number">174</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">58.010</span> <span class="number">12297</span>-<span class="number">12297</span>/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | <span class="number">36</span> | getSetContentViewTime] AppCompatActivity.setContentView(..) cost <span class="number">13</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">27.058</span> <span class="number">12297</span>-<span class="number">12297</span>/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | <span class="number">36</span> | getSetContentViewTime] AppCompatActivity.setContentView(..) cost <span class="number">44</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">31.128</span> <span class="number">12297</span>-<span class="number">12297</span>/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | <span class="number">36</span> | getSetContentViewTime] AppCompatActivity.setContentView(..) cost <span class="number">61</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">23</span>:<span class="number">09.805</span> <span class="number">12297</span>-<span class="number">12297</span>/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | <span class="number">36</span> | getSetContentViewTime] AppCompatActivity.setContentView(..) cost <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>可以看到，Awesome-WanAndroid项目里面各个界面的加载耗时一般都在几十毫秒作用，加载慢的界面可能会达到100多ms，当然，不同手机的配置不一样，但是，<strong>这足够让我们发现哪些界面布局的加载比较慢</strong>。</p>
<h2 id="3、LayoutInflaterCompat-setFactory2"><a href="#3、LayoutInflaterCompat-setFactory2" class="headerlink" title="3、LayoutInflaterCompat.setFactory2"></a>3、LayoutInflaterCompat.setFactory2</h2><p>上面我们使用了AOP的方式监控了Activity的布局加载耗时，那么，<strong>如果我们需要监控每一个控件的加载耗时，该怎么实现呢？</strong></p>
<p>答案是使用LayoutInflater.Factory2，我们<strong>在基类Activity的onCreate方法中直接使用LayoutInflaterCompat.setFactory2方法对Factory2的onCreateView方法进行重写</strong>，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时，</span></span><br><span class="line">    <span class="comment">// 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。</span></span><br><span class="line">    LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.equals(name, <span class="string">&quot;TextView&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 生成自定义TextView</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            View view = getDelegate().createView(parent, name, context, attrs);</span><br><span class="line">            LogHelper.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、setFactory2方法需在super.onCreate方法前调用，否则无效        </span></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(getLayoutId());</span><br><span class="line">    unBinder = ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    mActivity = <span class="keyword">this</span>;</span><br><span class="line">    ActivityCollector.getInstance().addActivity(<span class="keyword">this</span>);</span><br><span class="line">    onViewCreated();</span><br><span class="line">    initToolbar();</span><br><span class="line">    initEventAndData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就实现了利用LayoutInflaterCompat.Factory2<strong>全局监控Activity界面每一个控件加载耗时的处理，后续我们可以将这些数据上传到我们自己的APM服务端，作为监控数据可以分析出哪些控件加载比较耗时</strong>。当然，这里我们也可以做全局的自定义控件替换处理，比如在上述代码中，我们可以将TextView全局替换为自定义的TextView。</p>
<p>然后，我们注意到这里我们使用getDelegate().createView方法来创建对应的View实例，跟踪进去发现这里的createView是一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, String name, <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="meta">@NonNull</span> AttributeSet attrs)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它对应的实现方法为AppCompatDelegateImplV9对象的createView方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* Only read android:theme pre-L (L+ handles this anyway) */</span></span><br><span class="line">            <span class="keyword">true</span>, <span class="comment">/* Read read app:theme as a fallback at all times for legacy reasons */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* Only tint wrap the context if enabled */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终又调用了AppCompatViewInflater对象的createView方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs, <span class="keyword">boolean</span> inheritContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> readAndroidTheme, <span class="keyword">boolean</span> readAppTheme, <span class="keyword">boolean</span> wrapContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to &#x27;inject&#x27; our tint aware Views in place of the standard framework versions</span></span><br><span class="line">    <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatTextView(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatImageView(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatButton(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatEditText(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatSpinner(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatImageButton(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatCheckBox(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatRadioButton(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatCheckedTextView(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatAutoCompleteTextView(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatRatingBar(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">            view = <span class="keyword">new</span> AppCompatSeekBar(context, attrs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">        <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">        <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">        view = createViewFromTag(context, name, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">        checkOnClickListener(view, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AppCompatViewInflater对象的createView方法中系统根据不同的tag名字创建出了对应的AppCompat兼容控件。看到这里，我们明白了<strong>Android系统是使用了LayoutInflater的Factor2/Factory结合了AppCompat兼容类来进行高级版本控件的兼容适配的。</strong></p>
<p>接下来，我们注意到注释1处，<strong>setFactory2方法需在super.onCreate方法前调用，否则无效，这是为什么呢？</strong></p>
<p>这里可以先大胆猜测一下，可能是因为在<code>super.onCreate()</code>方法中就需要将Factory2实例存储到内存中以便后续使用。下面，我们就跟踪一下<code>super.onCreate()</code>的源码，看看是否如我们所假设的一样。AppCompatActivity的onCreate方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppCompatDelegate delegate = getDelegate();</span><br><span class="line">    delegate.installViewFactory();</span><br><span class="line">    delegate.onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">if</span> (delegate.applyDayNight() &amp;&amp; mThemeId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If DayNight has been applied, we need to re-apply the theme for</span></span><br><span class="line">        <span class="comment">// the changes to take effect. On API 23+, we should bypass</span></span><br><span class="line">        <span class="comment">// setTheme(), which will no-op if the theme ID is identical to the</span></span><br><span class="line">        <span class="comment">// current theme ID.</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            onApplyThemeResource(getTheme(), mThemeId, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setTheme(mThemeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行的delegate实例的installViewFactory()方法就吸引了我们的注意，因为它包含了一个敏感的关键字“Factory“，这里我们继续跟踪进installViewFactory()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">installViewFactory</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里一个是抽象方法，点击左边绿色圆圈，可以看到这里具体的实现类为AppCompatDelegateImplV9，其实现的installViewFactory()方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installViewFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LayoutInflater layoutInflater = LayoutInflater.from(mContext);</span><br><span class="line">    <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImplV9)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果我们在super.onCreate()方法前没有设置LayoutInflater的Factory2实例的话，这里就会设置一个默认的Factory2。最后，我们再来看下默认Factory2的onCreateView方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From &#123;<span class="doctag">@link</span> LayoutInflater.Factory2&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、First let the Activity&#x27;s Factory try and inflate the view</span></span><br><span class="line">    <span class="keyword">final</span> View view = callActivityOnCreateView(parent, name, context, attrs);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、If the Factory didn&#x27;t handle it, let our createView() method try</span></span><br><span class="line">    <span class="keyword">return</span> createView(parent, name, context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，我们首先会尝试让Activity的Facotry实例去加载对应的View实例，如果Factory不能够处理它，在注释2处，就会调用createView方法去创建对应的View，AppCompatDelegateImplV9类的createView方法的实现上面我们已经分析过了，此处就不再赘述了。</p>
<h1 id="总结（中）"><a href="#总结（中）" class="headerlink" title="总结（中）"></a>总结（中）</h1><p>在本篇文章中，我们主要对Android的全局监控布局和控件的加载耗时进行了全面的讲解，这为大家学习《深入探索Android布局优化（下）》打下了良好的基础。下面，总结一下本篇文章涉及的两大大主题：</p>
<ul>
<li>  4、布局加载原理：布局加载源码分析、LayoutInflater.Factory分析。</li>
<li>  5、获取界面布局耗时：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li>
</ul>
<h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>在上篇文章中，笔者带领大家学习了布局优化涉及到的绘制原理、优化工具、监测手段等等知识。如果对这块内容还不了解的建议先看看<a href="">《深入探索Android布局优化（上）》</a>、<a href="">深入探索Android布局优化（中）</a>。本篇，为深入探索Android布局优化的下篇。这篇文章包含的主要内容如下所示：</p>
<ul>
<li>  6、布局优化常规方案</li>
<li>  7、布局优化的进阶方案</li>
<li>  8、布局优化的常见问题</li>
</ul>
<p>下面，笔者将与大家一起进入进行布局优化的实操环节。</p>
<h3 id="六、布局优化常规方案"><a href="#六、布局优化常规方案" class="headerlink" title="六、布局优化常规方案"></a>六、布局优化常规方案</h3><p>布局优化的方法有很多，大部分主流的方案笔者已经在<a href="">Android性能优化之绘制优化</a>里讲解过了。下面，我将介绍一些其它的优化方案。</p>
<h4 id="1、布局Inflate优化方案演进"><a href="#1、布局Inflate优化方案演进" class="headerlink" title="1、布局Inflate优化方案演进"></a>1、布局Inflate优化方案演进</h4><h5 id="1、代码动态创建View"><a href="#1、代码动态创建View" class="headerlink" title="1、代码动态创建View"></a>1、代码动态创建View</h5><p>使用Java代码动态添加控件的简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Button button=<span class="keyword">new</span> Button(<span class="keyword">this</span>);        </span><br><span class="line">button.setBackgroundColor(Color.RED);</span><br><span class="line">button.setText(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">ViewGroup viewGroup = (ViewGroup) LayoutInflater.from(<span class="keyword">this</span>).inflate(R.layout.activity_main, <span class="keyword">null</span>);</span><br><span class="line">viewGroup.addView(button);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、替换MessageQueue来实现异步创建View"><a href="#2、替换MessageQueue来实现异步创建View" class="headerlink" title="2、替换MessageQueue来实现异步创建View"></a>2、替换MessageQueue来实现异步创建View</h5><p>在使用子线程创建视图控件的时候，我们可以把子线程Looper的MessageQueue替换成主线程的MessageQueue，在创建完需要的视图控件后记得将子线程Looper中的MessageQueue恢复为原来的。在<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-WanAndroid">Awesome-WanAndroid</a>项目下的UiUtils的Ui优化工具类中，提供了相应的实现，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现将子线程Looper中的MessageQueue替换为主线程中Looper的</span></span><br><span class="line"><span class="comment"> * MessageQueue，这样就能够在子线程中异步创建UI。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：需要在子线程中调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reset 是否将子线程中的MessageQueue重置为原来的，false则表示需要进行替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">replaceLooperWithMainThreadQueue</span><span class="params">(<span class="keyword">boolean</span> reset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CommonUtils.isMainThread()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取子线程的ThreadLocal实例</span></span><br><span class="line">        ThreadLocal&lt;Looper&gt; threadLocal = ReflectUtils.reflect(Looper.class).field(<span class="string">&quot;sThreadLocal&quot;</span>).get();</span><br><span class="line">        <span class="keyword">if</span> (threadLocal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Looper looper = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!reset) &#123;</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                looper = Looper.myLooper();</span><br><span class="line">                <span class="comment">// 2、通过调用MainLooper的getQueue方法区获取主线程Looper中的MessageQueue实例</span></span><br><span class="line">                Object queue = ReflectUtils.reflect(Looper.getMainLooper()).method(<span class="string">&quot;getQueue&quot;</span>).get();</span><br><span class="line">                <span class="keyword">if</span> (!(queue <span class="keyword">instanceof</span> MessageQueue)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3、将子线程中的MessageQueue字段的值设置为主线的MessageQueue实例</span></span><br><span class="line">                ReflectUtils.reflect(looper).field(<span class="string">&quot;mQueue&quot;</span>, queue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、reset为false，表示需要将子线程Looper中的MessageQueue重置为原来的。</span></span><br><span class="line">            ReflectUtils.reflect(threadLocal).method(<span class="string">&quot;set&quot;</span>, looper);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、AsynclayoutInflater异步创建View"><a href="#3、AsynclayoutInflater异步创建View" class="headerlink" title="3、AsynclayoutInflater异步创建View"></a>3、AsynclayoutInflater异步创建View</h5><p>在第三小节中，我们对Android的布局加载原理进行了深入地分析，从中我们得出了布局加载过程中的两个耗时点：</p>
<ul>
<li>  1、布局文件读取慢：IO过程。</li>
<li>  2、创建View慢：使用反射，比直接new的方式要慢3倍。布局嵌套层级越多，控件个数越多，反射的次数就会越频繁。</li>
</ul>
<p>很明显，我们无法从根本上去解决这两个问题，但是Google提供了一个从侧面解决的方案:使用AsyncLayoutInflater去异步加载对应的布局，它的特点如下：</p>
<ul>
<li>  1、工作线程加载布局。</li>
<li>  2、回调主线程。</li>
<li>  3、节省主线程时间。</li>
</ul>
<p>接下来，我将详细地介绍AsynclayoutInflater的使用。</p>
<p>首先，在项目的build.gradle中进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.android.support:asynclayoutinflater:28.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，在Activity中的onCreate方法中将setContentView注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"><span class="comment">// 内部分别使用了IO和反射的方式去加载布局解析器和创建对应的View</span></span><br><span class="line"><span class="comment">// setContentView(R.layout.activity_main);</span></span><br></pre></td></tr></table></figure>

<p>接着，在super.onCreate方法前继续布局的异步加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用AsyncLayoutInflater进行布局的加载</span></span><br><span class="line"><span class="keyword">new</span> AsyncLayoutInflater(MainActivity.<span class="keyword">this</span>).inflate(R.layout.activity_main, <span class="keyword">null</span>, <span class="keyword">new</span> AsyncLayoutInflater.OnInflateFinishedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="keyword">int</span> i, <span class="meta">@Nullable</span> ViewGroup viewGroup)</span> </span>&#123;</span><br><span class="line">            setContentView(view);</span><br><span class="line">            <span class="comment">// findViewById、视图操作等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br></pre></td></tr></table></figure>

<p>接下来，我们来分析下AsyncLayoutInflater的实现原理与工作流程。</p>
<p>由于我们是使用new的方式创建的AsyncLayoutInflater，所以我们先来看看它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AsyncLayoutInflater</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">this</span>.mInflater = <span class="keyword">new</span> AsyncLayoutInflater.BasicInflater(context);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> Handler(<span class="keyword">this</span>.mHandlerCallback);</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">this</span>.mInflateThread = AsyncLayoutInflater.InflateThread.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，创建了一个BasicInflater，它内部的onCreateView并没有使用Factory做AppCompat控件兼容的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    String[] var3 = sClassPrefixList;</span><br><span class="line">    <span class="keyword">int</span> var4 = var3.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        String prefix = var3[var5];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            View view = <span class="keyword">this</span>.createView(name, prefix, attrs);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由前面的分析可知，在createView方法中仅仅是做了反射创建出对应View的处理。</p>
<p>接着，在注释2处，创建了一个全局的Handler对象，主要是用于将异步线程创建好的View实例及其相关信息回调到主线程。</p>
<p>最后，在注释3处，获取了一个用于异步加载View的线程实例。</p>
<p>接着，我们继续跟踪AsyncLayoutInflater实例的inflate方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resid, <span class="meta">@Nullable</span> ViewGroup parent, <span class="meta">@NonNull</span> AsyncLayoutInflater.OnInflateFinishedListener callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;callback argument may not be null!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        AsyncLayoutInflater.InflateRequest request = <span class="keyword">this</span>.mInflateThread.obtainRequest();</span><br><span class="line">        request.inflater = <span class="keyword">this</span>;</span><br><span class="line">        request.resid = resid;</span><br><span class="line">        request.parent = parent;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        <span class="keyword">this</span>.mInflateThread.enqueue(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，这里使用InflateRequest对象将我们传进来的三个参数进行了包装，并最终将这个InflateRequest对象加入了mInflateThread线程中的一个ArrayBlockingQueue中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncLayoutInflater.InflateRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mQueue.put(request);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to enqueue async inflate request&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，在InflateThread这个静态内部类的静态代码块中调用了其自身实例的start方法以启动线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    sInstance.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.runInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AsyncLayoutInflater.InflateRequest request;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        request = (AsyncLayoutInflater.InflateRequest)<span class="keyword">this</span>.mQueue.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException var4) &#123;</span><br><span class="line">        Log.w(<span class="string">&quot;AsyncLayoutInflater&quot;</span>, var4);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        request.view = request.inflater.mInflater.inflate(request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var3) &#123;</span><br><span class="line">        Log.w(<span class="string">&quot;AsyncLayoutInflater&quot;</span>, <span class="string">&quot;Failed to inflate resource in the background! Retrying on the UI thread&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    Message.obtain(request.inflater.mHandler, <span class="number">0</span>, request).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在run方法中，使用了死循环的方式去不断地调用runInner方法，在runInner方法中，首先在注释1处从ArrayBlockingQueue队列中获取一个InflateRequest对象，然后在注释2处将异步加载好的view对象赋值给了InflateRequest对象，最后，在注释3处，将请求作为消息发送给了Handler的handleMessage：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback mHandlerCallback = <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncLayoutInflater.InflateRequest request = (AsyncLayoutInflater.InflateRequest)msg.obj;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (request.view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.view = AsyncLayoutInflater.<span class="keyword">this</span>.mInflater.inflate(request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.callback.onInflateFinished(request.view, request.resid, request.parent);</span><br><span class="line">        AsyncLayoutInflater.<span class="keyword">this</span>.mInflateThread.releaseRequest(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在handleMessage方法中，当异步加载得到的view为null时，此时在注释1处还做了一个fallback处理，直接在主线程进行view的加载，以此兼容某些异常情况，最后，就调用了回调接口的onInflateFinished方法将view的相关信息返回给Activity对象。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由以上分析可知，AsyncLayoutInflater是通过侧面缓解的方式去缓解布局加载过程中的卡顿，但是它依然存在一些问题：</p>
<ul>
<li>  1、不能设置LayoutInflater.Factory，需要通过自定义AsyncLayoutInflater的方式解决，由于它是一个final，所以需要将代码直接拷处进行修改。</li>
<li>  2、因为是异步加载，所以需要注意在布局加载过程中不能有依赖于主线程的操作。</li>
</ul>
<p>由于AsyncLayoutInflater仅仅只能通过侧面缓解的方式去缓解布局加载的卡顿，因此，我们下面将介绍一种从根本上解决问题的方案。对于AsynclayoutInflater的改进措施，可以查看祁同伟同学封装之后的代码，具体的改进分析可以查看<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0c0eda06ae4">Android AsyncLayoutInflater 限制及改进</a>，这里附上改进之后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现异步加载布局的功能，修改点：</span></span><br><span class="line"><span class="comment">* 1\. 单一线程；</span></span><br><span class="line"><span class="comment">* 2\. super.onCreate之前调用没有了默认的Factory；</span></span><br><span class="line"><span class="comment"> * 3\. 排队过多的优化；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncLayoutInflaterPlus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;AsyncLayoutInflaterPlus&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line">    <span class="keyword">private</span> InflateRunnable mInflateRunnable;</span><br><span class="line">    <span class="comment">// 真正执行加载任务的线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService sExecutor = Executors.newFixedThreadPool(Math.max(<span class="number">2</span>,</span><br><span class="line">        Runtime.getRuntime().availableProcessors() - <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// InflateRequest pool</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pools.SynchronizedPool&lt;AsyncLayoutInflaterPlus.InflateRequest&gt; sRequestPool = <span class="keyword">new</span> Pools.SynchronizedPool&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> Future&lt;?&gt; future;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncLayoutInflaterPlus</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        mInflater = <span class="keyword">new</span> AsyncLayoutInflaterPlus.BasicInflater(context);</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mHandlerCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resid, <span class="meta">@Nullable</span> ViewGroup parent, <span class="meta">@NonNull</span> CountDownLatch countDownLatch,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="meta">@NonNull</span> AsyncLayoutInflaterPlus.OnInflateFinishedListener callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;callback argument may not be null!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        AsyncLayoutInflaterPlus.InflateRequest request = obtainRequest();</span><br><span class="line">        request.inflater = <span class="keyword">this</span>;</span><br><span class="line">        request.resid = resid;</span><br><span class="line">        request.parent = parent;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.countDownLatch = countDownLatch;</span><br><span class="line">        mInflateRunnable = <span class="keyword">new</span> InflateRunnable(request);</span><br><span class="line">        future = sExecutor.submit(mInflateRunnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        future.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断这个任务是否已经开始执行</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInflateRunnable.isRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler.Callback mHandlerCallback = <span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            AsyncLayoutInflaterPlus.InflateRequest request = (AsyncLayoutInflaterPlus.InflateRequest) msg.obj;</span><br><span class="line">            <span class="keyword">if</span> (request.view == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.view = mInflater.inflate(</span><br><span class="line">                    request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            request.callback.onInflateFinished(</span><br><span class="line">                request.view, request.resid, request.parent);</span><br><span class="line">            request.countDownLatch.countDown();</span><br><span class="line">            releaseRequest(request);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnInflateFinishedListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(View view, <span class="keyword">int</span> resid, ViewGroup parent)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InflateRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> InflateRequest request;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InflateRunnable</span><span class="params">(InflateRequest request)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.request = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request.view = request.inflater.mInflater.inflate(</span><br><span class="line">                    request.resid, request.parent, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="comment">// Probably a Looper failure, retry on the UI thread</span></span><br><span class="line">                Log.w(TAG, <span class="string">&quot;Failed to inflate resource in the background! Retrying on the UI&quot;</span></span><br><span class="line">                    + <span class="string">&quot; thread&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            Message.obtain(request.inflater.mHandler, <span class="number">0</span>, request)</span><br><span class="line">                .sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isRunning;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InflateRequest</span> </span>&#123;</span><br><span class="line">        AsyncLayoutInflaterPlus inflater;</span><br><span class="line">        ViewGroup parent;</span><br><span class="line">        <span class="keyword">int</span> resid;</span><br><span class="line">        View view;</span><br><span class="line">        AsyncLayoutInflaterPlus.OnInflateFinishedListener callback;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        InflateRequest() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicInflater</span> <span class="keyword">extends</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">                <span class="string">&quot;android.widget.&quot;</span>,</span><br><span class="line">                <span class="string">&quot;android.webkit.&quot;</span>,</span><br><span class="line">                <span class="string">&quot;android.app.&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        BasicInflater(Context context) &#123;</span><br><span class="line">            <span class="keyword">super</span>(context);</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> AppCompatActivity) &#123;</span><br><span class="line">                <span class="comment">// 加上这些可以保证AppCompatActivity的情况下，super.onCreate之前</span></span><br><span class="line">                <span class="comment">// 使用AsyncLayoutInflater加载的布局也拥有默认的效果</span></span><br><span class="line">                AppCompatDelegate appCompatDelegate = ((AppCompatActivity) context).getDelegate();</span><br><span class="line">                <span class="keyword">if</span> (appCompatDelegate <span class="keyword">instanceof</span> LayoutInflater.Factory2) &#123;</span><br><span class="line">                    LayoutInflaterCompat.setFactory2(<span class="keyword">this</span>, (LayoutInflater.Factory2) appCompatDelegate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncLayoutInflaterPlus.BasicInflater(newContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    View view = createView(name, prefix, attrs);</span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> view;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// In this case we want to let the base class take a crack</span></span><br><span class="line">                    <span class="comment">// at it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AsyncLayoutInflaterPlus.<span class="function">InflateRequest <span class="title">obtainRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AsyncLayoutInflaterPlus.InflateRequest obj = sRequestPool.acquire();</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> AsyncLayoutInflaterPlus.InflateRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseRequest</span><span class="params">(AsyncLayoutInflaterPlus.InflateRequest obj)</span> </span>&#123;</span><br><span class="line">        obj.callback = <span class="keyword">null</span>;</span><br><span class="line">        obj.inflater = <span class="keyword">null</span>;</span><br><span class="line">        obj.parent = <span class="keyword">null</span>;</span><br><span class="line">        obj.resid = <span class="number">0</span>;</span><br><span class="line">        obj.view = <span class="keyword">null</span>;</span><br><span class="line">        sRequestPool.release(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调用入口类；同时解决加载和获取View在不同类的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncLayoutLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLayoutId;</span><br><span class="line">    <span class="keyword">private</span> View mRealView;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mRootView;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mCountDownLatch;</span><br><span class="line">    <span class="keyword">private</span> AsyncLayoutInflaterPlus mInflater;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SparseArrayCompat&lt;AsyncLayoutLoader&gt; sArrayCompat = <span class="keyword">new</span> SparseArrayCompat&lt;AsyncLayoutLoader&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncLayoutLoader <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncLayoutLoader(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AsyncLayoutLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        mCountDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resid, <span class="meta">@Nullable</span> ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        inflate(resid, parent, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UiThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> resid, <span class="meta">@Nullable</span> ViewGroup parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                    AsyncLayoutInflaterPlus.OnInflateFinishedListener listener)</span> </span>&#123;</span><br><span class="line">        mRootView = parent;</span><br><span class="line">        mLayoutId = resid;</span><br><span class="line">        sArrayCompat.append(mLayoutId, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener = <span class="keyword">new</span> AsyncLayoutInflaterPlus.OnInflateFinishedListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(View view, <span class="keyword">int</span> resid, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">                    mRealView = view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        mInflater = <span class="keyword">new</span> AsyncLayoutInflaterPlus(mContext);</span><br><span class="line">        mInflater.inflate(resid, parent, mCountDownLatch, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * getLayoutLoader 和 getRealView 方法配对出现</span></span><br><span class="line"><span class="comment">    * 用于加载和获取View在不同类的场景</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resid</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncLayoutLoader <span class="title">getLayoutLoader</span><span class="params">(<span class="keyword">int</span> resid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sArrayCompat.get(resid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * getLayoutLoader 和 getRealView 方法配对出现</span></span><br><span class="line"><span class="comment">    * 用于加载和获取View在不同类的场景</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resid</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getRealView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRealView == <span class="keyword">null</span> &amp;&amp; !mInflater.isRunning()) &#123;</span><br><span class="line">            mInflater.cancel();</span><br><span class="line">            inflateSync();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRealView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCountDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            setLayoutParamByParent(mContext, mRootView, mLayoutId, mRealView);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setLayoutParamByParent(mContext, mRootView, mLayoutId, mRealView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mRealView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据Parent设置异步加载View的LayoutParamsView</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> layoutResId</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLayoutParamByParent</span><span class="params">(Context context, ViewGroup parent, <span class="keyword">int</span> layoutResId, View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = context.getResources().getLayout(layoutResId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">            ViewGroup.LayoutParams params = parent.generateLayoutParams(attrs);</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRealView = LayoutInflater.from(mContext).inflate(mLayoutId, mRootView, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、使用X2C进行布局加载优化"><a href="#4、使用X2C进行布局加载优化" class="headerlink" title="4、使用X2C进行布局加载优化"></a>4、使用X2C进行布局加载优化</h5><p>由上分析可知，在布局加载的过程中有两个主要的耗时点，即IO操作和反射，<strong>而AsyncLayoutInflater仅仅是缓解，那么有什么方案能从根本上去解决这个问题呢？</strong></p>
<h4 id="使用Java代码写布局？"><a href="#使用Java代码写布局？" class="headerlink" title="使用Java代码写布局？"></a>使用Java代码写布局？</h4><p>如果使用Java代码写布局，无疑从Xml文件进行IO操作的过程和反射获取View实例的过程都将被抹去。虽然这样从本质上解决了问题，但是也引入了一些新问题，如不便于开发，可维护性差等等。</p>
<p>那么，还有没有别的更好的方式呢？</p>
<p>答案就是X2C。</p>
<h4 id="X2C"><a href="#X2C" class="headerlink" title="X2C"></a>X2C</h4><p><a target="_blank" rel="noopener" href="https://github.com/iReaderAndroid/X2C/blob/master/README_CN.md">X2C项目地址</a></p>
<p><strong>X2C框架保留了XML的优点，并解决了其IO操作和反射的性能问题。开发人员只需要正常写XML代码即可，在编译期，X2C会利用APT工具将XML代码翻译为Java代码。</strong></p>
<p>接下来，我们来进行X2C的使用。</p>
<p>首先，在app的build.gradle文件添加如下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotationProcessor <span class="string">&#x27;com.zhangyue.we:x2c-apt:1.1.2&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.zhangyue.we:x2c-lib:1.0.6&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，在对应的MainActivity类上方添加如下注解，让MainActivity知道我们使用的布局是activity_main：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Xml(layouts = &quot;activity_main&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">OnFeedShowCallBack</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>接着，将onCreate方法中setContentView的原始方式改为X2C的设置方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X2C.setContentView(MainActivity.<span class="keyword">this</span>, R.layout.activity_main);</span><br></pre></td></tr></table></figure>

<p>最后，我们再Rebuild项目，会在build下的generated-&gt;source-&gt;apt-&gt;debug-&gt;com.zhangyue.we.x2c下自动生成X2C127_activity_main这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X2C127_activity_main</span> <span class="keyword">implements</span> <span class="title">IViewCreator</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">createView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.zhangyue.we.x2c.layouts.X2C127_Activity_Main().createView(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中又继续调用了layout目录下的X2C127_Activity_Main实例的createView方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X2C127_Activity_Main</span> <span class="keyword">implements</span> <span class="title">IViewCreator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">createView</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        Resources res = ctx.getResources();</span><br><span class="line"></span><br><span class="line">        ConstraintLayout constraintLayout0 = <span class="keyword">new</span> ConstraintLayout(ctx);</span><br><span class="line"></span><br><span class="line">        RecyclerView recyclerView1 = <span class="keyword">new</span> RecyclerView(ctx);</span><br><span class="line">        ConstraintLayout.LayoutParams layoutParam1 = <span class="keyword">new</span> ConstraintLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        recyclerView1.setId(R.id.recycler_view);</span><br><span class="line">        recyclerView1.setLayoutParams(layoutParam1);</span><br><span class="line">        constraintLayout0.addView(recyclerView1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> constraintLayout0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可知，里面采用了new的方式创建了相应的控件，并设置了对应的信息。</p>
<p>接下来，我们回到X2C.setContentView(MainActivity.this, R.layout.activity_main)这个方法，看看它内部究竟做了什么处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置contentview，检测如果有对应的java文件，使用java文件，否则使用xml</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> activity 上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> layoutId layout的资源id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(Activity activity, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Activity must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    View view = getView(activity, layoutId);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activity.setContentView(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activity.setContentView(layoutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，通过getView方法获取到了对应的view，我们继续跟踪进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">getView</span><span class="params">(Context context, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    IViewCreator creator = sSparseArray.get(layoutId);</span><br><span class="line">    <span class="keyword">if</span> (creator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> group = generateGroupId(layoutId);</span><br><span class="line">            String layoutName = context.getResources().getResourceName(layoutId);</span><br><span class="line">            layoutName = layoutName.substring(layoutName.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            String clzName = <span class="string">&quot;com.zhangyue.we.x2c.X2C&quot;</span> + group + <span class="string">&quot;_&quot;</span> + layoutName;</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            creator = (IViewCreator) context.getClassLoader().loadClass(clzName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果creator为空，放一个默认进去，防止每次都调用反射方法耗时</span></span><br><span class="line">        <span class="keyword">if</span> (creator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            creator = <span class="keyword">new</span> DefaultCreator();</span><br><span class="line">        &#125;</span><br><span class="line">        sSparseArray.put(layoutId, creator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> creator.createView(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里采用了一个sSparseArray集合去存储布局对应的视图创建对象creator，如果是首次创建creator的话，会在注释1处使用反射的方式去加载处对应的creator对象，然后将它放入sSparseArray集中，最后在注释2处调用了creator的createView方法去使用new的方式去创建对应的控件。</p>
<p>但是，X2C框架还存在一些问题：</p>
<ul>
<li>  1、部分Java属性不支持。</li>
<li>  2、失去了系统的兼容（AppCompat）</li>
</ul>
<p>对于第2个问题，我们需要修改X2C框架的源码，<strong>当发现是TextView等控件时，需要直接使用new的方式去创建一个AppCompatTextView等兼容类型的控件</strong>。于此同时，它还有如下两个小的点不支持，但是这个问题不大：</p>
<ul>
<li>  merge标签 ,在编译期间无法确定xml的parent，所以无法支持。</li>
<li>  系统style,在编译期间只能查到应用的style列表，无法查询系统style，所以只支持应用内style。</li>
</ul>
<h4 id="2、使用ConstraintLayout降低布局嵌套层级"><a href="#2、使用ConstraintLayout降低布局嵌套层级" class="headerlink" title="2、使用ConstraintLayout降低布局嵌套层级"></a>2、使用ConstraintLayout降低布局嵌套层级</h4><p>首先，对于Android视图绘制的原理，我们必须要有一定的了解，关于这块，大家可以参考下<a href="">Android View的绘制流程</a> 这篇文章。</p>
<p>对于视图绘制的性能瓶颈，大概有以下三点：</p>
<ul>
<li>  1、测量、布局、绘制每个阶段的耗时。</li>
<li>  2、自顶而下的遍历，当嵌套层级过多时，遍历耗时会比较明显。</li>
<li>  3、无效的嵌套布局或不合理使用RelativeLayout可能会导致触发多次绘制。</li>
</ul>
<p>那么，如何减少布局的层级及复杂度呢？</p>
<p>基本上只要遵循以下两点即可：</p>
<ul>
<li>  1、减少View树层级。</li>
<li>  2、宽而浅，避免窄而深。</li>
</ul>
<p>为了提升布局的绘制速度，Google推出了ConstraintLayout，它的特点如下：</p>
<ul>
<li>  1、实现几乎完全扁平化的布局。</li>
<li>  2、构建复杂布局性能更高。</li>
<li>  3、具有RelativeLayout和LinearLayout的特性。</li>
</ul>
<p>接下来，我们来简单使用一下ConstraintLayout来优化一下我们的布局。</p>
<p>首先，下面是我们的原始布局:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/ll_out&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;5dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;com.facebook.drawee.view.SimpleDraweeView</span><br><span class="line">            android:id=&quot;@+id/iv_news&quot;</span><br><span class="line">            android:layout_width=&quot;80dp&quot;</span><br><span class="line">            android:layout_height=&quot;80dp&quot;</span><br><span class="line">            android:scaleType=&quot;fitXY&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tv_title&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:padding=&quot;10dp&quot;</span><br><span class="line">            android:textSize=&quot;20dp&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;right&quot;</span><br><span class="line">        android:padding=&quot;3dp&quot;</span><br><span class="line">        android:text=&quot;来自NBA官网&quot;</span><br><span class="line">        android:textSize=&quot;14dp&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到,它具有三层嵌套结构,然后我们来使用ConstraintLayout来优化一下这个布局：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/ll_out&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;5dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;com.facebook.drawee.view.SimpleDraweeView</span><br><span class="line">        android:id=&quot;@+id/iv_news&quot;</span><br><span class="line">        android:layout_width=&quot;80dp&quot;</span><br><span class="line">        android:layout_height=&quot;80dp&quot;</span><br><span class="line">        android:scaleType=&quot;fitXY&quot;</span><br><span class="line">        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_title&quot;</span><br><span class="line">        android:layout_width=&quot;0dp&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:paddingLeft=&quot;10dp&quot;</span><br><span class="line">        android:textSize=&quot;20dp&quot;</span><br><span class="line">        app:layout_constraintLeft_toRightOf=&quot;@id/iv_news&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toTopOf=&quot;@id/iv_news&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:padding=&quot;3dp&quot;</span><br><span class="line">        android:text=&quot;来自NBA官网&quot;</span><br><span class="line">        android:textSize=&quot;14dp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintRight_toRightOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintTop_toBottomOf=&quot;@id/iv_news&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过ConstraintLayout之后，布局的嵌套层级变为了2级，如果布局比较复杂，比如有5，6，7层嵌套层级，使用Contraintlayout之后降低的层级会更加明显。对于其app下的一系列属性，其实都非常简单，这里就不多做介绍了。</p>
<p>除此之外，还有以下方式可以减少布局层级和复杂度：</p>
<ul>
<li>  1、不嵌套使用RelativeLayout。</li>
<li>  2、不在嵌套LinearLayout中使用weight。</li>
<li>  3、使用merge标签，它能够减少一个层级，但只能用于根View。</li>
</ul>
<h4 id="3、过渡绘制优化"><a href="#3、过渡绘制优化" class="headerlink" title="3、过渡绘制优化"></a>3、过渡绘制优化</h4><p>在视图的绘制优化中，还有一个比较重要的优化点，就是避免过渡绘制，这个笔者已经在<a href="">Android性能优化之绘制优化</a>一文的第四小节详细分析过了。最后这里补充一下自定义View中使用clipRect的一个实例。</p>
<p>首先，我们自定义了一个DroidCardsView，他可以存放多个叠加的卡片，onDraw方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t draw anything until all the Asynctasks are done and all the DroidCards are ready.</span></span><br><span class="line">    <span class="keyword">if</span> (mDroids.length &gt; <span class="number">0</span> &amp;&amp; mDroidCards.size() == mDroids.length) &#123;</span><br><span class="line">        <span class="comment">// Loop over all the droids, except the last one.</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mDroidCards.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            mCardLeft = i * mCardSpacing;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Draw the card. Only the parts of the card that lie within the bounds defined by</span></span><br><span class="line">            <span class="comment">// the clipRect() get drawn.</span></span><br><span class="line">            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the final card. This one doesn&#x27;t get clipped.</span></span><br><span class="line">        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - <span class="number">1</span>),</span><br><span class="line">                mCardLeft + mCardSpacing, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalidate the whole view. Doing this calls onDraw() if the view is visible.</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可知，这里是直接进行绘制的，此时显示的布局过渡绘制背景如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-943f826a56d2ac0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，图片的背景都叠加起来了，这个时候，我们<strong>需要在绘制的时候使用clipRect让系统去识别可绘制的区域</strong>，因此我们在自定义的DroidCardsView的onDraw方法去使用clipRect：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t draw anything until all the Asynctasks are done and all the DroidCards are ready.</span></span><br><span class="line">    <span class="keyword">if</span> (mDroids.length &gt; <span class="number">0</span> &amp;&amp; mDroidCards.size() == mDroids.length) &#123;</span><br><span class="line">        <span class="comment">// Loop over all the droids, except the last one.</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mDroidCards.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            mCardLeft = i * mCardSpacing;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、clipRect方法和绘制前后成对使用canvas的save方法与restore方法。</span></span><br><span class="line">            canvas.save();</span><br><span class="line">            <span class="comment">// 2、使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。</span></span><br><span class="line"></span><br><span class="line">            canvas.clipRect(mCardLeft,<span class="number">0</span>,mCardLeft+mCardSpacing,mDroidCards.get(i).getHeight());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、Draw the card. Only the parts of the card that lie within the bounds defined by</span></span><br><span class="line">            <span class="comment">// the clipRect() get drawn.</span></span><br><span class="line">            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw the final card. This one doesn&#x27;t get clipped.</span></span><br><span class="line">        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - <span class="number">1</span>),</span><br><span class="line">                mCardLeft + mCardSpacing, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalidate the whole view. Doing this calls onDraw() if the view is visible.</span></span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处，首先需要在clipRect方法和绘制前后成对使用canvas的save方法与restore方法用来对画布进行操作。接着，在注释2处，使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。最后，在注释3处调用实际绘制卡片的方法。</p>
<p>使用clipRect优化过后的布局过渡绘制背景如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-a24122548380bbde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>注意：</strong></p>
<p>我们还可以<strong>通过canvas.quickReject方法来判断是否没和某个矩形相交，以跳过非矩形区域的绘制操作</strong>。</p>
<p>当然，对视图的绘制优化还有其它的一些优化操作，比如：</p>
<ul>
<li>  1、使用ViewStub、Merge，ViewStub是一种高效占位符，用于延迟初始化。</li>
<li>  2、onDraw中避免创建大对象，进行耗时操作。</li>
<li>  3、TextView的优化，比如利用它的drawableLeft属性。此外，也可以<strong>使用Android 9.0之后的 PrecomputedText，它将文件的measure与layout过程进行了异步化</strong>。但是需要注意，如果要显示的文本比较少，反而会造成不必要的Scheduling delay，<strong>建议文本字符大于200时才使用，并记得使用其兼容类PrecomputedTextCompat</strong>，它在9.0以上使用PrecomputedText进行优化，在5.0~9.0使用StaticLayout进行优化。具体调用代码如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(</span><br><span class="line">              “text”, textView.getTextMetricsParamsCompat(), <span class="keyword">null</span>)；</span><br><span class="line">textView.setTextFuture(future);</span><br></pre></td></tr></table></figure>

<p>到这里，笔者就将常规的布局优化讲解完了，是不是顿时感觉实力大增呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-3be183ec60e3f190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>如果你此时内心已经YY到这种程度，那我只能说：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-1d7072ce6db170b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>对于Android的布局优化还有更深入的优化方式吗？</strong></p>
<p>没错，下面，笔者就来和大家一起来探索布局优化的进阶方案。</p>
<h3 id="七、布局优化的进阶方案"><a href="#七、布局优化的进阶方案" class="headerlink" title="七、布局优化的进阶方案"></a>七、布局优化的进阶方案</h3><h4 id="1、使用异步布局框架Litho"><a href="#1、使用异步布局框架Litho" class="headerlink" title="1、使用异步布局框架Litho"></a>1、使用异步布局框架Litho</h4><p>Litho是Facebook开源的一款在Android上高效建立UI的<strong>声明式框架</strong>，它具有以下特点：</p>
<ul>
<li>  声明式：它使用了<strong>声明式的API</strong>来定义UI组件。</li>
<li>  异步布局：它可以<strong>提前布局UI</strong>，而不会阻塞UI线程。</li>
<li>  视图扁平化：它使用了Facebook开源的另一款<strong>布局引擎Yoga进行布局</strong>，以<strong>自动减少UI包含的ViewGroup数量</strong>。</li>
<li>  细粒度的回收：<strong>可以回收文本或图形等任何组件，并可以在用户界面的任何位置重复使用</strong>。</li>
<li>  内部不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。<strong>Litho实现了大量使用Drawable来渲染的基础组件，可以进一步使布局扁平化</strong>。</li>
</ul>
<h5 id="简单使用Litho"><a href="#简单使用Litho" class="headerlink" title="简单使用Litho"></a>简单使用Litho</h5><p>接下来，我们在项目里面来使用Litho。</p>
<p>1、首先，我们需要配置Litho的相关依赖，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 项目下</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module下</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Litho</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.litho:litho-core:0.33.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.litho:litho-widget:0.33.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.facebook.litho:litho-processor:0.33.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SoLoader</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.soloader:soloader:0.5.1&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For integration with Fresco</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.litho:litho-fresco:0.33.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For testing</span></span><br><span class="line">    testImplementation <span class="string">&#x27;com.facebook.litho:litho-testing:0.33.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sections （options，用来声明去构建一个list）</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.litho:litho-sections-core:0.33.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.facebook.litho:litho-sections-widget:0.33.0&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;com.facebook.litho:litho-sections-annotations:0.33.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.facebook.litho:litho-sections-processor:0.33.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、然后，在Application下的onCreate方法中初始化SoLoader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">    SoLoader.init(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从之前的介绍可知，我们知道Litho使用了Yoga进行布局，而Yoga包含有native依赖，在Soloader.init方法中对这些native依赖进行了加载。</p>
<p>3、最后，在Activity的onCreate方法中添加如下代码即可显示单个的文本视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1、将Activity的Context对象保存到ComponentContext中，并同时初始化</span></span><br><span class="line"><span class="comment">// 一个资源解析者实例ResourceResolver供其余组件使用。</span></span><br><span class="line">ComponentContext componentContext = <span class="keyword">new</span> ComponentContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、Text内部使用建造者模式以实现组件属性的链式调用，下面设置的text、</span></span><br><span class="line"><span class="comment">// TextColor等属性在Litho中被称为Prop，此概念引申字React。</span></span><br><span class="line">Text lithoText = Text.create(componentContext)</span><br><span class="line">        .text(<span class="string">&quot;Litho text&quot;</span>)</span><br><span class="line">        .textSizeDip(<span class="number">64</span>)</span><br><span class="line">        .textColor(ContextCompat.getColor(<span class="keyword">this</span>, R.color.light_deep_red))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、设置一个LithoView去展示Text组件：LithoView.create内部新建了一个</span></span><br><span class="line"><span class="comment">// LithoView实例，并用给定的Component（lithoText）进行初始化</span></span><br><span class="line">setContentView(LithoView.create(componentContext, lithoText));</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-1a0b8b768b3aeaa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在上面的示例中，我们仅仅是将Text这个子组件设置给了LithoView，后续为了实现更复杂的布局，我们需要使用带多个子组件的根组件去替换它。</p>
<h5 id="使用自定义Component"><a href="#使用自定义Component" class="headerlink" title="使用自定义Component"></a>使用自定义Component</h5><p>由上可知，在Litho中的视图单元叫做Component，即组件，它的设计理念来源于React组件化的思想。<strong>每个组件持有描述一个视图单元所必须的属性与状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或Drawable）来完成的</strong>。接下来，我们使用Litho提供的自定义Component的功能，它能够让我们实现更复杂的Component，这里我们来实现一个类似ListView的列表。</p>
<p>首先，我们先来实现一个ListItem Component，它就如ListView的itemView一样。在下面的实战中，我们将会学习到所有的基础知识，这将会支撑你后续能实现更多更复杂的Component。</p>
<p>然后，在Litho中，我们需要先写一个Spec类去声明Component所对应的布局，在这里需要使用@LayoutSpec规范注解(除此之外，Litho还提供了另一种类型的组件规范：Mount Spec)。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LayoutSpec</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItemSpec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnCreateLayout</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Component <span class="title">onCreateLayout</span><span class="params">(ComponentContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Column的作用类似于HTML中的&lt;div&gt;标签</span></span><br><span class="line">        <span class="keyword">return</span> Column.create(context)</span><br><span class="line">                .paddingDip(YogaEdge.ALL, <span class="number">16</span>)</span><br><span class="line">                .backgroundColor(Color.WHITE)</span><br><span class="line">                .child(Text.create(context)</span><br><span class="line">                            .text(<span class="string">&quot;Litho Study&quot;</span>)</span><br><span class="line">                            .textSizeSp(<span class="number">36</span>)</span><br><span class="line">                         	.textColor(Color.BLUE)</span><br><span class="line">                            .build())</span><br><span class="line">                .child(Text.create(context)</span><br><span class="line">                            .text(<span class="string">&quot;JsonChao&quot;</span>)</span><br><span class="line">                            .textSizeSp(<span class="number">24</span>)</span><br><span class="line">                         	.textColor(Color.MAGENTA)</span><br><span class="line">                            .build())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，框架会使用APT技术去帮助生成对应的ListItem Component 类。最后，我们在Activity的onCreate中将上述第一个例子中的第二步改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 2、构建ListItem组件</span></span><br><span class="line">ListItem listItem = ListItem.create(componentContext).build();</span><br></pre></td></tr></table></figure>

<p>运行项目，显示界面如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-46387b41d8106624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>那上述过程是如何进行构建的呢？</strong></p>
<p>它看起来就像有一个LithoSpec的类名，并且在项目构建之后生成了一个与LithoSpec有着同样包名的Litho类，如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-df1e2d42fed03778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-c734a954eb92ad9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>类似于Litho这种类中的所有方法参数都会由Litho进行自动填充。此外，基于这些规格，将会有一些额外的方法由注解处理器自动生成，例如上述示例中Column或Row中的Text的TextSizeSp、backgroundColor等方法。(Row和Column分别对应着Flexox中的行和列，它们都实现了Litho中另一种特殊的组件Layout)</p>
<h5 id="补充：MountSpec规范"><a href="#补充：MountSpec规范" class="headerlink" title="补充：MountSpec规范"></a>补充：MountSpec规范</h5><p>MountSpec是用来生成可挂载类型组件的一种规范，它的作用是<strong>用来生成渲染具体的View或者Drawable的组件</strong>。同LayoutSpec类似，它必须使用@MountSpec注解来标注，并实现一个标注了@onCreateMountContent的方法。但是MountSpec的实现要比Layout更加地复杂，因为它拥有自己的生命周期，如下所示：</p>
<ul>
<li>  @OnPrepare：准备阶段，用于进行一些初始化操作。</li>
<li>  @OnMeasure：负责布局的计算工作。</li>
<li>  @OnBoundsDefined：在布局计算完成之后、挂载视图之前做一些操作。</li>
<li>  @OnCreateMountContent：如果没有可以复用的视图单元，则调用它去创建需要挂载的视图。</li>
<li>  @OnMount：挂载视图，用于完成布局相关的设置。</li>
<li>  @OnBind：绑定视图，用于完成数据和视图的绑定。</li>
<li>  @OnUnBind：解绑视图，与@OnBind相对，主要用于重置视图的数据属性，避免出现数据复用的问题。</li>
<li>  @OnUnmount：卸载视图，与@OnMount相对，主要用于重置视图的布局相关的属性，避免出现布局复用的问题。</li>
</ul>
<p>MountSpec的生命周期流转图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-d72c223fc75a66f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在使用Litho完成了两个实例的开发之后，相信我们已经对Litho的布局方式已经有了一个感性的认知。那么，Litho到底是如何进行布局优化的呢？在布局优化中它所做的核心工作有哪些？</p>
<p>Litho在布局优化中所做的核心工作包括以下三点：</p>
<ul>
<li>  1、异步布局化。</li>
<li>  2、布局自动扁平化。</li>
<li>  3、更细粒度地优化RecyclerView中组件的缓存与回收的方法。</li>
</ul>
<h5 id="1、异步布局化"><a href="#1、异步布局化" class="headerlink" title="1、异步布局化"></a>1、异步布局化</h5><p>在前文中，我们知道Android的布局加载过程通常会先后涉及到measure、layout、draw过程，并且它们都是在主线程执行的，如果方法执行过程中耗时太多，则主界面必然会产生卡顿现象。</p>
<p>还记得我们在前面介绍的PrecomputedText，它内部将measure与layout的过程放在了异步线程进行初始化，而Litho与PrecomputedText类似，也是将measre与layout的过程进行了异步化，核心原理就是<strong>利用CPU的闲置时间提前在异步线程中完成measure和layout的过程，仅在UI线程中完成绘制工作</strong>。</p>
<p><strong>那么Android为什么不自己实现异步布局呢？</strong></p>
<p>主要有以下两原因：</p>
<ul>
<li>  1、因为View的属性是可变的，只要属性发生变化就可能导致布局变化，所以需要重新计算布局，那么提前异步去计算布局的意义就不大了。而Litho组件的属性是不可变的，因此它的布局计算结果也是不变的。</li>
<li>  2、提前异步布局需要去提前创建好接下来用到的若干条目的视图，但是Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，这将会大大增加App进程的内存占用。<strong>对于Litho的组件来说，它只是视图属性的一个集合，仅仅负责计算布局，绘制工作由指定的绘制单元来完成</strong>。因此在Litho中，提前创建好下面要用到的多个条目的组件，是不会有性能问题的。两者的绘制原理简图如下所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-86df33c81e36ca76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="2、布局自动扁平化"><a href="#2、布局自动扁平化" class="headerlink" title="2、布局自动扁平化"></a>2、布局自动扁平化</h5><p>经过之前的学习，我们了解到Litho采用了一套自有的布局引擎Yoga，它会在布局的过程中去检测出不必要的布局嵌套层级，并自动去减少多余的层级以实现布局的扁平化，这可以显著减少渲染时的递归调用，加快渲染速度。例如，在实现一个图片带多个文字的布局中，我们通常会至少有两个布局层级，<strong>当然，你也可以使用TextView的drawableStart方法 + 代码动态布局使用Spannable/Html.fromHtml(用来实现多种不同规格的文字) + lineSpaceExtra/lineSpacingMultiplier（用来调整多行文本的显示间距）来将布局层级降为一层</strong>，但是这种实现方式比较繁琐，而通过使用Litho，我们可以把降低布局嵌套层级的任务全部丢给布局引擎Yoga去处理。由前面可知，Litho是使用Flexbox来创建布局的，并最终生成带有层级结构的组件树。通过使用Yoga来进行布局计算，可以使用Flexbox的相对布局变成了只有一层嵌套的绝对布局。相比于ConstraintLayout，对于实现复杂布局的时候可读性会更好一些，因为<strong>ConstraintLayout此时会有过多的约束条件，这会导致可读性变差</strong>。此外，<strong>Litho自身还提供了许多挂载Drawable的基本视图组件，相比Viwe组件使用它们可以显著减少内存占用（通常会减少80%的内存占用）</strong>。Litho实现布局自动扁平化的原理图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-14f3cec2b9c9fd83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"><a href="#3、更细粒度地优化RecyclerView中组件的缓存与回收的方法" class="headerlink" title="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"></a>3、更细粒度地优化RecyclerView中组件的缓存与回收的方法</h5><p>使用了RecyclerView与ListView这么久，我们明白它是以viewType为粒度来对一个组件集合统一进行缓存与回收的，并且，<strong>当viewType的类型越多，其对组件集合的缓存与回收的效果就会越差</strong>。相对于RecyclerView与ListView缓存与回收的粗粒度而言，Litho实现了更细粒度的回收机制，<strong>它是以Text、image、video等单个Component为粒度来作为其基准的</strong>，具体<strong>实现原理</strong>为<strong>在item回收前，会把LithoView中挂载的各个绘制单元进行解绑拆分出来，由Litho自己的缓存池去分类回收，然后在展示前由LithoView按照组件树的样式挂载组装各个绘制单元</strong>，这样就达到了细粒度复用的目的。毫无疑问，这不仅<strong>提高了其缓存的命中率与内存的使用率，也降低了提高了其滚动刷新的频率</strong>。更细粒度复用优化内存的原图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-06860f37097b7022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>由上图可以看出，滑出屏幕的itemType1会被拆分成一个个的视图单元。其中LithoView容器由Recycler缓存池回收，而其他视图单元则由Litho的缓存池分类回收，例如分类为Img缓存池、Text缓存池等等。</p>
<p>现在，我们对Litho已经比较了解了，它似乎很完美，但是任何事物都有其弊端，在学习一个新的事物时，我们<strong>不仅仅只去使用与了解它的优势，更应该对它的缺陷与弊端了如指掌</strong>。Litho在布局的过程中，使用了类似React的单向数据流设计，并且由于Litho是使用代码进行动态布局，这大大增加了布局的复杂度，而且，代码布局是无法实时预览的，这也增加了开发调试时的难度。</p>
<p>综上，对于某些性能性能要求高的场景，可以先使用Litho布局的方式去替换，特别是需要利用好Litho中的RecyclerViewCollectionComponent与sections去充分提升RecylerView的性能。</p>
<p>现在，我们来使用RecyclerViewCollectionComponent与sections去创建一个可滚动的列表单元。</p>
<p>接下来，我们需要使用SectionsAPI，它可以将列表分为多个Section，然后编写GroupSectionSpec注解类来声明每个Section需要呈现的内容及其使用的数据。下面，我们创建一个ListSectoinSpec：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、可以理解为一个组合Sectoin规格</span></span><br><span class="line"><span class="meta">@GroupSectionSpec</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSectionSpec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnCreateChildren</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Children <span class="title">onCreateChildren</span><span class="params">(<span class="keyword">final</span> SectionContext context)</span> </span>&#123;</span><br><span class="line">        Children.Builder builder = Children.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            builder.child(</span><br><span class="line">                   <span class="comment">// 单组件区域用来包含一个特定的组件 </span></span><br><span class="line">                   SingleComponentSection.create(context)</span><br><span class="line">                    .key(String.valueOf(i))</span><br><span class="line">                    .component(ListItem.create(context).build())</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们将MainActivity onCreate方法中的步骤2替换为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2、使用RecyclerCollectionComponent去绘制list</span></span><br><span class="line">   RecyclerCollectionComponent recyclerCollectionComponent = RecyclerCollectionComponent.create(componentContext)</span><br><span class="line">           <span class="comment">// 使下拉刷新实现</span></span><br><span class="line">           .disablePTR(<span class="keyword">true</span>)</span><br><span class="line">           .section(ListSection.create(<span class="keyword">new</span> SectionContext(componentContext)).build())</span><br><span class="line">           .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终的显示效果如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-39283a6ace31dc69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>如果我们需要显示不同UI的ListItem该怎么办呢？</strong></p>
<p>这个时候我们需要去自定义Component的属性，即props，它是一种不可变属性（此外还有一种可变属性称为State，但是其变化是由组件内部进行控制的，例如输入框、Checkbox等都是由组件内部去感知用户的行为，并由此更新组件的State属性），你设置的这些属性将会改变Component的行为或表现。Props是Component Spec中方法的参数，并且使用@Prop注解。</p>
<p>下面，我们使用props将ListItemSpec的onCreateLayout修改为可自定义组件属性的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LayoutSpec</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItemSpec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnCreateLayout</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Component <span class="title">onCreateLayout</span><span class="params">(ComponentContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Prop</span> <span class="keyword">int</span> bacColor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Prop</span> String title,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Prop</span> String subTitle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Prop</span> <span class="keyword">int</span> textSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="meta">@Prop</span> <span class="keyword">int</span> subTextSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Column的作用类似于HTML中的&lt;div&gt;标签</span></span><br><span class="line">        <span class="keyword">return</span> Column.create(context)</span><br><span class="line">                .paddingDip(YogaEdge.ALL, <span class="number">16</span>)</span><br><span class="line">                .backgroundColor(bacColor)</span><br><span class="line">                .child(Text.create(context)</span><br><span class="line">                            .text(title)</span><br><span class="line">                         	.textSizeSp(textSize)</span><br><span class="line">                         	.textColor(Color.BLUE)</span><br><span class="line">                            .build())</span><br><span class="line">                .child(Text.create(context)</span><br><span class="line">                            .text(subTitle)</span><br><span class="line">                         	.textSizeSp(subTextSize)</span><br><span class="line">                         	.textColor(Color.MAGENTA)</span><br><span class="line">                            .build())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奇妙之处就发生在我们所定义的@Prop注解与注解处理器之间，<strong>注解处理器以一种智能的方式对组件构建过程中所关联的属性生成了对应的方法</strong>。</p>
<p>接下来，我们再修改ListSectionSpec类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GroupSectionSpec</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSectionSpec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnCreateChildren</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Children <span class="title">onCreateChildren</span><span class="params">(<span class="keyword">final</span> SectionContext context)</span> </span>&#123;</span><br><span class="line">        Children.Builder builder = Children.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            builder.child(</span><br><span class="line">                    SingleComponentSection.create(context)</span><br><span class="line">                    .key(String.valueOf(i))</span><br><span class="line">                    .component(ListItem.create(context)</span><br><span class="line">                            .bacColor(i % <span class="number">2</span> == <span class="number">0</span> ? Color.BLUE:Color.MAGENTA)</span><br><span class="line">                            .title(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次练习&quot;</span>)</span><br><span class="line">                         	.subTitle(<span class="string">&quot;JsonChao&quot;</span>)</span><br><span class="line">                            .textSize(<span class="number">36</span>)</span><br><span class="line">                            .subTextSize(<span class="number">24</span>)</span><br><span class="line">                            .build())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的显示效果如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-2fcd6fd373a1bdfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>除此之外，我们还可以有更多的方式去定义@Prop，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Prop(optional = true, resType = ResType.DIMEN_OFFSET)</span> <span class="keyword">int</span> shadowRadius,</span><br></pre></td></tr></table></figure>

<p>上面定义了一个可选的Prop，传入的shadowRadius是支持dimen规格的，如px、dp、sp等等。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>使用Litho，在布局性能上有很大的提升，但是开发成本太高，因为需要自己去实现很多的组件，并且其组件需要在编译时才能生成，不能够进行实时预览，但是可以把Litho封装成Flexbox布局的底层渲染引擎，以此实现上层的动态化，具体实现原理可参见<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/19/litho-practice-in-dynamic-program-mtflexbox.html">Litho在美团动态化方案MTFlexbox中的实践</a>。</p>
<h4 id="2、使用Flutter实现高性能的UI布局"><a href="#2、使用Flutter实现高性能的UI布局" class="headerlink" title="2、使用Flutter实现高性能的UI布局"></a>2、使用Flutter实现高性能的UI布局</h4><p>Flutter可以说是2019最火爆的框架之一了，它是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。对于Android来说，FLutter能够创作媲美原生的高性能应用，应用使用 Dart语言进行 开发。Flutter的架构类似于Android的层级架构，每一层都建立在前一层之上，其架构图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-3a77bc2cb936399c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在Framework层中，Flutter通过在 widgets 层组合基础 widgets 来构建 Material 层，而 widgets 层本身则是通过对来自 Rendering 层的低层次对象组合而来。而在Engine层，Flutter集成了Skia引擎用于进行栅格化，并且使用了Dart虚拟机。</p>
<h5 id="那么Flutter的图形性能为何能够媲美原生应用呢？"><a href="#那么Flutter的图形性能为何能够媲美原生应用呢？" class="headerlink" title="那么Flutter的图形性能为何能够媲美原生应用呢？"></a>那么Flutter的图形性能为何能够媲美原生应用呢？</h5><p>接下来，我们以Flutter、原生Android、其它跨平台框架如RN来做比较，它们的图形绘制调用层级图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-6a20b6e21d4d6a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到，Flutter框架的代码完全取代了Java层的框架代码，所以<strong>只要当Flutter框架中Dart代码的效率可以媲美原生框架的Java代码的时候，那么总体的Flutter App的性能就能够媲美原生的APP</strong>。而反观其它流行的跨平台框架如RN，它首先需要调用自身的Js代码，然后再去调用Java层的代码，这里比原生和Flutter的App显然多出来一个步骤，所以它的性能肯定是不及原生的APP的。此外，Flutter App不同于原生、RN，它<strong>内部是直接包含了Skia渲染引擎的，只要Flutter SDK进行升级，Skia就能够升级，这样Skia的性能改进就能够同步到Flutter框架之中</strong>。而对于Android原生和RN来说，只能等到Android系统升级才能同步Skia的性能改进。</p>
<h5 id="而Flutter又是如何实现高性能UI布局的呢？"><a href="#而Flutter又是如何实现高性能UI布局的呢？" class="headerlink" title="而Flutter又是如何实现高性能UI布局的呢？"></a>而Flutter又是如何实现高性能UI布局的呢？</h5><p>接下来，我们来大致了解一下Flutter的UI绘制原理，它主要是<strong>通过VSYNC信号来使UI线程和GPU线程有条不紊的周期性的去渲染界面</strong>，其绘制原理图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14601315-a6a1cde01dbfa649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>绘制步骤大致如下：</p>
<ul>
<li>  1、首先 UI Runner 会执行 root isolate（可简单理解为Dart VM的线程），它会告诉引擎层有帧要渲染，当需要渲染则会调用到Engine的<code>ScheduleFrame()</code>来注册VSYNC信号回调，一旦触发回调<code>doFrame()</code>，并当它执行完成后，便会移除回调方法，也就是说一次注册一次回调。</li>
<li>  2、当需要再次绘制则需要重新调用到<code>ScheduleFrame()</code>方法，该方法的唯一重要参数regenerate_layer_tree决定在帧绘制过程是否需要重新生成layer tree，还是直接复用上一次的layer tree。</li>
<li>  3、接着，执行的是UI线程绘制过程中最核心的WidgetsBinding的<code>drawFrame()</code>方法，然后会创建layer tree视图树。</li>
<li>  4、然后 Layer Tree 会交给 GPU Task Runner 进行合成和栅格化。</li>
<li>  5、最后，GPU Task Runner会利用Skia库结合GL或Vu’lkan将layer tree提供的信息转化为平台可执行的GPU指令。</li>
</ul>
<p>此外，Flutter 也采用了类似 Litho 的props属性不可变、Reat单向数据流的方案，用于将视图与数据分离。对于Flutter这一大前端领域的核心技术，笔者也是充满兴趣，后续会有计划对此进行深入研究，敬请期待。</p>
<h4 id="3、使用RenderThread-与-RenderScript"><a href="#3、使用RenderThread-与-RenderScript" class="headerlink" title="3、使用RenderThread 与 RenderScript"></a>3、使用RenderThread 与 RenderScript</h4><p>在Android 5.0之后，Android引进了<strong>RenderThread</strong>，它能够实现<strong>动画的异步渲染</strong>。但是目前支持RenderThread完全渲染的动画，只有两种，即<strong>ViewPropertyAnimator和CircularReveal（揭露动画）</strong>。对于CircularReveal使用比较简单且功能较为单一，就不多做过多的描述了。下面我简单说下ViewPropertyAnimator中如何去利用RenderThread。</p>
<h5 id="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："><a href="#1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：" class="headerlink" title="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："></a>1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用反射的方式去创建对应View的ViewPropertyAnimatorRT(非hide类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">createViewPropertyAnimatorRT</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;           </span><br><span class="line">        Class&lt;?&gt; animRtClazz = Class.forName(<span class="string">&quot;android.view.ViewPropertyAnimatorRT&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; animRtConstructor = animRtClazz.getDeclaredConstructor(View.class);</span><br><span class="line">        animRtConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object animRt = animRtConstructor.newInstance(view);            </span><br><span class="line">        <span class="keyword">return</span> animRt;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;            </span><br><span class="line">        Log.d(TAG, <span class="string">&quot;创建ViewPropertyAnimatorRT出错,错误信息:&quot;</span> + e.toString());           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："><a href="#2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：" class="headerlink" title="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："></a>2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setViewPropertyAnimatorRT</span><span class="params">(ViewPropertyAnimator animator, Object rt)</span> </span>&#123;       </span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; animClazz = Class.forName(<span class="string">&quot;android.view.ViewPropertyAnimator&quot;</span>);</span><br><span class="line">        Field animRtField = animClazz.getDeclaredField(<span class="string">&quot;mRTBackend&quot;</span>);</span><br><span class="line">        animRtField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        animRtField.set(animator, rt);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;设置ViewPropertyAnimatorRT出错,错误信息:&quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在animator.start()即执行动画开始之前配置的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onStartBeforeConfig</span><span class="params">(ViewPropertyAnimator animator, View view)</span> </span>&#123;</span><br><span class="line">    Object rt = createViewPropertyAnimatorRT(view);</span><br><span class="line">    setViewPropertyAnimatorRT(animator, rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："><a href="#3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：" class="headerlink" title="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："></a>3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewPropertyAnimator animator = v.animate().scaleY(<span class="number">2</span>).setDuration(<span class="number">2000</span>);</span><br><span class="line">AnimHelper.onStartBeforeConfig(animator, v);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure>

<p>当前，如果是做音视频或图像处理的工作，经常需要对图片进行高斯模糊、放大、锐化等操作，但是这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。而图片的变换又涉及大量的计算任务，这个时候我们可以<strong>通过RenderScript去充分利用手机的GPU计算能力，以实现高效的图片处理</strong>。</p>
<p>而RenderScript的工作流程需要经历如下三个步骤：</p>
<ul>
<li>  1、RenderScript运行时API：提供进行运算的API。</li>
<li>  2、反射层：相当于NDK中的JNI胶水代码，它是一些由Android编译工具自动生成的类，对我们写的RenderScript代码进行包装，以使得安卓层能够和RenderScript进行交互。</li>
<li>  3、安卓框架：通过调用反射层来访问RenderScript运行时。</li>
</ul>
<p>由于RenderScript主要是用于音视频、图像处理等细分领域，这里笔者就不继续深入扩展了，对于NDK、音视频领域的知识，笔者在今年会有一系列学习计划，目前大纲已经定制好了，如果有兴趣的朋友，可以了解下：<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-Android-NDK">Awesome-Android-NDK</a>。</p>
<h3 id="八、布局优化的常见问题"><a href="#八、布局优化的常见问题" class="headerlink" title="八、布局优化的常见问题"></a>八、布局优化的常见问题</h3><h4 id="1、你在做布局优化的过程中用到了哪些工具？"><a href="#1、你在做布局优化的过程中用到了哪些工具？" class="headerlink" title="1、你在做布局优化的过程中用到了哪些工具？"></a>1、你在做布局优化的过程中用到了哪些工具？</h4><p>我在做布局优化的过程中，用到了很多的工具，但是每一个工具都有它不同的使用场景，不同的场景应该使用不同的工具。下面我从线上和线下两个角度来进行分析。</p>
<p>比如说，我要统计线上的FPS，我使用的就是Choreographer这个类，它具有以下特性：</p>
<ul>
<li>  1、能够获取整体的帧率。</li>
<li>  2、能够带到线上使用。</li>
<li>  3、它获取的帧率几乎是实时的，能够满足我们的需求。</li>
</ul>
<p>同时，在线下，如果要去优化布局加载带来的时间消耗，那就需要检测每一个布局的耗时，对此我使用的是AOP的方式，它没有侵入性，同时也不需要别的开发同学进行接入，就可以方便地获取每一个布局加载的耗时。如果还要更细粒度地去检测每一个控件的加载耗时，那么就需要使用LayoutInflaterCompat.setFactory2这个方法去进行Hook。</p>
<p>此外，我还使用了LayoutInspector和Systrace这两个工具，Systrace可以很方便地看到每帧的具体耗时以及这一帧在布局当中它真正做了什么。而LayoutInspector可以很方便地看到每一个界面的布局层级，帮助我们对层级进行优化。</p>
<h4 id="2、布局为什么会导致卡顿，你又是如何优化的？"><a href="#2、布局为什么会导致卡顿，你又是如何优化的？" class="headerlink" title="2、布局为什么会导致卡顿，你又是如何优化的？"></a>2、布局为什么会导致卡顿，你又是如何优化的？</h4><p>分析完布局的加载流程之后，我们发现有如下四点可能会导致布局卡顿：</p>
<ul>
<li>  1、首先，系统会将我们的Xml文件通过<strong>IO</strong>的方式映射的方式加载到我们的内存当中，而IO的过程可能会导致卡顿。</li>
<li>  2、其次，布局加载的过程是一个反射的过程，而反射的过程也会可能会导致卡顿。</li>
<li>  3、同时，这个布局的层级如果比较深，那么进行布局遍历的过程就会比较耗时。</li>
<li>  4、最后，不合理的嵌套RelativeLayout布局也会导致重绘的次数过多。</li>
</ul>
<p>对此，我们的优化方式有如下几种：</p>
<ul>
<li>  1、针对布局加载Xml文件的优化，我们使用了异步Inflate的方式，即AsyncLayoutInflater。它的核心原理是在子线程中对我们的Layout进行加载，而加载完成之后会将View通过Handler发送到主线程来使用。所以不会阻塞我们的主线程，加载的时间全部是在异步线程中进行消耗的。而这仅仅是一个从侧面缓解的思路。</li>
<li>  2、后面，我们发现了一个从根源解决上述痛点的方式，即使用X2C框架。它的一个核心原理就是在开发过程我们还是使用的XML进行编写布局，但是在编译的时候它会使用APT的方式将XML布局转换为Java的方式进行布局，通过这样的方式去写布局，它有以下优点：1、它省去了使用IO的方式去加载XML布局的耗时过程。2、它是采用Java代码直接new的方式去创建控件对象，所以它也没有反射带来的性能损耗。这样就从根本上解决了布局加载过程中带来的问题。</li>
<li>  3、然后，我们可以使用ConstraintLayout去减少我们界面布局的嵌套层级，如果原始布局层级越深，它能减少的层级就越多。而使用它也能避免嵌套RelativeLayout布局导致的重绘次数过多。</li>
<li>  4、最后，我们可以使用AspectJ框架（即AOP）和LayoutInflaterCompat.setFactory2的方式分别去建立线下全局的布局加载速度和控件加载速度的监控体系。</li>
</ul>
<h4 id="3、做完布局优化有哪些成果产出？"><a href="#3、做完布局优化有哪些成果产出？" class="headerlink" title="3、做完布局优化有哪些成果产出？"></a>3、做完布局优化有哪些成果产出？</h4><ul>
<li>  1、首先，我们建立了一个体系化的监控手段，这里的体系还指的是线上加线下的一个综合方案，针对线下，我们使用AOP或者ARTHook，可以很方便地获取到每一个布局的加载耗时以及每一个控件的加载耗时。针对线上，我们通过Choreographer.getInstance().postFrameCallback的方式收集到了FPS，这样我们可以知道用户在哪些界面出现了丢帧的情况。</li>
<li>  2、然后，对于布局监控方面，我们设立了FPS、布局加载时间、布局层级等一系列指标。</li>
<li>  3、最后，在每一个版本上线之前，我们都会对我们的核心路径进行一次Review，确保我们的FPS、布局加载时间、布局层级等达到一个合理的状态。</li>
</ul>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>对于Android的布局优化，笔者以一种自顶向下，层层递进的方式和大家一起深入地去探索了Android中如何将布局优化做到极致，其中主要涉及以下八大主题：</p>
<ul>
<li>  1、绘制原理：CPU\GPU、Android图形系统的整体架构、绘制线程、刷新机制。</li>
<li>  2、屏幕适配：OLED 屏幕和 LCD 屏幕的区别、屏幕适配方案。</li>
<li>  3、优化工具：使用Systrace来进行布局优化、利用Layout Inspector来查看视图层级结构、采用Choreographer来获取FPS以及自动化测量 UI 渲染性能的方式（gfxinfo、SurfaceFlinger等dumpsys命令）。</li>
<li>  4、布局加载原理：布局加载源码分析、LayoutInflater.Factory分析。</li>
<li>  5、获取界面布局耗时：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li>
<li>  6、布局优化常规方案：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li>
<li>  7、布局优化的进阶方案：使用异步布局框架Litho、使用Flutter实现高性能的UI布局、使用RenderThread实现动画的异步渲染与 利用RenderScript实现高效的图片处理。</li>
<li>  8、布局优化的常见问题。</li>
</ul>
<p>可以看到，布局优化看似是Android性能优化中最简单的专项优化项，但是笔者却花费了整整三、四万字的篇幅才能比较完整地将其核心知识传授给大家。因此，<strong>不要小看每一个专项优化点，深入进去，必定满载而归</strong>。</p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/308.html">国内Top团队大牛带你玩转Android性能分析与优化 第五章 布局优化</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/80921">极客时间之Android开发高手课 UI优化</a></p>
<p>3、<a target="_blank" rel="noopener" href="http://mobile.zol.com.cn/680/6809348.html">手机屏幕的前世今生 可能比你想的还精彩</a></p>
<p>4、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22263252">OLED 和 LCD 什么区别？</a></p>
<p>5、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826034&idx=1&sn=5e86768d7abc1850b057941cdd003927&chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&scene=21#wechat_redirect">Android 目前稳定高效的UI适配方案</a></p>
<p>6、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect">骚年你的屏幕适配方式该升级了!-smallestWidth 限定符适配方案</a></p>
<p>7、<a target="_blank" rel="noopener" href="https://github.com/ladingwu/dimens_sw">dimens_sw github</a></p>
<p>8、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484502&idx=2&sn=a60ea223de4171dd2022bc2c71e09351&scene=21#wechat_redirect">一种极低成本的Android屏幕适配方式</a></p>
<p>9、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p>
<p>10、<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903697000972295#heading-0">今日头条屏幕适配方案终极版正式发布!</a></p>
<p>11、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b492140a555f">使用Systrace分析UI性能</a></p>
<p>12、<a target="_blank" rel="noopener" href="https://gapid.dev/about/">GAPID-Graphics API Debugger</a></p>
<p>13、<a target="_blank" rel="noopener" href="http://hukai.me/android-performance-render/">Android性能优化之渲染篇</a></p>
<p>14、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qian520ao/article/details/81144167">Android 屏幕绘制机制及硬件加速</a></p>
<p>15、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qian520ao/article/details/81144167">Android 图形处理官方教程</a></p>
<p>16、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20712354">Vulkan - 高性能渲染</a></p>
<p>17、<a target="_blank" rel="noopener" href="https://source.android.com/devices/graphics/arch-vulkan">Android Vulkan Tutorial</a></p>
<p>18、<a target="_blank" rel="noopener" href="https://developer.android.com/training/testing/performance#top_of_page">Test UI performance-gfxinfo</a></p>
<p>19、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7477e381a7ea">使用dumpsys gfxinfo 测UI性能（适用于Android6.0以后）</a></p>
<p>20、<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/view/TextureView">TextureView API</a></p>
<p>21、<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/text/PrecomputedText">PrecomputedText API</a></p>
<p>22、<a target="_blank" rel="noopener" href="https://fblitho.com/docs/tutorial">Litho Tutorial</a></p>
<p>23、<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html">基本功 | Litho的使用及原理剖析</a></p>
<p>24、<a target="_blank" rel="noopener" href="https://flutter.cn/docs/resources/technical-overview">Flutter官方文档中文版</a></p>
<p>25、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av48772383/?spm_id_from=333.788.videocard.0">[Google Flutter 团队出品] 深入了解 Flutter 的高性能图形渲染</a></p>
<p>26、<a target="_blank" rel="noopener" href="http://gityuan.com/2019/06/15/flutter_ui_draw/">Flutter渲染机制—UI线程</a></p>
<p>27、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&=41#wechat_redirect">RenderThread:异步渲染动画</a></p>
<p>28、<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/renderscript/compute">RenderScript官方文档</a></p>
<p>29、<a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&utm_medium=referral">RenderScript :简单而快速的图像处理</a></p>
<p>30、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b72da42e1463">RenderScript渲染利器</a></p>
<hr>
<p>原文作者：jsonchao<br>原文链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904048068395015">https://juejin.im/post/6844904048068395015</a><br>原文来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hzp201314.github.io/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" data-id="ckmlrcyek0004gkufc4mv762g" data-title="布局优化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          卡顿优化
        
      </div>
    </a>
  
  
    <a href="/2021/03/19/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E9%AB%98%E7%BA%A7%E7%AF%87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">内存优化-高级篇</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag">Android架构师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" style="font-size: 10px;">Android架构师</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/23/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/">卡顿优化</a>
          </li>
        
          <li>
            <a href="/2021/03/22/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">布局优化</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E9%AB%98%E7%BA%A7%E7%AF%87/">内存优化-高级篇</a>
          </li>
        
          <li>
            <a href="/2021/03/17/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">内存优化</a>
          </li>
        
          <li>
            <a href="/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">Android启动速度优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Hzp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>