<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Android启动速度优化 | Hzp&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、启动优化的意义八秒定律 如果我们去一家餐厅吃饭，在点餐的时候等了半天都没有服务人员过来，可能就没有耐心等待直接走了。 对于App来说，也是同样如此，如果用户点击App后，App半天都打不开，用户就可能失去耐心卸载应用。 第一体验 启动速度是用户对我们App的第一体验，打开应用后才能去使用其中提供的强大功能，就算我们应用的内部界面设计的再精美，功能再强大，如果启动速度过慢，用户第一印象就会很差。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android启动速度优化">
<meta property="og:url" content="https://hzp201314.github.io/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Hzp&#39;s Blog">
<meta property="og:description" content="一、启动优化的意义八秒定律 如果我们去一家餐厅吃饭，在点餐的时候等了半天都没有服务人员过来，可能就没有耐心等待直接走了。 对于App来说，也是同样如此，如果用户点击App后，App半天都打不开，用户就可能失去耐心卸载应用。 第一体验 启动速度是用户对我们App的第一体验，打开应用后才能去使用其中提供的强大功能，就算我们应用的内部界面设计的再精美，功能再强大，如果启动速度过慢，用户第一印象就会很差。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/14601315-4c485f54c0b2bcdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316190328674.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316192524772.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316201901315.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316200048250.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316202701988.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316202743067.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316203244725.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316205057742.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20210316205921513.png">
<meta property="article:published_time" content="2021-03-16T02:57:00.000Z">
<meta property="article:modified_time" content="2021-03-18T06:30:54.715Z">
<meta property="article:author" content="Hzp">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/14601315-4c485f54c0b2bcdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hzp's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hzp&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hzp201314.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Android启动速度优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2021-03-16T02:57:00.000Z" itemprop="datePublished">2021-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Android启动速度优化
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、启动优化的意义"><a href="#一、启动优化的意义" class="headerlink" title="一、启动优化的意义"></a>一、启动优化的意义</h1><p><strong>八秒定律</strong></p>
<p>如果我们去一家餐厅吃饭，在点餐的时候等了半天都没有服务人员过来，可能就没有耐心等待直接走了。</p>
<p>对于App来说，也是同样如此，<strong>如果用户点击App后，App半天都打不开，用户就可能失去耐心卸载应用</strong>。</p>
<p><strong>第一体验</strong></p>
<p><strong>启动速度是用户对我们App的第一体验</strong>，打开应用后才能去使用其中提供的强大功能，就算我们应用的内部界面设计的再精美，功能再强大，<strong>如果启动速度过慢，用户第一印象就会很差</strong>。</p>
<p>因此，拯救App的启动速度，迫在眉睫。</p>
<span id="more"></span>

<h1 id="思维导图大纲"><a href="#思维导图大纲" class="headerlink" title="思维导图大纲"></a>思维导图大纲</h1><p><img src="https://upload-images.jianshu.io/upload_images/14601315-4c485f54c0b2bcdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>[TOC]</p>
<h1 id="二、应用启动流程"><a href="#二、应用启动流程" class="headerlink" title="二、应用启动流程"></a>二、应用启动流程</h1><h2 id="1-、应用启动的类型"><a href="#1-、应用启动的类型" class="headerlink" title="1 、应用启动的类型"></a>1 、应用启动的类型</h2><p>应用启动的类型总共分为如下三种：</p>
<ul>
<li>  <strong>冷启动</strong></li>
<li>  <strong>热启动</strong></li>
<li>  <strong>温启动</strong></li>
</ul>
<p>下面，我们来详细分析下各个启动类型的特点及流程。</p>
<h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>从点击应用图标到UI界面完全显示且用户可操作的全部过程。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>耗时最多</strong>，衡量标准。</p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>Click Event -&gt; IPC -&gt; Process.start -&gt; ActivityThread -&gt; bindApplication -&gt; LifeCycle -&gt; ViewRootImpl</p>
<p>首先，用户进行了一个点击操作，这个点击事件它会触发一个IPC的操作，之后便会执行到Process的start方法中，这个方法是用于进程创建的，接着，便会执行到ActivityThread的main方法，这个方法可以看做是我们单个App进程的入口，相当于Java进程的main方法，在其中会<strong>执行消息循环的创建与主线程Handler的创建</strong>，创建完成之后，就会执行到 bindApplication 方法，在这里<strong>使用了反射去创建 Application</strong>以及调用了 Application相关的生命周期，Application结束之后，便会执行Activity的生命周期，在Activity生命周期结束之后，<strong>最后，就会执行到 ViewRootImpl，这时才会进行真正的一个页面的绘制</strong>。</p>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>直接从后台切换到前台。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>启动速度<strong>最快</strong>。</p>
<h3 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h3><p>只会重走Activity的生命周期，而不会重走进程的创建，Application的创建与生命周期等。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><strong>较快</strong>，介于冷启动和热启动之间的一个速度。</p>
<h4 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h4><p>LifeCycle -&gt; ViewRootImpl</p>
<h4 id="ViewRootImpl是什么？"><a href="#ViewRootImpl是什么？" class="headerlink" title="ViewRootImpl是什么？"></a>ViewRootImpl是什么？</h4><p>它是GUI管理系统与GUI呈现系统之间的桥梁。<strong>每一个ViewRootImpl关联一个Window， ViewRootImpl 最终会通过它的setView方法绑定Window所对应的View，并通过其performTraversals方法对View进行布局、测量和绘制</strong>。</p>
<h2 id="2、冷启动分析及其优化方向"><a href="#2、冷启动分析及其优化方向" class="headerlink" title="2、冷启动分析及其优化方向"></a>2、冷启动分析及其优化方向</h2><h3 id="冷启动涉及的相关任务"><a href="#冷启动涉及的相关任务" class="headerlink" title="冷启动涉及的相关任务"></a>冷启动涉及的相关任务</h3><h4 id="冷启动之前"><a href="#冷启动之前" class="headerlink" title="冷启动之前"></a>冷启动之前</h4><ul>
<li>  首先，会启动App</li>
<li>  然后，加载空白Window</li>
<li>  最后，创建进程</li>
</ul>
<p>需要注意的是，这些都是系统的行为，一般情况下我们是无法直接干预的。</p>
<h4 id="随后任务"><a href="#随后任务" class="headerlink" title="随后任务"></a>随后任务</h4><ul>
<li>  首先，创建Application</li>
<li>  启动主线程</li>
<li>  创建MainActivity</li>
<li>  加载布局</li>
<li>  布置屏幕</li>
<li>  首帧绘制</li>
</ul>
<p>通常到了<strong>界面首帧绘制完成</strong>后，我们就可以认为<strong>启动已经结束</strong>了。</p>
<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><p>我们的优化方向就是 <strong>Application和Activity的生命周期</strong> 这个阶段，因为这个阶段的时机对于我们来说是<strong>可控的</strong>。</p>
<h1 id="三、启动耗时测量方式"><a href="#三、启动耗时测量方式" class="headerlink" title="三、启动耗时测量方式"></a>三、启动耗时测量方式</h1><h2 id="1、查看Logcat"><a href="#1、查看Logcat" class="headerlink" title="1、查看Logcat"></a>1、查看Logcat</h2><p>在Android Studio Logcat中<strong>过滤关键字“Displayed”</strong>，可以看到对应的冷启动耗时日志。</p>
<h2 id="2、adb-shell-adb命令"><a href="#2、adb-shell-adb命令" class="headerlink" title="2、adb shell(adb命令)"></a>2、adb shell(adb命令)</h2><p>使用adb shell获取应用的启动时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 其中的AppStartActivity全路径可以省略前面的packageName</span><br><span class="line">adb shell am start -W [packageName]/[AppStartActivity全路径]</span><br><span class="line">//eg:adb shell am start -W com.app.demo/com.app.demo.MainActivity</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316190328674.png" alt="image-20210316190328674"></p>
<p>执行后会得到三个时间：ThisTime、TotalTime和WaitTime，详情如下：</p>
<h3 id="ThisTime"><a href="#ThisTime" class="headerlink" title="ThisTime"></a>ThisTime</h3><p>表示最后一个Activity启动耗时。</p>
<h3 id="TotalTime"><a href="#TotalTime" class="headerlink" title="TotalTime"></a>TotalTime</h3><p>表示所有Activity启动耗时。</p>
<h3 id="WaitTime"><a href="#WaitTime" class="headerlink" title="WaitTime"></a>WaitTime</h3><p>表示AMS启动Activity的总耗时。</p>
<p>一般来说，只需查看得到的TotalTime，即应用的启动时间，其包括 <strong>创建进程 + Application初始化 + Activity初始化到界面显示</strong> 的过程。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>  1、<strong>线下使用方便，不能带到线上</strong>。</li>
<li>  2、<strong>非严谨精确的时间</strong>。（应该计算首帧数据，而不是首帧时间）</li>
</ul>
<h2 id="3、代码打点（函数插桩）"><a href="#3、代码打点（函数插桩）" class="headerlink" title="3、代码打点（函数插桩）"></a>3、代码打点（函数插桩）</h2><p>启动时埋点，启动结束埋点，计算二者差值</p>
<p><strong>实战：</strong></p>
<p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：</p>
<ul>
<li>  在上传数据到服务器时<strong>建议根据用户ID的尾号来抽样上报</strong>。</li>
<li>  在项目中<strong>核心基类的关键回调函数和核心方法</strong>中加入打点。</li>
</ul>
<p>其代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 耗时监视器对象，记录整个过程的耗时情况，可以用在很多需要统计的地方，比如Activity的启动耗时和Fragment的启动耗时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = TimeMonitor.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMonitord = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一个耗时统计模块的各种耗时，tag对应某一个阶段的时间</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Long&gt; mTimeTag = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMonitor</span><span class="params">(<span class="keyword">int</span> mMonitorId)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;init TimeMonitor id: &quot;</span> + mMonitorId);</span><br><span class="line">        <span class="keyword">this</span>.mMonitorId = mMonitorId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonitorId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMonitorId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次重新启动都把前面的数据清除，避免统计错误的数据</span></span><br><span class="line">        <span class="keyword">if</span> (mTimeTag.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	mTimeTag.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mStartTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每打一次点，记录某个tag的耗时</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordingTimeTag</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若保存过相同的tag，先清除</span></span><br><span class="line">        <span class="keyword">if</span> (mTimeTag.get(tag) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimeTag.remove(tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - mStartTime;</span><br><span class="line">        Log.d(TAG, tag + <span class="string">&quot;: &quot;</span> + time);</span><br><span class="line">        mTimeTag.put(tag, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(String tag, <span class="keyword">boolean</span> writeLog)</span> </span>&#123;</span><br><span class="line">        recordingTimeTag(tag);</span><br><span class="line">        end(writeLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="keyword">boolean</span> writeLog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (writeLog) &#123;</span><br><span class="line">            <span class="comment">//写入到本地文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashMap&lt;String, Long&gt; <span class="title">getTimeTags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTimeTag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了<strong>使代码更好管理</strong>，我们需要定义一个<strong>打点配置类</strong>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打点配置类，用于统计各阶段的耗时，便于代码的维护和管理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeMonitorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用启动耗时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIME_MONITOR_ID_APPLICATION_START = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，耗时统计可能会在多个模块和类中需要打点，所以需要一个<strong>单例类来管理各个耗时统计的数据</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 采用单例管理各个耗时统计的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeMonitorManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeMonitorManager mTimeMonitorManager = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, TimeMonitor&gt; mTimeMonitorMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> TimeMonitorManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTimeMonitorManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimeMonitorManager = <span class="keyword">new</span> TimeMonitorManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mTimeMonitorManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMonitorManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mTimeMonitorMap = <span class="keyword">new</span> HashMap&lt;Integer, TimeMonitor&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化打点模块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetTimeMonitor</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTimeMonitorMap.get(id) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimeMonitorMap.remove(id);</span><br><span class="line">        &#125;</span><br><span class="line">        getTimeMonitor(id).startMonitor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取打点器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeMonitor <span class="title">getTimeMonitor</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        TimeMonitor monitor = mTimeMonitorMap.get(id);</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = <span class="keyword">new</span> TimeMonitor(id);</span><br><span class="line">            mTimeMonitorMap.put(id, monitor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monitor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要在以下几个方面需要打点：</p>
<ul>
<li>  <strong>应用程序的生命周期节点</strong>。</li>
<li>  <strong>启动时需要初始化的重要方法</strong>，例如数据库初始化，读取本地的一些数据。</li>
<li>  <strong>其他耗时的一些算法</strong>。</li>
</ul>
<p>例如，启动时在Application和第一个Activity加入打点统计：</p>
<h3 id="Application-打点"><a href="#Application-打点" class="headerlink" title="Application 打点"></a>Application 打点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    <span class="comment">//初始化 并开启计时</span></span><br><span class="line">    TimeMonitorManager.getInstance().resetTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    SoLoader.init(<span class="keyword">this</span>, <span class="comment">/* native exopackage */</span> <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//结束计时</span></span><br><span class="line">	TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span><br><span class="line">    	.recordingTimeTag(<span class="string">&quot;Application-onCreate&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一个Activity打点"><a href="#第一个Activity打点" class="headerlink" title="第一个Activity打点"></a>第一个Activity打点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span><br><span class="line">    	.recordingTimeTag(<span class="string">&quot;SplashActivity-onCreate&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    initData();</span><br><span class="line"></span><br><span class="line">    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span><br><span class="line">    		.recordingTimeTag(<span class="string">&quot;SplashActivity-onCreate-Over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START)</span><br><span class="line">    	.end(<span class="string">&quot;SplashActivity-onStart&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p><strong>精确，可带到线上，但是代码有侵入性，修改成本高</strong>。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>  1、在上传数据到服务器时<strong>建议根据用户ID的尾号来抽样上报</strong>。</p>
</li>
<li><p>2、<strong>onWindowFocusChanged只是首帧时间，App启动完成的结束点应该是真实数据展示出来的时候（通常来说都是首帧数据），如列表第一条数据展示，记得使用getViewTreeObserver().addOnPreDrawListener()（在API 16以上可以使用addOnDrawListener），它会把任务延迟到列表显示后再执行</strong>，例如，在项目主页的RecyclerView列表，启动结束的时间就是列表的首帧时间，也即列表第一条数据展示的时候。这里，我们直接在RecyclerView的适配器ArticleListAdapter的convert（onBindViewHolder）方法中加上如下代码即可：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mHasRecorded:是否统计过，统计过就不统计了</span></span><br><span class="line"><span class="comment">//是否是第一条数据</span></span><br><span class="line"><span class="keyword">if</span> (helper.getLayoutPosition() == <span class="number">1</span> &amp;&amp; !mHasRecorded) &#123;</span><br><span class="line">      mHasRecorded = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//addOnDrawListener要求API16+</span></span><br><span class="line">      helper.getView(R.id.item_search_pager_group).getViewTreeObserver()</span><br><span class="line">      	.addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              helper.getView(R.id.item_search_pager_group).getViewTreeObserver()</span><br><span class="line">              	.removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//结束统计</span></span><br><span class="line">              LogHelper.i(<span class="string">&quot;FeedShow&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="为什么不使用onWindowFocusChanged这个方法作为启动结束点？"><a href="#为什么不使用onWindowFocusChanged这个方法作为启动结束点？" class="headerlink" title="为什么不使用onWindowFocusChanged这个方法作为启动结束点？"></a>为什么不使用onWindowFocusChanged这个方法作为启动结束点？</h4><p>因为用户看到真实的界面是需要有网络请求返回真实数据的，但是onWindowFocusChanged只是界面绘制的<strong>首帧时间</strong>，但是列表中的数据是需要从网络中下载得到的，所以应该以列表的<strong>首帧数据</strong>作为启动结束点。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316192524772.png" alt="首帧时间与首帧数据耗时对比"></p>
<h2 id="4、AOP-Aspect-Oriented-Programming-打点"><a href="#4、AOP-Aspect-Oriented-Programming-打点" class="headerlink" title="4、AOP(Aspect Oriented Programming) 打点"></a>4、AOP(Aspect Oriented Programming) 打点</h2><p>面向切面编程，<strong>通过预编译和运行期动态代理实现程序功能统一维护</strong>的一种技术。</p>
<h3 id="4-1、作用"><a href="#4-1、作用" class="headerlink" title="4.1、作用"></a>4.1、作用</h3><p>利用AOP可<strong>以对业务逻辑的各个部分进行隔离</strong>，从而使得业务逻辑各部分之间的<strong>耦合性降低</strong>，<strong>提高程序的可重用性</strong>，同时大大<strong>提高了开发效率</strong>。</p>
<h3 id="4-2、AOP核心概念"><a href="#4-2、AOP核心概念" class="headerlink" title="4.2、AOP核心概念"></a>4.2、AOP核心概念</h3><h4 id="1、横切关注点"><a href="#1、横切关注点" class="headerlink" title="1、横切关注点"></a>1、横切关注点</h4><p>对哪些方法进行拦截，拦截后怎么处理。</p>
<h4 id="2、切面（Aspect）"><a href="#2、切面（Aspect）" class="headerlink" title="2、切面（Aspect）"></a>2、切面（Aspect）</h4><p>类是对物体特征的抽象，<strong>切面就是对横切关注点的抽象</strong>。</p>
<h4 id="3、连接点（JoinPoint）"><a href="#3、连接点（JoinPoint）" class="headerlink" title="3、连接点（JoinPoint）"></a>3、连接点（JoinPoint）</h4><p>被拦截到的点（方法、字段、构造器）。</p>
<h4 id="4、切入点（PointCut）"><a href="#4、切入点（PointCut）" class="headerlink" title="4、切入点（PointCut）"></a>4、切入点（PointCut）</h4><p>对JoinPoint进行拦截的定义。哪些需要拦截，拦截条件</p>
<h4 id="5、通知（Advice）"><a href="#5、通知（Advice）" class="headerlink" title="5、通知（Advice）"></a>5、通知（Advice）</h4><p><strong>拦截到JoinPoint后要执行的代码</strong>，分为<strong>Before前置、After后置、Around环绕</strong>三种类型。</p>
<h3 id="4-3、准备：接入AspectJx进行切面编码"><a href="#4-3、准备：接入AspectJx进行切面编码" class="headerlink" title="4.3、准备：接入AspectJx进行切面编码"></a>4.3、准备：接入AspectJx进行切面编码</h3><p>首先，为了在Android使用AOP埋点需要引入AspectJ，在项目根目录的build.gradle下加入：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">&#x27;com.hujiang.aspectjx:gradle-android-plugin- aspectjx:2.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，在app目录下的build.gradle下加入：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;android-aspectjx&#x27;</span></span><br><span class="line">implement <span class="string">&#x27;org.aspectj:aspectjrt:1.8.+&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4、AOP埋点实战"><a href="#4-4、AOP埋点实战" class="headerlink" title="4.4、AOP埋点实战"></a>4.4、AOP埋点实战</h3><p>JoinPoint一般定位在如下位置</p>
<ul>
<li>  1、<strong>函数调用</strong></li>
<li>  2、<strong>获取、设置变量</strong></li>
<li>  3、<strong>类初始化</strong></li>
</ul>
<p><strong>使用PointCut对我们指定的连接点进行拦截，通过Advice，就可以拦截到JoinPoint后要执行的代码</strong>。Advice通常有以下几种类型：</p>
<ul>
<li>  1、<strong>Before</strong>：PointCut之前执行</li>
<li>  2、<strong>After</strong>：PointCut之后执行</li>
<li>  3、<strong>Around</strong>：PointCut之前、之后分别执行</li>
</ul>
<p>首先，我们举一个小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* android.app.Activity.on**(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCalled</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 execution 中的是一个匹配规则</strong>，第一个 * 代表<strong>匹配任意的方法返回值</strong>，后面的语法代码<strong>匹配所有Activity中on开头的方法</strong>。</p>
<p>其中execution是处理Join Point的类型，在AspectJx中共有两种类型，如下所示：</p>
<ul>
<li>  1、<strong>call</strong>：插入在函数体里面</li>
<li>  2、<strong>execution</strong>：插入在函数体外面</li>
</ul>
<h4 id="如何统计Application中的所有方法耗时？"><a href="#如何统计Application中的所有方法耗时？" class="headerlink" title="如何统计Application中的所有方法耗时？"></a>如何统计Application中的所有方法耗时？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call (* com.demo.application.BaseApplication.**(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//方法名</span></span><br><span class="line">        String name = signature.toShortString();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行目标方法</span></span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算耗时时间</span></span><br><span class="line">        Log.i(TAG, name + <span class="string">&quot; cost&quot;</span> +     (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们需要注意 <strong>不同的Action类型其对应的方法入参是不同的</strong>，具体的差异如下所示：</p>
<ul>
<li>  当Action为<strong>Before、After</strong>时，方法入参为<strong>JoinPoint</strong>。</li>
<li>  当Action为<strong>Around</strong>时，方法入参为<strong>ProceedingPoint</strong>。</li>
</ul>
<h4 id="Around和Before、After的最大区别"><a href="#Around和Before、After的最大区别" class="headerlink" title="Around和Before、After的最大区别:"></a>Around和Before、After的最大区别:</h4><p><strong>ProceedingPoint</strong>不同于JoinPoint，其<strong>提供了proceed方法执行目标方法</strong>。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316201901315.png" alt="image-20210316201901315"></p>
<h3 id="4-5、总结AOP特性"><a href="#4-5、总结AOP特性" class="headerlink" title="4.5、总结AOP特性"></a>4.5、总结AOP特性</h3><ul>
<li>  1、<strong>无侵入性</strong></li>
<li>  2、<strong>修改方便，建议使用</strong></li>
</ul>
<h2 id="5、启动速度分析工具-—-TraceView"><a href="#5、启动速度分析工具-—-TraceView" class="headerlink" title="5、启动速度分析工具 — TraceView"></a>5、启动速度分析工具 — TraceView</h2><h3 id="5-1、使用方式"><a href="#5-1、使用方式" class="headerlink" title="5.1、使用方式"></a>5.1、使用方式</h3><ul>
<li>  1、代码中添加：<code>Debug.startMethodTracing(&quot;App&quot;)</code>、检测方法、<code>Debug.stopMethodTracing()</code>。文件生成位置sd卡:/Android/data/packagename/files/App.trace（需要<strong>使用adb pull将生成的.trace文件导出到电脑，然后使用Android Studio的Profiler进行加载</strong>，也可以直接在device file explorer里面双击打开）</li>
<li>  2、打开 <strong>Profiler CPU -&gt; 点击 Record -&gt; 点击 Stop -&gt; 查看Profiler下方Top Down/Bottom Up 区域</strong>，以找出<strong>耗时的热点方法</strong>。</li>
</ul>
<h3 id="5-2、Profile-CPU"><a href="#5-2、Profile-CPU" class="headerlink" title="5.2、Profile CPU"></a>5.2、Profile CPU</h3><p>使用 Profile 的 CPU 模块可以帮我们快速找到耗时的热点方法，下面，我们来详细来分析一下这个模块。</p>
<h3 id="5-2-1、Trace-types"><a href="#5-2-1、Trace-types" class="headerlink" title="5.2.1、Trace types"></a>5.2.1、Trace types</h3><p>Trace types 有四种，如下所示。</p>
<p><strong>1、Trace Java Methods</strong></p>
<p>会记录每个方法的时间、CPU信息。对运行时性能影响较大。</p>
<p><strong>2、Sample Java Methods</strong></p>
<p>相比于Trace Java Methods会记录每个方法的时间、CPU信息，它<strong>会在应用的Java代码执行期间频繁捕获应用的调用堆栈</strong>，对运行时性能的影响比较小，<strong>能够记录更大的数据区域</strong>。</p>
<p><strong>3、Sample C/C++ Functions</strong></p>
<p>需部署到<strong>Android 8.0及以上</strong>设备，<strong>内部使用simpleperf跟踪应用的native代码</strong>，也可以命令行使用simpleperf。</p>
<p><strong>4、Trace System Calls</strong></p>
<ul>
<li>  检查<strong>应用与系统资源的交互情况</strong>。</li>
<li>  查看所有<strong>核心的CPU瓶颈</strong>。</li>
<li>  <strong>内部采用systrace</strong>，也可以使用systrace命令。</li>
</ul>
<h3 id="5-2-2、Event-timeline"><a href="#5-2-2、Event-timeline" class="headerlink" title="5.2.2、Event timeline"></a>5.2.2、Event timeline</h3><p>用于显示<strong>应用程序在其生命周期中转换不同状态的活动</strong>，如用户交互、屏幕旋转事件等。</p>
<h3 id="5-2-3、CPU-timeline"><a href="#5-2-3、CPU-timeline" class="headerlink" title="5.2.3、CPU timeline"></a>5.2.3、CPU timeline</h3><p>用于显示应用程序 <strong>实时CPU使用率、其它进程实时CPU使用率、应用程序使用的线程总数</strong>。</p>
<h3 id="5-2-4、Thread-activity-timeline"><a href="#5-2-4、Thread-activity-timeline" class="headerlink" title="5.2.4、Thread activity timeline"></a>5.2.4、Thread activity timeline</h3><p><strong>列出应用程序进程中的每个线程</strong>，并<strong>使用了不同的颜色在其时间轴上指示其活动</strong>。</p>
<ul>
<li>  <strong>绿色</strong>：线程处于<strong>活动状态</strong>或<strong>准备好使用CPU</strong>。</li>
<li>  <strong>黄色</strong>：线程正<strong>等待IO</strong>操作。（重要）</li>
<li>  <strong>灰色</strong>：线程正在<strong>睡眠</strong>，<strong>不消耗CPU时间</strong>。</li>
</ul>
<h3 id="5-2-5、检查跟踪数据窗口"><a href="#5-2-5、检查跟踪数据窗口" class="headerlink" title="5.2.5、检查跟踪数据窗口"></a>5.2.5、检查跟踪数据窗口</h3><p>Profile提供的检查跟踪数据窗口有四种，如下所示：</p>
<p>**1、Call Chart **</p>
<p>提供函数跟踪数据的图形表示形式。</p>
<ul>
<li>  <strong>水平轴</strong>：表示<strong>调用的时间段和时间</strong>。</li>
<li>  <strong>垂直轴</strong>：显示<strong>被调用方</strong>。</li>
<li>  <strong>橙色</strong>：<strong>系统API</strong>。</li>
<li>  <strong>绿色</strong>：<strong>应用自有方法</strong>。</li>
<li>  <strong>蓝色</strong>：<strong>第三方API</strong>（包括<strong>Java API</strong>）。</li>
</ul>
<p><strong>提示</strong></p>
<p>右键点击 Jump to source 跳转至指定函数。</p>
<p><strong>2、Flame Chart</strong> </p>
<p><strong>将具有相同调用方顺序的完全相同的方法收集起来</strong>。</p>
<ul>
<li>  <strong>水平轴</strong>：<strong>执行每个方法的相对时间量</strong>。</li>
<li>  <strong>垂直轴</strong>：显示<strong>被调用方</strong>。</li>
</ul>
<p><strong>使用技巧</strong></p>
<p>看<strong>顶层</strong>的<strong>哪个函数占据的宽度最大（表现为平顶）</strong>，可能<strong>存在性能问题</strong>。</p>
<p><strong>3、Top Down</strong></p>
<ul>
<li><p><strong>递归调用列表</strong>，提供<strong>self、children、total时间和比率来表示被调用的函数信息</strong>。total=self+children</p>
<p>total time:执行方法总时间；self time:自身执行时间，除去内部函数时间；children time:内部函数的时间</p>
</li>
<li><p>  <strong>Flame Chart是Top Down列表数据的图形化</strong>。</p>
</li>
</ul>
<p><strong>4、Bottom Up</strong></p>
<ul>
<li>  <strong>展开函数会显示其调用方</strong>。</li>
<li>  <strong>按照消耗CPU时间由多到少的顺序对函数排序</strong>。</li>
</ul>
<p><strong>注意事项</strong></p>
<p>我们在查看上面4个跟踪数据的区域时，应该注意右侧的两个时间，如下所示：</p>
<ul>
<li>  <strong>Wall Clock Time</strong>：<strong>程序执行时间</strong>。</li>
<li>  <strong>Thread Time</strong>：<strong>CPU执行的时间</strong>。</li>
</ul>
<h3 id="5-3、TraceView小结"><a href="#5-3、TraceView小结" class="headerlink" title="5.3、TraceView小结"></a>5.3、TraceView小结</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>  1、<strong>图形的形式展示执行时间、调用栈</strong>等。</li>
<li>  2、<strong>信息全面，包含所有线程</strong>。</li>
<li>  3、<strong>运行时开销严重，整体都会变慢</strong>，得出的<strong>结果并不真实</strong>。</li>
<li>  4、<strong>找到最耗费时间的路径：Flame Chart、Top Down</strong>。</li>
<li>  5、<strong>找到最耗费时间的节点：Bottom Up</strong>。</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主要做热点分析，用来得到以下两种数据：</p>
<ul>
<li>  <strong>单次执行最耗时的方法</strong>。</li>
<li>  <strong>执行次数最多的方法</strong>。</li>
</ul>
<h2 id="6、启动速度分析工具-—-Systrace"><a href="#6、启动速度分析工具-—-Systrace" class="headerlink" title="6、启动速度分析工具 — Systrace"></a>6、启动速度分析工具 — Systrace</h2><h3 id="1、使用方式：代码插桩"><a href="#1、使用方式：代码插桩" class="headerlink" title="1、使用方式：代码插桩"></a>1、使用方式：代码插桩</h3><p>首先，我们可以定义一个Trace静态工厂类，将<code>TraceCompat.begainSection()</code>，<code>TraceCompat.endSection()</code>封装成i、o方法，然后再在想要分析的方法前后进行插桩即可。</p>
<p>然后，在命令行下执行systrace.py脚本，命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /Android/sdk/platform-tools/systrace/systrace.py -t 20 sched gfx view wm am app webview -a &quot;com.packagename&quot; -o ~/Documents/open-project/systrace_data/start_1.html</span><br></pre></td></tr></table></figure>

<p>具体参数含义如下：</p>
<ul>
<li>  -t：指定统计时间为20s。</li>
<li>  shced：cpu调度信息。</li>
<li>  gfx：图形信息。</li>
<li>  view：视图。</li>
<li>  wm：窗口管理。</li>
<li>  am：活动管理。</li>
<li>  app：应用信息。</li>
<li>  webview：webview信息。</li>
<li>  -a：指定目标应用程序的包名。</li>
<li>  -o：生成的systrace.html文件。</li>
</ul>
<h4 id="如何查看数据？"><a href="#如何查看数据？" class="headerlink" title="如何查看数据？"></a>如何查看数据？</h4><p>在<strong>UIThread</strong>一栏可以看到<strong>核心的系统方法时间区域</strong>和我们自己使用<strong>代码插桩捕获的方法时间区域</strong>。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316200048250.png" alt="image-20210316200048250"></p>
<h3 id="2、Systrace原理"><a href="#2、Systrace原理" class="headerlink" title="2、Systrace原理"></a>2、Systrace原理</h3><ul>
<li>  首先，<strong>在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label）</strong>。</li>
<li>  然后，<strong>通过Label的开始和结束来确定某个核心过程的执行时间，并把这些Label信息收集起来得到系统关键路径的运行时间信息，最后得到整个系统的运行性能信息</strong>;</li>
</ul>
<p>其中，Android Framework 里面一些重要的模块都插入了label信息，用户App中也可以添加自定义的Label。</p>
<h3 id="3、Systrace小结"><a href="#3、Systrace小结" class="headerlink" title="3、Systrace小结"></a>3、Systrace小结</h3><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>轻量级，开销小</p>
</li>
<li><p>直观反映CPU利用率</p>
</li>
<li><p>  结合<strong>Android内核的数据</strong>，生成<strong>Html</strong>报告。</p>
</li>
<li><p>  <strong>系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多</strong>。</p>
</li>
<li><p>  <strong>必须手动缩小范围</strong>，会帮助你<strong>加速收敛问题的分析过程</strong>，进而<strong>快速地定位和解决问题</strong>。</p>
</li>
</ul>
<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p>主要用于<strong>分析绘制性能方面的问题</strong>。</p>
</li>
<li><p>分析<strong>系统关键方法和应用方法耗时</strong>。</p>
</li>
</ul>
<p><strong>注意事项</strong>：cpu time 与 wall time 区别</p>
<ul>
<li><strong>cpu time</strong> 是代码消耗cpu时间(<strong>重点指标</strong>)</li>
<li><strong>wall time</strong> 是代码执行时间 eg:锁冲突</li>
</ul>
<h2 id="7、启动监控"><a href="#7、启动监控" class="headerlink" title="7、启动监控"></a>7、启动监控</h2><h3 id="1、实验室监控：视频录制"><a href="#1、实验室监控：视频录制" class="headerlink" title="1、实验室监控：视频录制"></a>1、实验室监控：视频录制</h3><ul>
<li>  80%绘制</li>
<li>  图像识别</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>覆盖高中低端机型不同的场景。</p>
<h3 id="2、线上监控"><a href="#2、线上监控" class="headerlink" title="2、线上监控"></a>2、线上监控</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>需要准确地统计启动耗时。</p>
<h4 id="1、启动结束的统计时机"><a href="#1、启动结束的统计时机" class="headerlink" title="1、启动结束的统计时机"></a>1、启动结束的统计时机</h4><p>是否是使用界面显示且用户真正可以操作的时间作为启动结束时间。</p>
<h4 id="2、启动时间扣除逻辑"><a href="#2、启动时间扣除逻辑" class="headerlink" title="2、启动时间扣除逻辑"></a>2、启动时间扣除逻辑</h4><p>闪屏、广告和新手引导这些时间都应该从启动时间里扣除。</p>
<h4 id="3、启动排除逻辑"><a href="#3、启动排除逻辑" class="headerlink" title="3、启动排除逻辑"></a>3、启动排除逻辑</h4><p>Broadcast、Server拉起，启动过程进入后台都需要排除统计。</p>
<h4 id="4、使用什么指标来衡量启动速度的快慢？"><a href="#4、使用什么指标来衡量启动速度的快慢？" class="headerlink" title="4、使用什么指标来衡量启动速度的快慢？"></a>4、使用什么指标来衡量启动速度的快慢？</h4><h5 id="平均启动时间的问题"><a href="#平均启动时间的问题" class="headerlink" title="平均启动时间的问题"></a>平均启动时间的问题</h5><p>一些体验很差的用户很可能被平均了。</p>
<h5 id="建议的指标"><a href="#建议的指标" class="headerlink" title="建议的指标"></a>建议的指标</h5><ul>
<li>  1、快开慢开比</li>
</ul>
<p>如2s快开比，5s慢开比，可以看到<strong>有多少比例的用户体验好，多少比例的用户比较糟糕</strong>。</p>
<ul>
<li>  2、90%用户的启动时间</li>
</ul>
<p>如果90%用户的启动时间都小于5s，那么90%区间的启动耗时就是5s。</p>
<h4 id="5、启动的类型有哪几种？"><a href="#5、启动的类型有哪几种？" class="headerlink" title="5、启动的类型有哪几种？"></a>5、启动的类型有哪几种？</h4><ul>
<li>  首次安装启动</li>
<li>  覆盖安装启动</li>
<li>  冷启动（指标）</li>
<li>  热启动（反映程序的活跃或保活能力）</li>
</ul>
<p>借鉴Facebook的 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo">profilo</a> 工具原理，对启动整个流程进行耗时监控，在后台对不同的版本做自动化对比，监控新版本是否有新增耗时的函数。</p>
<h1 id="四、启动优化常规方案"><a href="#四、启动优化常规方案" class="headerlink" title="四、启动优化常规方案"></a>四、启动优化常规方案</h1><h3 id="启动过程中的常见问题"><a href="#启动过程中的常见问题" class="headerlink" title="启动过程中的常见问题"></a>启动过程中的常见问题</h3><ul>
<li>  1、<strong>点击图标很久都不响应</strong>：预览窗口被禁用或设置为透明。</li>
<li>  2、<strong>首页显示太慢</strong>：初始化任务太多。</li>
<li>  3、<strong>首页显示后无法进行操作</strong>：太多延迟初始化任务占用主线程CPU时间片。</li>
</ul>
<h3 id="优化区域"><a href="#优化区域" class="headerlink" title="优化区域"></a>优化区域</h3><p>Application、Activity创建以及回调等过程。</p>
<h2 id="1、Theme主题切换"><a href="#1、Theme主题切换" class="headerlink" title="1、Theme主题切换"></a>1、Theme主题切换</h2><p><strong>使用Activity的windowBackground主题属性预先设置一个启动图片</strong>（layer-list实现），在启动后，在Activity的onCreate()方法中的<code>super.onCreate()</code>前再<code>setTheme(R.style.AppTheme)</code>。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316202701988.png" alt="image-20210316202701988"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316202743067.png" alt="image-20210316202743067"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>  使用<strong>简单</strong>。</li>
<li>  <strong>避免了启动白屏和点击启动图标不响应的情况</strong>。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>  <strong>治标不治本</strong>，表面上产生一种快的感觉。</li>
<li>  <strong>对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验</strong>。</li>
</ul>
<h2 id="2、第三方库懒加载"><a href="#2、第三方库懒加载" class="headerlink" title="2、第三方库懒加载"></a>2、第三方库懒加载</h2><p>按需初始化，特别是<strong>针对于一些应用启动时不需要初始化的库</strong>，可以等到用时才进行加载。</p>
<h2 id="3、异步初始化预备知识-线程优化"><a href="#3、异步初始化预备知识-线程优化" class="headerlink" title="3、异步初始化预备知识-线程优化"></a>3、异步初始化预备知识-线程优化</h2><h3 id="3-1、Android线程调度原理剖析"><a href="#3-1、Android线程调度原理剖析" class="headerlink" title="3.1、Android线程调度原理剖析"></a>3.1、Android线程调度原理剖析</h3><h4 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h4><ul>
<li>  1、任意时刻，<strong>只有一个线程占用CPU，处于运行状态</strong>。</li>
<li>  2、多线程并发，轮流获取CPU使用权。</li>
<li>  3、JVM负责线程调度，按照特定机制分配CPU使用权。</li>
</ul>
<h4 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h4><h5 id="1、分时调度模型"><a href="#1、分时调度模型" class="headerlink" title="1、分时调度模型"></a>1、分时调度模型</h5><p>轮流获取、均分CPU。</p>
<h5 id="2、抢占式调度模型"><a href="#2、抢占式调度模型" class="headerlink" title="2、抢占式调度模型"></a>2、抢占式调度模型</h5><p>优先级高的获取。</p>
<h4 id="如何干预线程调度？"><a href="#如何干预线程调度？" class="headerlink" title="如何干预线程调度？"></a>如何干预线程调度？</h4><p>设置线程优先级。</p>
<h4 id="Android线程调度"><a href="#Android线程调度" class="headerlink" title="Android线程调度"></a>Android线程调度</h4><h5 id="1、nice值"><a href="#1、nice值" class="headerlink" title="1、nice值"></a>1、nice值</h5><ul>
<li>  Process中定义。</li>
<li>  值越小，优先级越高。</li>
<li>  默认是THREAD_PRIORITY_DEFAUT，0。</li>
</ul>
<h5 id="2、cgroup"><a href="#2、cgroup" class="headerlink" title="2、cgroup"></a>2、cgroup</h5><p>它是一种更严格的群组调度策略，主要分为如下两种类型：</p>
<ul>
<li>  后台group（默认）。</li>
<li>  前台group，保证前台线程可以获取到更多的CPU</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>  <strong>线程过多会导致CPU频繁切换，降低线程运行效率</strong>。</li>
<li>  <strong>正确认识任务重要性以决定使用哪种线程优先级</strong>。</li>
<li>  优先级具有继承性。</li>
</ul>
<h3 id="3-2、Android异步方式"><a href="#3-2、Android异步方式" class="headerlink" title="3.2、Android异步方式"></a>3.2、Android异步方式</h3><h4 id="1、Thread"><a href="#1、Thread" class="headerlink" title="1、Thread"></a>1、Thread</h4><ul>
<li>  最简单、常见的异步方式。</li>
<li>  不易复用，频繁创建及销毁开销大。</li>
<li>  复杂场景不易使用。</li>
</ul>
<h4 id="2、HandlerThread"><a href="#2、HandlerThread" class="headerlink" title="2、HandlerThread"></a>2、HandlerThread</h4><ul>
<li>  自带消息循环的线程。</li>
<li>  串行执行。</li>
<li>  长时间运行，不断从队列中获取任务。</li>
</ul>
<h4 id="3、IntentService"><a href="#3、IntentService" class="headerlink" title="3、IntentService"></a>3、IntentService</h4><ul>
<li>  继承自Service在内部创建HandlerThread。</li>
<li>  异步，不占用主线程。</li>
<li>  优先级较高，不易被系统Kill。</li>
</ul>
<h4 id="4、AsyncTask"><a href="#4、AsyncTask" class="headerlink" title="4、AsyncTask"></a>4、AsyncTask</h4><ul>
<li>  Android提供的工具类。</li>
<li>  无需自己处理线程切换。</li>
<li>  需注意版本不一致问题（API 14以上解决）</li>
</ul>
<h4 id="5、线程池"><a href="#5、线程池" class="headerlink" title="5、线程池"></a>5、线程池</h4><ul>
<li>  Java提供的线程池。</li>
<li>  易复用，减少频繁创建、销毁的时间。</li>
<li>  功能强大，如定时、任务队列、并发数控制等。</li>
</ul>
<h4 id="6、RxJava"><a href="#6、RxJava" class="headerlink" title="6、RxJava"></a>6、RxJava</h4><p>由强大的调度器Scheduler集合提供。</p>
<p>不同类型的Scheduler：</p>
<ul>
<li>  IO</li>
<li>  Computation</li>
</ul>
<h4 id="异步方式总结"><a href="#异步方式总结" class="headerlink" title="异步方式总结"></a>异步方式总结</h4><ul>
<li>  推荐度：从后往前排列。</li>
<li>  正确场景选择正确的方式。</li>
</ul>
<h3 id="3-3、Android线程优化实战"><a href="#3-3、Android线程优化实战" class="headerlink" title="3.3、Android线程优化实战"></a>3.3、Android线程优化实战</h3><h4 id="线程使用准则"><a href="#线程使用准则" class="headerlink" title="线程使用准则"></a>线程使用准则</h4><ul>
<li>  1、<strong>严禁使用new Thread方式</strong>。</li>
<li>  2、提供<strong>基础线程池</strong>供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多。</li>
<li>  3、<strong>根据任务类型选择合适的异步方式</strong>：优先级低，长时间执行，HandlerThread；定时执行耗时任务，线程池。</li>
<li>  4、创建线程必须<strong>命名</strong>，以方便<strong>定位线程归属</strong>，在运行期 <strong>Thread.currentThread().setName</strong> 修改名字。</li>
<li>  5、关键异步任务监控，注意<strong>异步不等于不耗时</strong>，建议使用<strong>AOP</strong>的方式来做<strong>监控</strong>。</li>
<li>  6、<strong>重视优先级设置（根据任务具体情况），Process.setThreadPriority() 可以设置多次</strong>。</li>
</ul>
<h3 id="3-4、如何锁定线程创建者"><a href="#3-4、如何锁定线程创建者" class="headerlink" title="3.4、如何锁定线程创建者"></a>3.4、如何锁定线程创建者</h3><h4 id="锁定线程创建背景"><a href="#锁定线程创建背景" class="headerlink" title="锁定线程创建背景"></a>锁定线程创建背景</h4><ul>
<li>  项目变大之后收敛线程。</li>
<li>  项目源码、三方库、aar中都有线程的创建。</li>
</ul>
<h4 id="锁定线程创建方案"><a href="#锁定线程创建方案" class="headerlink" title="锁定线程创建方案"></a>锁定线程创建方案</h4><p>特别适合Hook手段，<strong>找Hook点：构造函数或者特定方法，如Thread的构造函数。</strong></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>这里我们直接使用维数的 <a target="_blank" rel="noopener" href="https://github.com/tiann/epic">epic</a> 对Thread进行Hook。在attachBaseContext中调用<code>DexposedBridge.hookAllConstructors()</code>方法即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DexposedBridge.hookAllConstructors(Thread.class, <span class="keyword">new</span> XC_MethodHook() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> afterHookedMethod（MethodHookParam param）<span class="keyword">throws</span> Throwable &#123;                         </span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param); </span><br><span class="line">        Thread thread = (Thread) param.thisObject; </span><br><span class="line">        LogUtils.i(<span class="string">&quot;stack &quot;</span> + Log.getStackTraceString(<span class="keyword">new</span> Throwable());</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从log找到线程创建信息，根据堆栈信息跟相关业务方沟通解决方案。</p>
<h3 id="3-5、线程收敛优雅实践初步"><a href="#3-5、线程收敛优雅实践初步" class="headerlink" title="3.5、线程收敛优雅实践初步"></a>3.5、线程收敛优雅实践初步</h3><h4 id="线程收敛常规方案"><a href="#线程收敛常规方案" class="headerlink" title="线程收敛常规方案"></a>线程收敛常规方案</h4><ul>
<li>  根据线程创建堆栈考量合理性，使用同一线程库。</li>
<li>  各业务线下掉自己的线程库。</li>
</ul>
<h4 id="问题：基础库怎么使用线程？"><a href="#问题：基础库怎么使用线程？" class="headerlink" title="问题：基础库怎么使用线程？"></a>问题：基础库怎么使用线程？</h4><p>直接依赖线程库，但问题在于<strong>线程库更新可能会导致基础库更新</strong>。</p>
<h4 id="基础库优雅使用线程"><a href="#基础库优雅使用线程" class="headerlink" title="基础库优雅使用线程"></a>基础库优雅使用线程</h4><ul>
<li>  <strong>基础库内部暴露API：setExecutor</strong>。</li>
<li>  <strong>初始化的时候注入统一的线程库</strong>。</li>
</ul>
<h4 id="统一线程库时区分任务类型"><a href="#统一线程库时区分任务类型" class="headerlink" title="统一线程库时区分任务类型"></a>统一线程库时区分任务类型</h4><ul>
<li>  <strong>IO密集型任务</strong>：IO密集型任务不消耗CPU，核心池可以很大。常见的IO密集型任务如文件读取、写入，网络请求等等。</li>
<li>  <strong>CPU密集型任务</strong>：核心池大小和CPU核心数相关。常见的CPU密集型任务如比较复杂的计算操作，此时需要使用大量的CPU计算单元。</li>
</ul>
<h4 id="实现用于执行多类型任务的基础线程池组件"><a href="#实现用于执行多类型任务的基础线程池组件" class="headerlink" title="实现用于执行多类型任务的基础线程池组件"></a>实现用于执行多类型任务的基础线程池组件</h4><p>目前基础线程池组件位于启动器sdk之中，使用非常简单，示例代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前执行的任务是CPU密集型任务，则从基础线程池组件</span></span><br><span class="line"><span class="comment">// DispatcherExecutor中获取到用于执行 CPU 密集型任务的线程池</span></span><br><span class="line">DispatcherExecutor.getCPUExecutor().execute(YourRunable());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前执行的任务是IO密集型任务，则从基础线程池组件</span></span><br><span class="line"><span class="comment">// DispatcherExecutor中获取到用于执行 IO 密集型任务的线程池</span></span><br><span class="line">DispatcherExecutor.getIOExecutor().execute(YourRunable());</span><br></pre></td></tr></table></figure>

<p>具体的实现源码也比较简单，并且我对每一处代码都进行了详细的解释，就不一一具体分析了。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CPU 密集型任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor sCPUThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IO 密集型任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService sIOThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前设备可以使用的 CPU 核数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池核心线程数，其数量在2 ~ 5这个区域内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池线程数的最大值：这里指定为了核心线程数的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 线程池中空闲线程等待工作的超时时间，当线程池中</span></span><br><span class="line"><span class="comment">    * 线程数量大于corePoolSize（核心线程数量）或</span></span><br><span class="line"><span class="comment">    * 设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，</span></span><br><span class="line"><span class="comment">    * 线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</span></span><br><span class="line"><span class="comment">    * 否则，线程会永远等待新的工作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_SECONDS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建一个基于链表节点的阻塞队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; S_POOL_WORK_QUEUE = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建线程的线程工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultThreadFactory S_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池执行耗时任务时发生异常所需要做的拒绝执行处理</span></span><br><span class="line"><span class="comment">     * 注意：一般不会执行到这里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler S_HANDLER = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            Executors.newCachedThreadPool().execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取CPU线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CPU线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">getCPUExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sCPUThreadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取IO线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> IO线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">getIOExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sIOThreadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现一个默认的线程工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger POOL_NUMBER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                    Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;TaskDispatcherPool-&quot;</span> +</span><br><span class="line">                    POOL_NUMBER.getAndIncrement() +</span><br><span class="line">                    <span class="string">&quot;-Thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 每一个新创建的线程都会分配到线程组group当中</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon()) &#123;</span><br><span class="line">                <span class="comment">// 非守护线程</span></span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置线程优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sCPUThreadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,</span><br><span class="line">                S_POOL_WORK_QUEUE, S_THREAD_FACTORY, S_HANDLER);</span><br><span class="line">        <span class="comment">// 设置是否允许空闲核心线程超时时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。否则，线程会永远等待新的工作。</span></span><br><span class="line">        sCPUThreadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// IO密集型任务线程池直接采用CachedThreadPool来实现，</span></span><br><span class="line">        <span class="comment">// 它最多可以分配Integer.MAX_VALUE个非核心线程用来执行任务</span></span><br><span class="line">        sIOThreadPoolExecutor = Executors.newCachedThreadPool(S_THREAD_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6、线程优化核心问题"><a href="#3-6、线程优化核心问题" class="headerlink" title="3.6、线程优化核心问题"></a>3.6、线程优化核心问题</h3><h4 id="1、线程使用为什么会遇到问题？"><a href="#1、线程使用为什么会遇到问题？" class="headerlink" title="1、线程使用为什么会遇到问题？"></a>1、线程使用为什么会遇到问题？</h4><p>项目发展阶段忽视基础设施建设，没有采用统一的线程池，导致线程数量过多。</p>
<h5 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h5><p>异步任务执行太耗时，导致主线程卡顿。</p>
<h5 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h5><ul>
<li>  <strong>1、Java线程调度是抢占式的，线程优先级比较重要，需要区分</strong>。</li>
<li>  <strong>2、没有区分IO和CPU密集型任务，导致主线程抢不到CPU</strong>。</li>
</ul>
<h4 id="2、怎么在项目中对线程进行优化？"><a href="#2、怎么在项目中对线程进行优化？" class="headerlink" title="2、怎么在项目中对线程进行优化？"></a>2、怎么在项目中对线程进行优化？</h4><h5 id="核心：线程收敛"><a href="#核心：线程收敛" class="headerlink" title="核心：线程收敛"></a>核心：线程收敛</h5><ul>
<li>  <strong>通过Hook方式找到对应线程的堆栈信息，和业务方讨论是否应该单独起一个线程，尽可能使用统一线程池</strong>。</li>
<li>  <strong>每个基础库都暴露一个设置线程池的方法，以避免线程库更新导致基础库需要更新的问题</strong>。</li>
<li>  <strong>统一线程池应注意IO、CPU密集型任务区分</strong>。</li>
<li>  其它细节：<strong>重要异步任务统计耗时、注重异步任务优先级和线程名的设置</strong>。</li>
</ul>
<h2 id="4、异步初始化"><a href="#4、异步初始化" class="headerlink" title="4、异步初始化"></a>4、异步初始化</h2><h3 id="4-1、核心思想"><a href="#4-1、核心思想" class="headerlink" title="4.1、核心思想"></a>4.1、核心思想</h3><p>子线程分担主线程任务，并行减少时间。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316203244725.png" alt="image-20210316203244725"></p>
<h3 id="4-2、异步优化注意点"><a href="#4-2、异步优化注意点" class="headerlink" title="4.2、异步优化注意点"></a>4.2、异步优化注意点</h3><ul>
<li>  1、<strong>不符合异步要求</strong>。</li>
<li>  2、<strong>需要在某个阶段完成（采用CountDownLatch确保异步任务完成后才到下一个阶段）</strong>。</li>
<li>  3、<strong>如出现主线程要使用时还没初始化则在此次使用前初始化</strong>。</li>
<li>  4、<strong>区分CPU密集型和IO密集型任务</strong>。</li>
</ul>
<h3 id="4-3、异步初始化方案演进"><a href="#4-3、异步初始化方案演进" class="headerlink" title="4.3、异步初始化方案演进"></a>4.3、异步初始化方案演进</h3><ul>
<li><p>1、new Thread</p>
</li>
<li><p>2、IntentService</p>
</li>
<li><p>3、线程池（合理配置并选择CPU密集型和IO密集型线程池）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiApplication</span> <span class="keyword">extends</span> <span class="title">HiBaseApplication</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取CPU核数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(CORE_POOL_SIZE);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Bugly</span></span><br><span class="line">                initBugly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//初始化U盟统计</span></span><br><span class="line">                initUmeng();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//高德地图</span></span><br><span class="line">                initAMap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//设备ID</span></span><br><span class="line">                getDeviceId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//JPush</span></span><br><span class="line">                initJPush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Weex</span></span><br><span class="line">                initWeex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//ARouter</span></span><br><span class="line">                initARouter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316205057742.png" alt="image-20210316205057742"></p>
</li>
<li><p>  4、异步启动器</p>
</li>
</ul>
<h3 id="4-4、异步优化最优解：异步启动器"><a href="#4-4、异步优化最优解：异步启动器" class="headerlink" title="4.4、异步优化最优解：异步启动器"></a>4.4、异步优化最优解：异步启动器</h3><p><a target="_blank" rel="noopener" href="https://github.com/hzp201314/LaunchStarter">异步启动器源码及使用demo地址</a></p>
<h4 id="常规异步优化痛点"><a href="#常规异步优化痛点" class="headerlink" title="常规异步优化痛点"></a>常规异步优化痛点</h4><ul>
<li>  1、代码不优雅：例如使用线程池实现多个并行异步任务时会有多个<code>executorService.submit()</code>代码块。</li>
<li>  2、场景不好处理(依赖关系)：各个初始化任务之间存在依赖关系，例如推送sdk的初始化任务需要依赖于获取设备id的初始化任务。此外，有些任务是需要在某些特定的时候就初始化完成，例如需要在Application的<code>onCreate()</code>方法执行完之前就初始化完成。</li>
<li>  3、维护成本高。</li>
</ul>
<h4 id="启动器核心思想"><a href="#启动器核心思想" class="headerlink" title="启动器核心思想"></a>启动器核心思想</h4><p><strong>充分</strong>利用CPU多核，<strong>自动</strong>梳理任务顺序。</p>
<h4 id="启动器流程"><a href="#启动器流程" class="headerlink" title="启动器流程"></a>启动器流程</h4><p>启动器的流程图如下所示：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210316205921513.png" alt="image-20210316205921513"></p>
<p>启动器的主题流程为上图中的中间区域，即<strong>主线程与并发两个区域块</strong>。需要注意的是，在上图中的 <strong>head task与tail task</strong> 并不包含在启动器的主题流程中，它仅仅是用于<strong>处理启动前/启动后的一些通用任务</strong>，例如我们可以在head task中做一些获取通用信息的操作，在tail task可以做一些log输出、数据上报等操作。</p>
<p>那么，这里我们总结一下启动的核心流程，如下所示：</p>
<ul>
<li>  1、<strong>任务Task化，启动逻辑抽象成Task</strong>（Task即对应一个个的初始化任务）。</li>
<li>  2、<strong>根据所有任务依赖关系排序生成一个有向无环图</strong>：例如上述说到的推送SDK初始化任务需要依赖于获取设备id的初始化任务，各个任务之间都可能存在依赖关系，所以将它们的依赖关系排序生成一个有向无环图能将<strong>并行效率最大化</strong>。</li>
<li>  3、<strong>多线程按照排序后的优先级依次执行</strong>：例如必须先初始化获取设备id的初始化任务，才能去进行推送SDK的初始化任务。</li>
</ul>
<h4 id="异步启动器优化实战与源码剖析"><a href="#异步启动器优化实战与源码剖析" class="headerlink" title="异步启动器优化实战与源码剖析"></a>异步启动器优化实战与源码剖析</h4><p>下面，我们就来使用异步启动器来在Application的<code>onCreate()</code>方法中进行异步优化，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、启动器初始化</span></span><br><span class="line">TaskDispatcher.init(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 2、创建启动器实例，这里每次获取的都是新对象</span></span><br><span class="line">TaskDispatcher dispatcher = TaskDispatcher.createInstance();</span><br><span class="line"><span class="comment">// 3、给启动器配置一系列的（异步/非异步）初始化任务并启动启动器</span></span><br><span class="line">dispatcher</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitAMapTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitStethoTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitWeexTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitBuglyTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitFrescoTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitJPushTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> InitUmengTask())</span><br><span class="line">        .addTask(<span class="keyword">new</span> GetDeviceIdTask())</span><br><span class="line">        .start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、需要等待微信SDK初始化完成，程序才能往下执行</span></span><br><span class="line">dispatcher.await();</span><br></pre></td></tr></table></figure>

<p>这里的 <strong>TaskDispatcher</strong> 就是我们的<strong>启动器调用类</strong>。首先，在注释1处，我们需要先调用TaskDispatcher的init方法进行启动器的初始化，其源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sContext = context;</span><br><span class="line">        sHasInit = <span class="keyword">true</span>;</span><br><span class="line">        sIsMainProcess = Utils.isMainProcess(sContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，仅仅是初始化了几个基础字段。接着，在注释2处，我们创建了启动器实例，其源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：这里我们每次获取的都是新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskDispatcher <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sHasInit) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;must call TaskDispatcher.init    first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在createInstance方法的中我们每次都会创建一个新的TaskDispatcher实例。然后，在注释3处，我们给启动器配置了一系列的初始化任务并启动启动器，需要注意的是，<strong>这里的Task既可以是用于执行异步任务（子线程）的也可以是用于执行非异步任务（主线程）</strong>。下面，我们来分析下这两种Task的用法，比如InitStethoTask这个异步任务的初始化，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步的Task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitStethoTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stetho.initializeWithDefaults(mContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">ITask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String mTag = getClass().getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context mContext = TaskDispatcher.getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前进程是否是主进程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> mIsMainProcess = TaskDispatcher.isMainProcess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否正在等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mIsWaiting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否正在执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mIsRunning;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Task是否执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mIsFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Task是否已经被分发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mIsSend;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前Task依赖的Task数量（需要等待被依赖的Task执行完毕才能执行自己），默认没有依赖</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mDepends = <span class="keyword">new</span> CountDownLatch(dependsOn() == <span class="keyword">null</span> ? <span class="number">0</span> : dependsOn().size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Task等待，让依赖的Task先执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitToSatisfy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mDepends.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖的Task执行完一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">satisfy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDepends.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要尽快执行，解决特殊场景的问题：一个Task耗时非常多但是优先级却一般，很有可能开始的时间较晚，</span></span><br><span class="line"><span class="comment">     * 导致最后只是在等它，这种可以早开始。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needRunAsSoon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Task的优先级，运行在主线程则不要去改优先级</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Process.THREAD_PRIORITY_BACKGROUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Task执行在哪个线程池，默认在IO的线程池；</span></span><br><span class="line"><span class="comment">     * CPU 密集型的一定要切换到DispatcherExecutor.getCPUExecutor();</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">runOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DispatcherExecutor.getIOExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步线程执行的Task是否需要在被调用await的时候等待，默认不需要</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Task依赖的Task集合（需要等待被依赖的Task执行完毕才能执行自己），默认没有依赖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Task&gt;&gt; dependsOn() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">runOnMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">getTailRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTaskCallBack</span><span class="params">(TaskCallBack callBack)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否只在主进程，默认是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onlyInMainProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIsRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunning</span><span class="params">(<span class="keyword">boolean</span> mIsRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mIsRunning = mIsRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIsFinished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinished</span><span class="params">(<span class="keyword">boolean</span> finished)</span> </span>&#123;</span><br><span class="line">        mIsFinished = finished;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIsSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSend</span><span class="params">(<span class="keyword">boolean</span> send)</span> </span>&#123;</span><br><span class="line">        mIsSend = send;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mIsWaiting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWaiting</span><span class="params">(<span class="keyword">boolean</span> mIsWaiting)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mIsWaiting = mIsWaiting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这里的InitStethoTask直接继承自Task，Task中的runOnMainThread方法返回为false，说明 <strong>task</strong> 是用于<strong>处理异步任务的task</strong>，其中的run方法就是Runnable的run方法。下面，我们再看看另一个用于初始化非异步任务的例子，例如用于微信SDK初始化的InitWeexTask，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 主线程执行的task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitWeexTask</span> <span class="keyword">extends</span> <span class="title">MainTask</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//true:必须等待初始化完成程序才能继续往下执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InitConfig config = <span class="keyword">new</span> InitConfig.Builder().build();</span><br><span class="line">        WXSDKEngine.initialize((Application) mContext, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它直接继承了MainTask，MainTask的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true:初始化主线程中的非异步任务的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">runOnMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MainTask</strong> 直接继承了Task，并仅仅是重写了runOnMainThread方法返回了true，说明它就是用来<strong>初始化主线程中的非异步任务的</strong>。</p>
<p>此外，我们注意到InitWeexTask中还重写了一个needWait方法并返回了true，<strong>其目的是为了在某个时刻之前必须等待InitWeexTask初始化完成程序才能继续往下执行</strong>，这里的某个时刻指的就是我们在Application的<code>onCreate()</code>方法中的注释4处的代码所执行的地方：<code>dispatcher.await()</code>，其实现源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要等待的任务数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger mNeedWaitCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用了 await 还没结束且需要等待的任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Task&gt; mNeedWaitTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CountDownLatch mCountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITTIME = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1、仅仅在测试阶段才输出需等待的任务列表数与任务名称</span></span><br><span class="line">        <span class="keyword">if</span> (DispatcherLog.isDebug()) &#123;</span><br><span class="line">            DispatcherLog.i(<span class="string">&quot;still has &quot;</span> + mNeedWaitCount.get());</span><br><span class="line">            <span class="keyword">for</span> (Task task : mNeedWaitTasks) &#123;</span><br><span class="line">                DispatcherLog.i(<span class="string">&quot;needWait: &quot;</span> + task.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、只要还有需要等待的任务没有执行完成，就调用mCountDownLatch的await方法进行等待，这里我们设定超时时间为10s</span></span><br><span class="line">        <span class="keyword">if</span> (mNeedWaitCount.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCountDownLatch == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;You have to call start() before call await()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCountDownLatch.await(WAITTIME, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，在注释1处，我们仅仅只会在测试阶段才会输出需等待的任务列表数与任务名称。然后，在注释2处，只要需要等待的任务数mNeedWaitCount大于0，即只要还有需要等待的任务没有执行完成，就调用mCountDownLatch的await方法进行等待，注意我们这里设定了超时时间为10s。当一个<strong>task执行完成后</strong>，无论它是异步还是非异步的，最终都会执行到<strong>mTaskDispatcher的markTaskDone(mTask)方法</strong>，我们看看它的实现源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 已经结束的Task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Class&lt;? extends Task&gt;&gt; mFinishedTasks = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markTaskDone</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ifNeedWait(task)) &#123;</span><br><span class="line">        <span class="comment">//添加到已完成的任务列表</span></span><br><span class="line">        mFinishedTasks.add(task.getClass());</span><br><span class="line">        <span class="comment">//移除需要等待的任务</span></span><br><span class="line">        mNeedWaitTasks.remove(task);</span><br><span class="line">        <span class="comment">//总线程数据减一</span></span><br><span class="line">        mCountDownLatch.countDown();</span><br><span class="line">        <span class="comment">//等待线程数减一</span></span><br><span class="line">        mNeedWaitCount.getAndDecrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里每执行完成一个task，就会将mCountDownLatch的锁计数减1，与此同时，也会将我们的mNeedWaitCount这个原子整数包装类的数量减1。</p>
<p>此外，我们在前面说到了启动器将各个任务之间的依赖关系抽象成了一个有向无环图，在上面一系列的初始化代码中，InitJPushTask是需要依赖于GetDeviceIdTask的，<strong>那么，我们怎么告诉启动器它们两者之间的依赖关系呢</strong>？</p>
<p>这里只需要在InitJPushTask中<strong>重写dependsOn()方法，并返回包含GetDeviceIdTask的task列表即可</strong>，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* InitJPushTask 需要在 getDeviceId 之后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitJPushTask</span> <span class="keyword">extends</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Task&gt;&gt; dependsOn() &#123;</span><br><span class="line">        List&lt;Class&lt;? extends Task&gt;&gt; task = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        task.add(GetDeviceIdTask.class);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JPushInterface.init(mContext);</span><br><span class="line">        MyApplication app = (MyApplication) mContext;</span><br><span class="line">        JPushInterface.setAlias(mContext, <span class="number">0</span>, app.getDeviceId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们的异步启动器就分析完毕了。下面我们来看看如何高效地进行延迟初始化。</p>
<h2 id="5、延迟初始化"><a href="#5、延迟初始化" class="headerlink" title="5、延迟初始化"></a>5、延迟初始化</h2><h3 id="5-1、常规方案：利用闪屏页的停留时间进行部分初始化"><a href="#5-1、常规方案：利用闪屏页的停留时间进行部分初始化" class="headerlink" title="5.1、常规方案：利用闪屏页的停留时间进行部分初始化"></a>5.1、常规方案：利用闪屏页的停留时间进行部分初始化</h3><ul>
<li>  <code>new Handler().postDelayed()</code>。</li>
<li>  界面UI展示后调用。</li>
</ul>
<h3 id="5-2、常规初始化痛点"><a href="#5-2、常规初始化痛点" class="headerlink" title="5.2、常规初始化痛点"></a>5.2、常规初始化痛点</h3><ul>
<li>  <strong>时机不容易控制</strong>：handler postDelayed指定的延迟时间不好估计。</li>
<li>  <strong>导致界面UI卡顿</strong>：此时用户可能还在滑动列表。</li>
</ul>
<h3 id="5-3、延迟优化最优解：延迟启动器"><a href="#5-3、延迟优化最优解：延迟启动器" class="headerlink" title="5.3、延迟优化最优解：延迟启动器"></a>5.3、延迟优化最优解：延迟启动器</h3><p><a target="_blank" rel="noopener" href="https://github.com/hzp201314/LaunchStarter">延迟启动器源码及使用demo地址</a></p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>利用IdleHandler特性，<strong>在CPU空闲时执行，对延迟任务进行分批初始化</strong>。</p>
<h4 id="延迟启动器优化实战与源码剖析"><a href="#延迟启动器优化实战与源码剖析" class="headerlink" title="延迟启动器优化实战与源码剖析"></a>延迟启动器优化实战与源码剖析</h4><p>延迟初始化启动器的代码很简单，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟初始化分发器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayInitDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Task&gt; mDelayTasks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueue.IdleHandler mIdleHandler = <span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 分批执行的好处在于每一个task占用主线程的时间相对</span></span><br><span class="line">            <span class="comment">// 来说很短暂，并且此时CPU是空闲的，这些能更有效地避免UI卡顿</span></span><br><span class="line">            <span class="keyword">if</span>(mDelayTasks.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Task task = mDelayTasks.poll();</span><br><span class="line">                <span class="keyword">new</span> DispatchRunnable(task).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//队列空了就移除idle</span></span><br><span class="line">            <span class="keyword">return</span> !mDelayTasks.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//添加需要延迟初始化的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DelayInitDispatcher <span class="title">addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">        mDelayTasks.add(task);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启延迟初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Looper.myQueue().addIdleHandler(mIdleHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DelayInitDispatcher中，我们提供了mDelayTasks队列用于将每一个task添加进来，使用者只需调用<code>addTask()</code>方法即可。<strong>当CPU空闲时，mIdleHandler便会回调自身的<code>queueIdle()</code>方法，这个时候我们可以将task一个一个地拿出来并执行</strong>。这种分批执行的好处在于每一个task占用主线程的时间相对来说很短暂，并且此时CPU是空闲的，这样能更有效地避免UI卡顿，真正地提升用户的体验。</p>
<p>至于使用就非常简单了，我们可以直接利用SplashActivity的广告页停留时间去进行延迟初始化，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    GlobalHandler.getInstance().getHandler().post((Runnable) () -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">            DelayInitDispatcher delayInitDispatcher = <span class="keyword">new</span> DelayInitDispatcher();</span><br><span class="line">            delayInitDispatcher.addTask(<span class="keyword">new</span> InitOtherTask())</span><br><span class="line">                    .start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<strong>能异步的task我们会优先使用异步启动器在Application的<code>onCreate()</code>方法中加载（或者是必须在Application的<code>onCreate()</code>方法完成前必须执行完的非异task务），对于不能异步的task，我们可以利用延迟启动器进行加载。如果任务可以到用时再加载，可以使用懒加载的方式</strong>。</p>
<h4 id="延迟启动器优势"><a href="#延迟启动器优势" class="headerlink" title="延迟启动器优势"></a>延迟启动器优势</h4><ul>
<li><p>执行时机明确。</p>
</li>
<li><p>缓解界面UI卡顿。</p>
</li>
<li><p>真正提升用户体验。</p>
</li>
</ul>
<h2 id="启动优化的其他方案"><a href="#启动优化的其他方案" class="headerlink" title="启动优化的其他方案"></a>启动优化的其他方案</h2><h2 id="6、Multidex预加载优化"><a href="#6、Multidex预加载优化" class="headerlink" title="6、Multidex预加载优化"></a>6、Multidex预加载优化</h2><p>我们都知道，安装或者升级后首次 MultiDex 花费的时间过于漫长，我们需要进行Multidex的预加载优化。</p>
<h3 id="6-1、优化步骤"><a href="#6-1、优化步骤" class="headerlink" title="6.1、优化步骤"></a>6.1、优化步骤</h3><ul>
<li>  1、启动时单独开一个进程去异步进行Multidex的第一次加载，即Dex提取和Dexopt操作。</li>
<li>  2、此时，主进程Application进入while循环，不断检测Multidex操作是否完成。</li>
<li>  3、执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的<code>onCreate()</code>方法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/hzp201314/MultiDexTest">Multidex优化Demo地址</a></p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化，所以应判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</p>
<h3 id="6-2、dex-opt过程是怎样的？"><a href="#6-2、dex-opt过程是怎样的？" class="headerlink" title="6.2、dex-opt过程是怎样的？"></a>6.2、dex-opt过程是怎样的？</h3><p>主要包括inline以及quick指令的优化。</p>
<h4 id="那么，inline是什么？"><a href="#那么，inline是什么？" class="headerlink" title="那么，inline是什么？"></a>那么，inline是什么？</h4><p>使编译器在函数调用处用函数体代码代替函数调用指令。</p>
<h4 id="inline的作用？"><a href="#inline的作用？" class="headerlink" title="inline的作用？"></a>inline的作用？</h4><p>函数调用的转移操作有一定的时间和空间方面的开销，特别是对于一些函数体不大且频繁调用的函数，解决其效率问题更为重要，引入inline函数就是为了解决这一问题。</p>
<h4 id="inline又是如何进行优化的？"><a href="#inline又是如何进行优化的？" class="headerlink" title="inline又是如何进行优化的？"></a>inline又是如何进行优化的？</h4><p>inline函数至少在三个方面提升了程序的时间性能：</p>
<ul>
<li>  1、避免了函数调用必须执行的压栈出栈等操作。</li>
<li>  2、由于函数体代码被移到函数调用处，编译器可以获得更多的上下文信息，并根据这些信息对函数体代码和被调用者代码进行更进一步的优化。</li>
<li>  3、若不使用inline函数，程序执行至函数调用处，需要转而去执行函数体所在位置的代码。一般函数调用位置和函数代码所在位置在代码段中并不相近，这样很容易形成操作系统的缺页中断。操作系统需要把缺页地址的代码从硬盘移入内存，所需时间将成数量级增加。而使用inline函数则可以减少缺页中断发生的机会。</li>
</ul>
<h4 id="对于inline的使用，我们应该注意的问题？"><a href="#对于inline的使用，我们应该注意的问题？" class="headerlink" title="对于inline的使用，我们应该注意的问题？"></a>对于inline的使用，我们应该注意的问题？</h4><ul>
<li>  1、由于inline函数在函数调用处插入函数体代码代替函数调用，若该函数在程序的很多位置被调用，有可能造成内存空间的浪费。</li>
<li>  2、一般程序的压栈出栈操作也需要一定的代码，这段代码完成栈指针调整、参数传递、现场保护和恢复等操作。 若函数的函数体代码量小于编译器生成的函数压栈出栈代码，则可以放心地定义为inline，这个时候占用内存空间反而会减小。而当函数体代码大于函数压栈出栈代码时，将函数定义为inline就会增加内存空间的使用。</li>
<li>  3、C++程序应该根据应用的具体场景、函数体大小、调用位置多少、函数调用的频率、应用场景对时间性能的要求，应用场景对内存性能的要求等各方面因素合理决定是否定义inline函数。</li>
<li>  4、inline函数内不允许用循环语句和开关语句。</li>
</ul>
<h3 id="6-3、抖音BoostMultiDex优化"><a href="#6-3、抖音BoostMultiDex优化" class="headerlink" title="6.3、抖音BoostMultiDex优化"></a>6.3、抖音BoostMultiDex优化</h3><p>为了彻底解决MutiDex加载时间慢的问题，抖音团队深入挖掘了 Dalvik 虚拟机的底层系统机制，对 DEX 相关的处理逻辑进行了重新设计与优化，并推出了 BoostMultiDex 方案，它能够减少 80% 以上的黑屏等待时间，挽救低版本 Android 用户的升级安装体验。如有兴趣的同学可以看看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904079206907911">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></p>
<h3 id="6-4、预加载SharedPreferences"><a href="#6-4、预加载SharedPreferences" class="headerlink" title="6.4、预加载SharedPreferences"></a>6.4、预加载SharedPreferences</h3><p>可以利用MultiDex预加载期间的这段CPU去预加载SharedPreferences。</p>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>需重写getApplicationContext返回this，否则此时可能获取不到context。</p>
<h2 id="7、类预加载优化"><a href="#7、类预加载优化" class="headerlink" title="7、类预加载优化"></a>7、类预加载优化</h2><p>在Application中提前异步加载初始化耗时较长的类。</p>
<h3 id="如何找到耗时较长的类？"><a href="#如何找到耗时较长的类？" class="headerlink" title="如何找到耗时较长的类？"></a>如何找到耗时较长的类？</h3><p>替换系统的ClassLoader，打印类加载的时间，按需选取需要异步加载的类。</p>
<h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><ul>
<li>  Class.forName()只加载类本身及其静态变量的引用类。</li>
<li>  new 类实例 可以额外加载类成员变量的引用类。</li>
</ul>
<h2 id="8、WebView启动优化"><a href="#8、WebView启动优化" class="headerlink" title="8、WebView启动优化"></a>8、WebView启动优化</h2><ul>
<li>  1、WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。</li>
<li>  2、使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。</li>
<li>  3、本地离线包，即预置静态页面资源。</li>
</ul>
<h2 id="9、页面数据预加载"><a href="#9、页面数据预加载" class="headerlink" title="9、页面数据预加载"></a>9、页面数据预加载</h2><p>在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。</p>
<h2 id="10、启动阶段不启动子进程"><a href="#10、启动阶段不启动子进程" class="headerlink" title="10、启动阶段不启动子进程"></a>10、启动阶段不启动子进程</h2><p>子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。</p>
<h3 id="注意启动顺序"><a href="#注意启动顺序" class="headerlink" title="注意启动顺序"></a>注意启动顺序</h3><p>App onCreate之前是ContentProvider初始化。</p>
<h2 id="11、闪屏页与主页的绘制优化"><a href="#11、闪屏页与主页的绘制优化" class="headerlink" title="11、闪屏页与主页的绘制优化"></a>11、闪屏页与主页的绘制优化</h2><ul>
<li>  1、布局优化。</li>
<li>  2、过渡绘制优化。</li>
</ul>
<p>关于布局与绘制优化可以参考<a href="">Android性能优化之绘制优化</a>。</p>
<h1 id="五、启动优化黑科技"><a href="#五、启动优化黑科技" class="headerlink" title="五、启动优化黑科技"></a>五、启动优化黑科技</h1><h2 id="1、启动阶段抑制GC"><a href="#1、启动阶段抑制GC" class="headerlink" title="1、启动阶段抑制GC"></a>1、启动阶段抑制GC</h2><p><strong>启动时GC抑制，允许堆一直增长，直到手动或OOM停止GC抑制</strong>。（空间换时间）</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>  1、设备厂商没有加密内存中的Dalvik库文件。</li>
<li>  2、设备厂商没有改动Google的Dalvik源码。</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>  1、首先，<strong>在源码级别找到抑制GC的修改方法，例如改变跳转分支</strong>。</li>
<li>  2、然后，<strong>在二进制代码里找到 A 分支条件跳转的”指令指纹”，以及用于改变分支的二进制代码，假设为 override_A</strong>。</li>
<li>  3、最后，<strong>应用启动后扫描内存中的 libdvm.so，根据”指令指纹”定位到修改位置，并使用 override_A 覆盖</strong>。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>需要<strong>白名单覆盖</strong>所有设备，但维护成本高。</p>
<h2 id="2、CPU锁频"><a href="#2、CPU锁频" class="headerlink" title="2、CPU锁频"></a>2、CPU锁频</h2><p>一个设备的CPU通常都是4核或者8核，但是应用在一般情况下对CPU的利用率并不高，可能只有30%或者50%，如果我们在启动速度暴力拉伸CPU频率，以此提高CPU的利用率，那么，应用的启动速度会提升不少。</p>
<p>在Android系统中，<strong>CPU相关的信息存储在/sys/devices/system/cpu目录的文件中，通过对该目录下的特定文件进行写值，实现对CPU频率等状态信息的更改</strong>。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>暴力拉伸CPU频率，导致耗电量增加。</p>
<h3 id="CPU工作模式"><a href="#CPU工作模式" class="headerlink" title="CPU工作模式"></a>CPU工作模式</h3><ul>
<li>  <strong>performance</strong>：<strong>最高性能模式</strong>，即使系统负载非常低，cpu也在<strong>最高频率</strong>下运行。</li>
<li>  <strong>powersave</strong>：<strong>省电模式</strong>，与performance模式相反，cpu始终在<strong>最低频率</strong>下运行。</li>
<li>  <strong>ondemand</strong>：CPU频率跟<strong>随系统负载</strong>进行<strong>变化</strong>。</li>
<li>  <strong>userspace</strong>：可以简单理解为<strong>自定义模式</strong>，在该模式下可以<strong>对频率进行设定</strong>。</li>
</ul>
<h3 id="CPU的工作频率范围"><a href="#CPU的工作频率范围" class="headerlink" title="CPU的工作频率范围"></a>CPU的工作频率范围</h3><p>对应的文件有：</p>
<ul>
<li>  cpuinfo_max_freq</li>
<li>  cpuinfo_min_freq</li>
<li>  scaling_max_freq</li>
<li>  scaling_min_freq</li>
</ul>
<h2 id="3、IO优化"><a href="#3、IO优化" class="headerlink" title="3、IO优化"></a>3、IO优化</h2><ul>
<li>  1、启动过程<strong>不建议出现网络IO</strong>。</li>
<li>  2、为了<strong>只解析启动过程中用到的数据</strong>，应<strong>选择合适的数据结构</strong>，如将ArrayMap改造成支持随机读写、延时解析的数据存储结构以替代SharePreference。</li>
</ul>
<p>这里需要注意的是，需要<strong>考虑重度用户的使用场景</strong>。</p>
<h3 id="补充加油站：Linux-IO知识"><a href="#补充加油站：Linux-IO知识" class="headerlink" title="补充加油站：Linux IO知识"></a>补充加油站：Linux IO知识</h3><h4 id="1、磁盘高速缓存技术"><a href="#1、磁盘高速缓存技术" class="headerlink" title="1、磁盘高速缓存技术"></a>1、磁盘高速缓存技术</h4><p>利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p>
<p>其内存中分为两种形式：</p>
<ul>
<li>  在内存中开辟一个单独的存储空间作为磁速缓存，大小固定。</li>
<li>  把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘I/O时共享。</li>
</ul>
<h4 id="2、分页"><a href="#2、分页" class="headerlink" title="2、分页"></a>2、分页</h4><ul>
<li>  存储器管理的一种技术。</li>
<li>  可以使电脑的主存使用存储在辅助存储器中的数据。</li>
<li>  操作系统会将辅助存储器（通常是磁盘）中的数据分区成固定大小的区块，称为“页”（pages）。 当不需要时，将分页由主存（通常是内存）移到辅助存储器；当需要时，再将数据取回，加载主存中。</li>
<li>  相对于分段，分页允许存储器存储于不连续的区块以维持文件系统的整齐。</li>
<li>  分页是磁盘和内存间传输数据块的最小单位。</li>
</ul>
<h4 id="3、高速缓存-缓冲器"><a href="#3、高速缓存-缓冲器" class="headerlink" title="3、高速缓存/缓冲器"></a>3、高速缓存/缓冲器</h4><ul>
<li>  都是介于高速设备和低速设备之间。</li>
<li>  高速缓存存放的是低速设备中某些数据的复制数据，而缓冲器则可同时存储高低速设备之间的数据。</li>
<li>  高速缓存存放的是高速设备经常要访问的数据。</li>
</ul>
<h4 id="4、linux同步IO：sync、fsync、msync、fdatasync"><a href="#4、linux同步IO：sync、fsync、msync、fdatasync" class="headerlink" title="4、linux同步IO：sync、fsync、msync、fdatasync"></a>4、linux同步IO：sync、fsync、msync、fdatasync</h4><h5 id="为什么要使用同步IO？"><a href="#为什么要使用同步IO？" class="headerlink" title="为什么要使用同步IO？"></a>为什么要使用同步IO？</h5><p>当数据写入文件时，内核通常先将该数据复制到缓冲区高速缓存或页面缓存中，如果该缓冲区尚未写满，则不会将其排入输入队列，而是等待其写满或内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，最后等待其到达队首时，才进行实际的IO操作—延迟写。</p>
<p>延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，可能会造成文件更新内容的丢失。为了保证数据一致性，则需使用同步IO。</p>
<h5 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h5><ul>
<li>  sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际磁盘写操作结束再返回。</li>
<li>  通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。</li>
</ul>
<h5 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h5><ul>
<li>  fsync函数只对文件描述符filedes指定的单一文件起作用，并且等待磁盘IO写结束后再返回。通常应用于需要确保将修改内容立即写到磁盘的应用如数据库。</li>
<li>  文件的数据和metadata通常存放在硬盘的不同地方，因此fsync至少需要两次IO操作。</li>
</ul>
<h5 id="msync"><a href="#msync" class="headerlink" title="msync"></a>msync</h5><p>如果当前硬盘的平均寻道时间是3-15ms，7200RPM硬盘的平均旋转延迟大约为4ms，因此一次IO操作的耗时大约为10ms。</p>
<p>如果使用内存映射文件的方式进行文件IO（mmap），将文件的page cache直接映射到进程的地址空间，这时需要使用msync系统调用确保修改的内容完全同步到硬盘之上。</p>
<h5 id="fdatasync"><a href="#fdatasync" class="headerlink" title="fdatasync"></a>fdatasync</h5><ul>
<li>  fdatasync函数类似于fsync，但它只影响文件的数据部分。而fsync还会同步更新文件的属性。</li>
<li>  仅仅只在必要（如文件尺寸需要立即同步）的情况下才会同步metadata，因此可以减少一次IO操作。</li>
</ul>
<h5 id="日志文件都是追加性的，文件尺寸一致在增大，如何利用好fdatasync减少日志文件的同步开销？"><a href="#日志文件都是追加性的，文件尺寸一致在增大，如何利用好fdatasync减少日志文件的同步开销？" class="headerlink" title="日志文件都是追加性的，文件尺寸一致在增大，如何利用好fdatasync减少日志文件的同步开销？"></a>日志文件都是追加性的，文件尺寸一致在增大，如何利用好fdatasync减少日志文件的同步开销？</h5><p>创建每个log文件时先写文件的最后一个page，将log文件扩展为10MB大小，这样便可以使用fdatasync，每写10MB只有一次同步metadata的开销。</p>
<h4 id="5、磁盘IO与网络IO"><a href="#5、磁盘IO与网络IO" class="headerlink" title="5、磁盘IO与网络IO"></a>5、磁盘IO与网络IO</h4><h5 id="磁盘IO（缓存IO）"><a href="#磁盘IO（缓存IO）" class="headerlink" title="磁盘IO（缓存IO）"></a>磁盘IO（缓存IO）</h5><p>标准IO，大多数文件系统默认的IO操作。</p>
<ul>
<li>  数据先从磁盘复制到内核空间的缓冲区，然后再从内核空间中的缓冲区复制到应用程序的缓冲区。</li>
<li>  读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经有缓存了，那么直接从缓存中返回；否则，从磁盘中返回，再缓存在操作系统的磁盘中。</li>
<li>  写操作：将数据从用户空间复制到内核空间中的缓冲区中，这时对用户来说写操作就已经完成，至于什么时候写到磁盘中，由操作系统决定，除非显示地调用了sync同步命令。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>  在一定程度上分离了内核空间和用户空间，保护系统本身安全。</li>
<li>  可以减少磁盘IO的读写次数，从而提高性能。</li>
</ul>
<p><strong>缺点</strong></p>
<p><strong>【这段话有问题,存疑：DMA应该是节省CPU和内存开销，而磁盘IO会造成CPU以及内存开销很大】</strong>DMA方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存中写回到磁盘，而不能在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）中进行多次数据拷贝操作，这带来的CPU以及内存开销是非常大的。</p>
<p><strong>磁盘IO主要的延时（15000RPM硬盘为例）</strong></p>
<p>机械转动延时（平均2ms）+ 寻址延时（2~3ms）+ 块传输延时（0.1ms左右）=&gt; 平均5ms</p>
<p><strong>网络IO主要延时</strong></p>
<p>服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时（一般为几十毫秒到几千毫秒，受环境影响极大）</p>
<h4 id="6、PIO与DMA"><a href="#6、PIO与DMA" class="headerlink" title="6、PIO与DMA"></a>6、PIO与DMA</h4><h5 id="PIO"><a href="#PIO" class="headerlink" title="PIO"></a>PIO</h5><p>很早之前，磁盘和内存之间的数据传输是需要CPU控制的，也就是读取磁盘文件到内存中时，数据会经过CPU存储转发，这种方式称为PIO。</p>
<h5 id="DMA（直接内存访问，Direct-Memory-Access）"><a href="#DMA（直接内存访问，Direct-Memory-Access）" class="headerlink" title="DMA（直接内存访问，Direct Memory Access）"></a>DMA（直接内存访问，Direct Memory Access）</h5><ul>
<li>  可以不经过CPU而直接进行磁盘和内存的数据交换。</li>
<li>  CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可。</li>
<li>  DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占用率，大大节省了系统资源，而它的传输速度与PIO的差异并不明显，而这主要取决于慢速设备的速度。</li>
</ul>
<h4 id="7、直接IO与异步IO"><a href="#7、直接IO与异步IO" class="headerlink" title="7、直接IO与异步IO"></a>7、直接IO与异步IO</h4><h5 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h5><p>应用程序直接访问磁盘数据，而不经过内核缓冲区。以减少从内核缓冲区到用户数据缓存的数据复制。</p>
<h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>当访问数据的线程发出请求后，线程会接着去处理其它事情，而不是阻塞等待。</p>
<h4 id="8、VFS（虚拟文件系统，Virtual-File-System）"><a href="#8、VFS（虚拟文件系统，Virtual-File-System）" class="headerlink" title="8、VFS（虚拟文件系统，Virtual File System）"></a>8、VFS（虚拟文件系统，Virtual File System）</h4><p>可以为访问文件系统的系统调用提供一个统一的抽象接口。</p>
<h2 id="4、数据重排"><a href="#4、数据重排" class="headerlink" title="4、数据重排"></a>4、数据重排</h2><p>Dex文件用到的类和APK里面各种资源文件都比较小，读取频繁，且磁盘地址分布范围比较广。我们可以利用Linux文件IO流程中的page cache机制将它们按照读取顺序重新排列在一起，以减少真实的磁盘IO次数。</p>
<h3 id="1、类重排"><a href="#1、类重排" class="headerlink" title="1、类重排"></a>1、类重排</h3><p>使用Facebook的 <a target="_blank" rel="noopener" href="https://github.com/facebook/redex">ReDex</a> 的Interdex调整类在Dex中的排列顺序。</p>
<h3 id="2、资源文件重排"><a href="#2、资源文件重排" class="headerlink" title="2、资源文件重排"></a>2、资源文件重排</h3><ul>
<li>  1、最佳方案是修改内核源码，实现统计、度量、自动化，其次也可以使用Hook框架进行统计得出资源加载顺序列表。</li>
<li>  2、最后，调整apk文件列表需要修改7zip源码以支持传入文件列表顺序。</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li>  所谓的创新，不一定是要创造前所未有的东西，也可以将已有的方案移植到新的平台，并结合该平台的特性落地，就是一个很大的创新。</li>
<li>  当我们足够熟悉底层的知识时，可以利用系统的特性去做更加深层次的优化。</li>
</ul>
<h3 id="3、了解Hook框架"><a href="#3、了解Hook框架" class="headerlink" title="3、了解Hook框架"></a>3、了解Hook框架</h3><h4 id="Xposed框架是什么？"><a href="#Xposed框架是什么？" class="headerlink" title="Xposed框架是什么？"></a>Xposed框架是什么？</h4><p>一个可以不修改APK就影响程序运行的Hook框架。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用自身实现的app_process替换掉系统/system/bin/app_process，加载一个额外的XposedBridge的jar包，用于将入口osZygoteInit.main()替换成XposedBridge.main()。之后，创建的Zygote进程和其子进程都是Hook过的了。</p>
<p>使用具体细节参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/coder_pig/article/details/80031285">Xposed教程</a>。</p>
<h2 id="5、类加载优化（Dalvik）"><a href="#5、类加载优化（Dalvik）" class="headerlink" title="5、类加载优化（Dalvik）"></a>5、类加载优化（Dalvik）</h2><h3 id="1、类预加载原理"><a href="#1、类预加载原理" class="headerlink" title="1、类预加载原理"></a>1、类预加载原理</h3><p>对象第一次创建的时候，JVM首先检查对应的Class对象是否已经加载。如果没有加载，JVM会根据类名查找.class文件，将其Class对象载入。同一个类第二次new的时候就不需要加载类对象，而是直接实例化，创建时间就缩短了。</p>
<h3 id="2、类加载优化过程"><a href="#2、类加载优化过程" class="headerlink" title="2、类加载优化过程"></a>2、类加载优化过程</h3><ul>
<li>  在Dalvik VM加载类的时候会有一个类校验过程，它需要校验方法的每一个指令。</li>
<li>  通过Hook去掉verify步骤 -&gt; 几十ms的优化</li>
<li>  最大优化场景在于首次安装和覆盖安装时，在Dalvik平台上，一个2MB的Dex正常需要350ms，将classVerifyMode设为VERIFY_MODE_NONE后，只需150ms，节省超过50%时间。</li>
</ul>
<p>ART比较复杂，Hook需要兼容几个版本。而且在安装时，大部分Dex已经优化好了，去掉ART平台的verify只会对动态加载的Dex带来一些好处。所以暂时不建议在ART平台使用。</p>
<h3 id="3、延伸：插件化和热修复"><a href="#3、延伸：插件化和热修复" class="headerlink" title="3、延伸：插件化和热修复"></a>3、延伸：插件化和热修复</h3><p>它们在设计上都存在大量的Hook和私有API调用，共同的缺点有如下两类问题。</p>
<h5 id="1、稳定性较差"><a href="#1、稳定性较差" class="headerlink" title="1、稳定性较差"></a>1、稳定性较差</h5><p>由于厂商的兼容性、安装失败、ART加载时dex2oat失败等原因，还是会有一些代码和资源的异常。Android P推出的non-sdk-interface调用限制，以后适配只会越来越难，成本越来越高。</p>
<h5 id="2、性能问题"><a href="#2、性能问题" class="headerlink" title="2、性能问题"></a>2、性能问题</h5><p>用到一些黑科技导致底层Runtime的优化享受不到。如Tinker加载补丁后，启动速度会降低5%~10%。</p>
<h4 id="1、各项热补丁技术的优缺点"><a href="#1、各项热补丁技术的优缺点" class="headerlink" title="1、各项热补丁技术的优缺点"></a>1、各项热补丁技术的优缺点</h4><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>  只针对单一客户端版本，随着版本差异变大补丁体积也会变大。</li>
<li>  不支持所有修改，如AndroidManifest。</li>
<li>  对代码和资源的更新成功率无法达到100%。</li>
</ul>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>  降低开发成本，轻量而快速地升级。发布补丁等同于发布版本，也应该完整地执行测试与上线流程。</li>
<li>  远端调试，只为特定用户发送补丁。</li>
<li>  数据统计，对同一批用户更换补丁版本，能够更好地进行ABTest，得到更精确的数据。</li>
</ul>
<h4 id="2、InstanceRun实现机制"><a href="#2、InstanceRun实现机制" class="headerlink" title="2、InstanceRun实现机制"></a>2、InstanceRun实现机制</h4><p>Android官方使用热补丁技术实现InstantRun。</p>
<h5 id="应用构建流程"><a href="#应用构建流程" class="headerlink" title="应用构建流程"></a>应用构建流程</h5><p>构建 -&gt; 部署 -&gt; 安装 -&gt; 重启app -&gt; 重启activity</p>
<h5 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h5><p>尽可能多的剔除不必要的步骤，然后提升必要步骤的速度。</p>
<h5 id="InstantRun构建的三种方式"><a href="#InstantRun构建的三种方式" class="headerlink" title="InstantRun构建的三种方式"></a>InstantRun构建的三种方式</h5><p><strong>1、HotSwap</strong></p>
<p>增量构建 -&gt; 改变部署</p>
<p><strong>场景：</strong></p>
<p>适用于多数简单的改变（包括一些方法实现的修改，或者变量值修改）。</p>
<p><strong>2、Warm Swap</strong></p>
<p>增量构建 -&gt; 改变部署 -&gt; activity重启</p>
<p><strong>场景：</strong></p>
<p>一般是修改了resources。</p>
<p><strong>3、Cold Swap</strong></p>
<p>增量构建 -&gt; 改变部署 -&gt; 应用重启 -&gt; activity重启</p>
<p><strong>场景：</strong></p>
<p>涉及结构性变化，如修改了继承规则或方法签名。</p>
<h5 id="首次运行Instant-Run，Gradle执行的操作"><a href="#首次运行Instant-Run，Gradle执行的操作" class="headerlink" title="首次运行Instant Run，Gradle执行的操作"></a>首次运行Instant Run，Gradle执行的操作</h5><ul>
<li>  在有Instant Run的环境下：一个新的App Server会被注入到App中，与Bytecode instrumentation协同监控代码的变化。</li>
<li>  同时会有一个新的Application类，它注入了一个自定义类加载器。同时该Application会启动我们所需的新注入的App Server。于是，AndroidManifest会被修改来确保我们能使用这个新的Application。</li>
<li>  使用的时候，它会通过决策，合理运用<strong>冷温热拔插</strong>来协助我们大量地缩短构建程序的时间。</li>
</ul>
<h5 id="HotSwap原理"><a href="#HotSwap原理" class="headerlink" title="HotSwap原理"></a>HotSwap原理</h5><p>Android Studio monitors 运行着Gradle任务来生成增量.dex文件（dex对应着开发中的修改类），AS会提取这些.dex文件发送到App Server，然后部署到App。因为原来版本的类都装载在运行中的程序了，Gradle会解释更新好这些.dex文件，发送到App Server的时候，交给自定义的类加载器来加载.dex文件。 App Server会不断地监听是否需要重写类文件，如果需要，任务会被立马执行，新的更改便能立即被响应。</p>
<p>需要注意的是，此时InstantRun是不能回退的，必须重启应用响应修改。</p>
<h5 id="WarmSwap原理"><a href="#WarmSwap原理" class="headerlink" title="WarmSwap原理"></a>WarmSwap原理</h5><p>因为资源文件是在Activity创建时加载，所以必须重启Activity加载资源文件。</p>
<p>注意：AndroidManifest的值是在APK安装的时候被读取的，所以需要触发一个完整的应用构建和部署。</p>
<h5 id="ColdSwap原理"><a href="#ColdSwap原理" class="headerlink" title="ColdSwap原理"></a>ColdSwap原理</h5><p>应用部署的时候，会把工程拆分成十个部分，每个部分都拥有自己的.dex文件，然后所有的类会根据包名被分配给相应的.dex文件。当ColdSwap开启时，修改过的类所对应的的.dex文件，会重组生成新的.dex文件，然后再部署到设备上。</p>
<p>注意：应用多进程会被降级为ColdSwap。</p>
<h4 id="3、apk打包流程"><a href="#3、apk打包流程" class="headerlink" title="3、apk打包流程"></a>3、apk打包流程</h4><p>manifest文件合并、打包，和res一起被AAPT合并到APK中，同时项目代码被编译成字节码，然后转换成.dex文件，也被合并到APK中。</p>
<h5 id="Android打包流程回顾，最后对于release签名apk需要进行zipalign优化，它是指什么？"><a href="#Android打包流程回顾，最后对于release签名apk需要进行zipalign优化，它是指什么？" class="headerlink" title="Android打包流程回顾，最后对于release签名apk需要进行zipalign优化，它是指什么？"></a>Android打包流程回顾，最后对于release签名apk需要进行zipalign优化，它是指什么？</h5><p>在回答这个问题之前，我们需要先了解下内存对齐（DSA，Data Structure Alignment）：<strong>各种类型的数据按照一定的规则在内存空间上排列，这就是对齐。</strong></p>
<p><strong>内存对齐的优势在于能够以空间换时间，减少数据存取指令周期，提升程序运行时的速度</strong>。</p>
<h5 id="编译器内存字节对齐的原则是什么？"><a href="#编译器内存字节对齐的原则是什么？" class="headerlink" title="编译器内存字节对齐的原则是什么？"></a>编译器内存字节对齐的原则是什么？</h5><ul>
<li>  1、数据类型的自身对齐值就是其长度（64位 OS）。</li>
<li>  2、结构体或类的自身对齐值就是成员中自身对齐值最大的那个。需要起始地址必须是其相应有效对齐值的整数，并要求结构体的大小也为该结构体有效对齐值的整数倍。</li>
</ul>
<p>zipalign优化的最根本目的是<strong>帮助操作系统更高效地根据请求索引资源，使用resource-handling code统一将DSA限定为4byte。</strong></p>
<h5 id="手动执行Align优化"><a href="#手动执行Align优化" class="headerlink" title="手动执行Align优化"></a>手动执行Align优化</h5><p>利用build-tools文件夹下对应Android版本中的zipalign工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign -v 4 source.apk androidres.apk</span><br></pre></td></tr></table></figure>

<p>检查当前APK是否已经执行过Align优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign -c -v 4 androidres.apk</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>  -c：检查。</li>
<li>  -v：代表详细输出。</li>
<li>  4：代表对齐为4个字节。</li>
</ul>
<h4 id="4、AndFix"><a href="#4、AndFix" class="headerlink" title="4、AndFix"></a>4、AndFix</h4><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>native hook -&gt; dalvik_repleaceMethod -&gt; 无法支持新增或删除filed的情况 -&gt; 需修复特定问题</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>  立即生效</li>
<li>  补丁较小</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>  兼容性不佳</li>
<li>  开发不透明</li>
</ul>
<h4 id="5、Qzone"><a href="#5、Qzone" class="headerlink" title="5、Qzone"></a>5、Qzone</h4><p>它是一个基于Android Dex分包方案。它将多个dex文件放入到app的classloader中，但是android dex拆包方案中的类是没有重复的，如果classes.dex和classes1.dex中有重复的类，<strong>当用到这个重复的类时，系统会选择哪个类进行加载呢？</strong></p>
<p>一个ClassLoader可以包含多个dex文件，每个dex文件是一个Elements，多个dex文件排列成有序的dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找到则返回，如果找不到从下一个dex文件继续查找。</p>
<p>所以，如果在不同的dex中有相同的类存在，那么会优先选择排在前面的dex文件的类。</p>
<p>Qzone热补丁方案就是把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex插入到Elements的最前面。</p>
<h5 id="实现中遇到的问题"><a href="#实现中遇到的问题" class="headerlink" title="实现中遇到的问题"></a>实现中遇到的问题</h5><p><strong>1、当其它dex文件中的类引用了patch.dex中的类时，会出现校验错误。拆分dex的很多类都不是在同一个dex内的，怎么没有问题？</strong></p>
<p>因为这个校验有个前提，当引用类被打上了CLASS_ISPREVERIFIED标志，那么就会进行dex的校验。</p>
<p><strong>2、CLASS_ISPREVERIFIED标志是什么时候被打上去的？</strong></p>
<ul>
<li>  在dex转换成odex（dexopt过程）时，当apk在安装的时候，apk中的classes.dex会被虚拟机（dexopt）优化成odex文件，然后才会拿去执行。</li>
<li>  虚拟机在启动的时候，会有许多的启动参数，其中一项就是verify选项，当verify选项被打开时，doVerify变量为true，那么就会执行dvmVerifyClass进行类的校验，如果校验成功，这个类会被打上CLASS_ISPREVERIFIED标志。</li>
</ul>
<h5 id="具体的校验过程是怎么样的？"><a href="#具体的校验过程是怎么样的？" class="headerlink" title="具体的校验过程是怎么样的？"></a>具体的校验过程是怎么样的？</h5><p>有两步验证：</p>
<p>1、验证clazz -&gt; directMethods方法，其包含以下方法：</p>
<ul>
<li>  static方法</li>
<li>  private方法</li>
<li>  构造函数</li>
</ul>
<p>2、clazz -&gt; virtualMethods</p>
<ul>
<li>  虚函数 = override方法</li>
</ul>
<p>如果以上方法中直接引用到的类（第一层级关系，不会进行递归搜索）和clazz<strong>都在同一个dex中</strong>的话，那么这个类就会被打上CLASS_ISPREVERIFED标志。</p>
<p>为了解决补丁方案中遇到的问题，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。QQ空间的方案是往所有类的构造函数里面插入一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If (ClassVerifier.PREVENT_VERIFY) &#123;</span><br><span class="line">    System.out.println(AntilazyLoad.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中AntilazyLoad类会被打包成单独的hack.dex，这样当安装apk的时候，classes.dex中的类都会引用一个在不同dex中的AntilazyLoad类，这样就防止类被打上了CLASS_ISPREVERIFILED标志，只要没被打上这个标志的类都可以进行打补丁操作。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  1、在应用启动进行加载时，AntilazyLoad类所在的dex包必须先加载进来，不然AntilazyLoad类会被标记为不存在，即使后续加载了hack.dex包，那么它也是不存在的。</li>
<li>  2、当在Application的onCreate中加载hack.dex时，Application不能插入上述代码。</li>
</ul>
<p><strong>为什么要选择构造函数？</strong></p>
<p>因为他不增加方法数，一个类即使没有显示的构造函数，也有一个隐式的默认构造函数。</p>
<h5 id="如何更高效地插入上述代码？"><a href="#如何更高效地插入上述代码？" class="headerlink" title="如何更高效地插入上述代码？"></a>如何更高效地插入上述代码？</h5><p>可以使用ASM/javaassist库在编译期间将相应的字节码插入Class文件中。</p>
<h5 id="Art的处理"><a href="#Art的处理" class="headerlink" title="Art的处理"></a>Art的处理</h5><p>Art采用了新的方式，插桩对代码的执行效率没有影响。但是补丁中的类出现修改类变量或者方法，可能会导致出现内存地址错乱的情况。</p>
<p><strong>原因：</strong></p>
<p>dex2oat时fast*已经将类能确定的各个地址写死。如果运行时补丁包的地址出现改变，原始类去调用时就会出现地址错乱。</p>
<p><strong>解决方法：</strong></p>
<p>将其父类以及调用类的所有类都加入到补丁包中。</p>
<h5 id="虚拟机在安装期间为类打上CLASS-ISPREVERIFIED标志是为了什么？"><a href="#虚拟机在安装期间为类打上CLASS-ISPREVERIFIED标志是为了什么？" class="headerlink" title="虚拟机在安装期间为类打上CLASS_ISPREVERIFIED标志是为了什么？"></a>虚拟机在安装期间为类打上CLASS_ISPREVERIFIED标志是为了什么？</h5><p>为了提高性能。</p>
<h5 id="禁用CLASS-ISPREVERIFIED是否会影响APP的性能？"><a href="#禁用CLASS-ISPREVERIFIED是否会影响APP的性能？" class="headerlink" title="禁用CLASS_ISPREVERIFIED是否会影响APP的性能？"></a>禁用CLASS_ISPREVERIFIED是否会影响APP的性能？</h5><p>由于现在很多App都使用了MultiDex分包方案，这导致了很多类都没有被打上这个标志，所以此时禁用所有类打上CLASS_ISPREVERIFIED标志对性能的影响不是很大。</p>
<h5 id="如何有效地生成补丁包？"><a href="#如何有效地生成补丁包？" class="headerlink" title="如何有效地生成补丁包？"></a>如何有效地生成补丁包？</h5><ul>
<li>  1、在正式版本发布的时候，会生成一份缓存文件，里面记录了所有class文件的MD5值，还有一份mapping混淆文件。</li>
<li>  2、在后续的版本中使用-applaymapping选项，应用正式版本的mapping文件，然后计算编译完成的class文件的MD5和正式版本进行比较，把不相同的class文件打包成补丁包。</li>
</ul>
<h5 id="Qzone方案缺点"><a href="#Qzone方案缺点" class="headerlink" title="Qzone方案缺点"></a>Qzone方案缺点</h5><p>在补丁包大小与性能损耗上有一定的局限性。</p>
<h4 id="6、ASM字节码插桩"><a href="#6、ASM字节码插桩" class="headerlink" title="6、ASM字节码插桩"></a>6、ASM字节码插桩</h4><p>插桩就是将一段代码插入或者替换原本的代码。 字节码插桩就是在我们的代码编译成字节码（Class）后，在Android下生成dex之前修改Class文件，修改或者增强原有代码逻辑的操作。</p>
<p>除了AspectJ、Javassist框架外，还有一个应用更为广泛的ASM框架同样也是字节码操作框架，Instant Run包括Javassist就是借助ASM来实现各自的功能。</p>
<p>可以这样理解Class字节码与ASM之间的联系：<strong>JSON对于GSON就类似于字节码Class对于Javassist/ASM。</strong></p>
<h5 id="Android-ASM自动埋点方案实践"><a href="#Android-ASM自动埋点方案实践" class="headerlink" title="Android ASM自动埋点方案实践"></a>Android ASM自动埋点方案实践</h5><p>Android 1.5.0版本以后提供了Transform API，允许第三方Plugin在打包dex文件之前的编译过程中操作.class文件，我们做的就是实现Transform进行.class文件遍历拿到所有方法，修改完成后对文件进行替换。</p>
<p>大致的流程如下所示：</p>
<p><strong>1、自动埋点追踪，遍历所有文件更换字节码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoTransform -&gt; transform -&gt; inputs.each &#123;TransformInput input -&gt; input.jarInput.each &#123; JarInput jarInput -&gt; … &#125; input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; … &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、Gradle插件实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PluginEntry -&gt; apply -&gt; def android &#x3D; project.extensions.getByType(AppExtension)</span><br><span class="line"></span><br><span class="line">registerTransform(android) -&gt; AutoTransform transform &#x3D; new AutoTransform</span><br><span class="line"></span><br><span class="line">android.registerTransform(transform)</span><br></pre></td></tr></table></figure>

<p><strong>3、使用ASM进行字节码编写</strong></p>
<p><strong>ASM框架核心类</strong></p>
<ul>
<li>  ClassReader：读取编译后的.class文件。</li>
<li>  ClassWriter：重新构建编译后的类。</li>
<li>  ClassVisitor：拜访类成员信息。</li>
<li>  AdviceAdapter：实现MethodVisitor接口，拜访方法的信息。</li>
</ul>
<p>1、visit -&gt; 在ClassVisitor中根据判断是否是实现View$OnClickListener接口的类，只有满足条件的类才会遍历其中的方法进行操作。</p>
<p>2、在MethodVisitor中对该方法进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitAnnotation -&gt; onMethodEnter -&gt; onMethodExi</span><br></pre></td></tr></table></figure>

<p>3、先在java文件中编写要插入的代码，然后使用ASM插件查看对应的字节码，根据其用ASM提供的Api一一对应地把代码填进来即可。</p>
<p>关于编译插桩的知识，笔者后面会有一系列的文章进行深入讲解，具体的文章目录可以在<a target="_blank" rel="noopener" href="https://github.com/JsonChao/Awesome-Android-Architecture#%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E6%8A%80%E6%9C%AF%E8%BF%9B%E8%A1%8C%E4%B8%AD">这里查看</a>。</p>
<h4 id="7、Tinker"><a href="#7、Tinker" class="headerlink" title="7、Tinker"></a>7、Tinker</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><ul>
<li>  全量替换新的Dex</li>
<li>  在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。由于比较耗费时间与内存，放在后台进程:patch中，为了补丁包尽可能小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。</li>
</ul>
<p>DexDiff的粒度是Dex格式的每一项，BsDiff的粒度是文件，AndFix/Qzone的粒度为class。</p>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>  1、占用Rom体积，1.5倍所修改Dex大小 = Dex.jar + dexopt文件。</li>
<li>  2、一个额外的合成过程，合成时间长短和额外的内存消耗也会影响最终的成功率。</li>
</ul>
<h5 id="热补丁方案对比"><a href="#热补丁方案对比" class="headerlink" title="热补丁方案对比"></a>热补丁方案对比</h5><p>若不care性能损耗与补丁包大小，Qzone是最简单且成功率最高的方案。</p>
<h4 id="8、完善的热补丁系统构建"><a href="#8、完善的热补丁系统构建" class="headerlink" title="8、完善的热补丁系统构建"></a>8、完善的热补丁系统构建</h4><h5 id="一、网络通道"><a href="#一、网络通道" class="headerlink" title="一、网络通道"></a>一、网络通道</h5><p>负责将补丁包交付给用户，包括特定用户和全量用户。</p>
<p><strong>1、pull通道</strong></p>
<p>在登录/24小时等时机，通过pull方式查询后台是否有对应的补丁包更新。</p>
<p><strong>2、指定版本的push通道</strong></p>
<p>在紧急情况下，我们可以在一个小时内向所有用户下发补丁包更新。</p>
<p><strong>3、指定特定用户的push通道</strong></p>
<p>对特定用户或用户组做远程调试。</p>
<h5 id="二、上线与管理平台"><a href="#二、上线与管理平台" class="headerlink" title="二、上线与管理平台"></a>二、上线与管理平台</h5><p>快速上线，管理历史记录，以及监控补丁的运行情况。</p>
<h2 id="6、保活"><a href="#6、保活" class="headerlink" title="6、保活"></a>6、保活</h2><h3 id="1、厂商合作"><a href="#1、厂商合作" class="headerlink" title="1、厂商合作"></a>1、厂商合作</h3><h3 id="2、微信Hardcoder"><a href="#2、微信Hardcoder" class="headerlink" title="2、微信Hardcoder"></a>2、微信Hardcoder</h3><p>构建了App与系统（ROM）之间可靠的通信框架，让系统知道App的需求。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul>
<li>  1、其实质是让<strong>App跨过Framework直接跟厂商ROM通信</strong>。</li>
<li>  2、分为Client端和Server端，<strong>Server端由厂商系统侧自行实现</strong>。</li>
<li>  3、它们直接采用 <strong>LocalSocket</strong> 方式，Hardcoder是 <strong>Native</strong> 实现的，使用了<strong>Linux的Socket接口</strong>实现了一套自己的LocalSocket。</li>
</ul>
<h4 id="性能提升有多少？"><a href="#性能提升有多少？" class="headerlink" title="性能提升有多少？"></a>性能提升有多少？</h4><p>平均10%~30%。</p>
<h3 id="3、OPPO-Hyper-Boost加速引擎"><a href="#3、OPPO-Hyper-Boost加速引擎" class="headerlink" title="3、OPPO Hyper Boost加速引擎"></a>3、OPPO Hyper Boost加速引擎</h3><p>一种<strong>优化资源调度</strong>的技术。</p>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>让应用程序与系统资源实现实时”双向对话”。当来自应用和游戏程序的<strong>不同场景和用户行为</strong>被Hyper Boost识别后，手机会<strong>智能地匹配到合理的系统资源，让手机SoC的CPU、GPU、ISP、DSP提供的运算资源更加合理地利用</strong>，从而让用户使用手机<strong>更加流畅</strong>。</p>
<h1 id="六、启动优化的常见问题"><a href="#六、启动优化的常见问题" class="headerlink" title="六、启动优化的常见问题"></a>六、启动优化的常见问题</h1><h2 id="1、启动优化是怎么做的？"><a href="#1、启动优化是怎么做的？" class="headerlink" title="1、启动优化是怎么做的？"></a>1、启动优化是怎么做的？</h2><ul>
<li>  <strong>1、分析现状、确认问题</strong></li>
<li>  <strong>2、针对性优化（先概括，引导其深入）</strong></li>
<li>  <strong>3、长期保持优化效果</strong></li>
</ul>
<p>在某一个版本之后呢，我们会发现这个启动速度变得特别慢，同时用户给我们的反馈也越来越多，所以，我们开始考虑对应用的启动速度来进行优化。然后，我们就对启动的代码进行了代码层面的梳理，我们发现应用的启动流程已经非常复杂，接着，我们通过一系列的工具来确认是否在主线程中执行了太多的耗时操作。</p>
<p>我们经过了细查代码之后，发现应用主线程中的任务太多，我们就想了一个方案去针对性地解决，也就是进行异步初始化。（引导=&gt;第2题） 然后，我们还发现了另外一个问题，也可以进行针对性的优化，就是在我们的初始化代码当中有些的优先级并不是那么高，它可以不放在Application的onCreate中执行，而完全可以放在之后延迟执行的，因为我们对这些代码进行了延迟初始化，最后，我们还结合了idealHandler做了一个更优的延迟初始化的方案，利用它可以在主线程的空闲时间进行初始化，以减少启动耗时导致的卡顿现象。做完这些之后，我们的启动速度就变得很快了。</p>
<p>最后，我简单说下我们是怎么长期来保持启动优化的效果的。首先，我们做了我们的启动器，并且结合了我们的CI，在线上加上了很多方面的监控。（引导=&gt; 第4题）</p>
<h2 id="2、是怎么异步的，异步遇到问题没有？"><a href="#2、是怎么异步的，异步遇到问题没有？" class="headerlink" title="2、是怎么异步的，异步遇到问题没有？"></a>2、是怎么异步的，异步遇到问题没有？</h2><ul>
<li>  <strong>1、体现演进过程</strong></li>
<li>  <strong>2、详细介绍启动器</strong></li>
</ul>
<p>我们最初是采用的普通的一个异步的方案，即new Thread + 设置线程优先级为后台线程的方式在Application的onCreate方法中进行异步初始化，后来，我们使用了线程池、IntentService的方式，但是，在我们应用的演进过程当中，发现代码会变得不够优雅，并且有些场景非常不好处理，比如说多个初始化任务直接的依赖关系，比如说某一个初始化任务需要在某一个特定的生命周期中初始化完成，这些都是使用线程池、IntentService无法实现的。所以说，我们就开始思考一个新的解决方案，它能够完美地解决我们刚刚所遇到的这些问题。</p>
<p>这个方案就是我们目前所使用的启动器，在启动器的概念中，我们将每一个初始化代码抽象成了一个Task，然后，对它们进行了一个排序，根据它们之间的依赖关系排了一个有向无环图，接着，使用一个异步队列进行执行，并且这个异步队列它和CPU的核心数是强烈相关的，它能够最大程度地保证我们的主线程和别的线程都能够执行我们的任务，也就是大家几乎都可以同时完成。</p>
<h2 id="3、启动优化有哪些容易忽略的注意点？"><a href="#3、启动优化有哪些容易忽略的注意点？" class="headerlink" title="3、启动优化有哪些容易忽略的注意点？"></a>3、启动优化有哪些容易忽略的注意点？</h2><ul>
<li>  <strong>1、cpu time与wall time</strong></li>
<li>  <strong>2、注意延迟初始化的优化</strong></li>
<li>  <strong>3、介绍下黑科技</strong></li>
</ul>
<p>首先，在CPU Profiler和Systrace中有两个很重要的指标，即cpu time与wall time，我们必须清楚cpu time与wall time之间的区别，wall time指的是代码执行的时间，而cpu time指的是代码消耗CPU的时间，锁冲突会造成两者时间差距过大。我们需要以cpu time来作为我们优化的一个方向。</p>
<p>其次，我们不仅只追求启动速度上的一个提升，也需要注意延迟初始化的一个优化，对于延迟初始化，通常的做法是在界面显示之后才去进行加载，但是如果此时界面需要进行滑动等与用户交互的一系列操作，就会有很严重的卡顿现象，因此我们使用了idealHandler来实现cpu空闲时间来执行耗时任务，这极大地提升了用户的体验，避免了因启动耗时任务而导致的页面卡顿现象。</p>
<p>最后，对于启动优化，还有一些黑科技，首先，就是我们采用了类预先加载的方式，我们在MultiDex.install方法之后起了一个线程，然后用Class.forName的方式来预先触发类的加载，然后当我们这个类真正被使用的时候，就不用再进行类加载的过程了。同时，我们再看Systrace图的时候，有一部分手机其实并没有给我们应用去跑满cpu，比如说它有8核，但是却只给了我们4核等这些情况，然后，有些应用对此做了一些黑科技，它会将cpu的核心数以及cpu的频率在启动的时候去进行一个暴力的提升。</p>
<h2 id="4、版本迭代导致的启动变慢有好的解决方式吗？"><a href="#4、版本迭代导致的启动变慢有好的解决方式吗？" class="headerlink" title="4、版本迭代导致的启动变慢有好的解决方式吗？"></a>4、版本迭代导致的启动变慢有好的解决方式吗？</h2><ul>
<li>  <strong>启动器</strong></li>
<li>  <strong>结合CI</strong></li>
<li>  <strong>监控完善</strong></li>
</ul>
<p>这种问题其实我们之前也遇到过，这的确非常难以解决。但是，我们后面对此进行了反复的思考与尝试，终于找到了一个比较好的解决方式。</p>
<p>首先，我们使用了启动器去管理每一个初始化任务，并且启动器中每一个任务的执行都是被其自动进行分配的，也就是说这些自动分配的task我们会尽量保证它会平均分配在我们每一个线程当中的，这和我们普通的异步是不一样的，它可以很好地缓解我们应用的启动变慢。</p>
<p>其次，我们还结合了CI，比如说，我们现在限制了一些类，如Application，如果有人修改了它，我们不会让这部分代码合并到主干分支或者是修改之后会有一些内部的工具如邮件的形式发送到我，然后，我就会和他确认他加的这些代码到底是耗时多少，能否异步初始化，不能异步的话就考虑延迟初始化，如果初始化时间太长，则可以考虑是否能进行懒加载，等用到的时候再去使用等等。</p>
<p>然后，我们会将问题尽可能地暴露在上线之前。同时，我们真正已经到了线上的一个环境下时，我们进行了监控的一个完善，我们不仅是监控了App的整个的启动时间，同时呢，我们也将每一个生命周期都进行了一个监控。比如说Application的onCreate与onAttachBaseContext方法的耗时，以及这两个生命周期之间间隔的时间，我们都进行了一个监控，如果说下一次我们发现了这个启动速度变慢了，我们就可以去查找到底是哪一个环节变慢了，我们会和以前的版本进行对比，对比完成之后呢，我们就可以来找这一段新加的代码。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h2 id="1、优化总方针"><a href="#1、优化总方针" class="headerlink" title="1、优化总方针"></a>1、优化总方针</h2><ul>
<li>  <strong>异步、延迟、懒加载</strong></li>
<li>  <strong>技术、业务相结合</strong></li>
</ul>
<h2 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h2><h3 id="1、cpu-time-和-wall-time"><a href="#1、cpu-time-和-wall-time" class="headerlink" title="1、cpu time 和 wall time"></a>1、cpu time 和 wall time</h3><ul>
<li>  <strong>wall time（代码执行时间）与cpu time（代码消耗CPU时间），锁冲突会造成这两者时间差距过大</strong>。</li>
<li>  <strong>cpu time才是优化方向，应尽力按照systrace的cpu time和wall time跑满cpu</strong>。</li>
</ul>
<h3 id="2、监控的完善"><a href="#2、监控的完善" class="headerlink" title="2、监控的完善"></a>2、监控的完善</h3><ul>
<li>  线上监控多阶段时间（App、Activity、生命周期间隔时间）。</li>
<li>  处理聚合看趋势。</li>
<li>  收敛启动代码修改权限。</li>
<li>  结合CI修改启动代码需要Review通知。</li>
</ul>
<p>至此，探索Android启动速度优化的旅途也应该告一段落了，如果你耐心读到最后的话，会发现要想极致地提升App的性能，需要有一定的技术广度，如我们<strong>引入了始于后端的AOP编程来实现无侵入式的函数插桩</strong>，也需要有一定的深度，从前面的探索之旅来看，<strong>我们先后涉及了Framework层、Native层、Dalvik虚拟机、甚至是Linux IO和文件系统相关的原理</strong>。因此，我想说，<strong>Android开发并不简单，即使是App层面的性能优化这一知识体系，也是需要我们不断地加深自身知识的深度和广度</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps：在文章的黑科技部分涉及到了许多基础架构研发领域的知识，这部分无法理解的同学不要灰心，先了解即可，</span><br><span class="line">    笔者之后的文章都会一一详细讲解。</span><br></pre></td></tr></table></figure>

<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/73651">Android开发高手课之启动优化</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/672750">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></p>
<p>3、<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/680526">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></p>
<p>4、<a target="_blank" rel="noopener" href="https://github.com/facebook/redex">Facebook Redex字节码优化工具</a></p>
<p>5、<a target="_blank" rel="noopener" href="https://blog.csdn.net/tencent_bugly/article/details/51821722">微信Android热补丁实践演进之路</a></p>
<p>6、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20308548">安卓App热补丁动态修复技术介绍</a></p>
<p>7、<a target="_blank" rel="noopener" href="https://blog.csdn.net/fishmai/article/details/52398485">Dalvik Optimization and Verification With dexopt</a></p>
<p>8、<a target="_blank" rel="noopener" href="https://github.com/Tencent/Hardcoder">微信在Github开源了Hardcoder，对Android开发者有什么影响？</a></p>
<p>9、<a target="_blank" rel="noopener" href="http://mobile.yesky.com/433/311567433.shtml">历时三年研发，OPPO 的 Hyper Boost 引擎如何对系统、游戏和应用实现加速？</a></p>
<p>10、<a target="_blank" rel="noopener" href="https://blog.csdn.net/coder_pig/article/details/80031285">抱歉，Xposed真的可以为所欲为</a></p>
<p>11、<a target="_blank" rel="noopener" href="https://blog.csdn.net/balian8/article/details/53319580">墙上时钟时间 ，用户cpu时间 ，系统cpu时间的理解</a></p>
<p>12、《Android应用性能优化最佳实践》</p>
<p>13、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ">必知必会 | Android 性能优化的方面方面都在这儿</a></p>
<p>14、<a target="_blank" rel="noopener" href="https://coding.imooc.com/class/308.html">极客时间之Top团队大牛带你玩转Android性能分析与优化</a></p>
<p>15、<a target="_blank" rel="noopener" href="https://github.com/zeshaoaaa/LaunchStarter">启动器源码</a></p>
<p>16、<a target="_blank" rel="noopener" href="https://github.com/lanshifu/MultiDexTest">MultiDex优化源码</a></p>
<p>17、<a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter07">使用gradle自动化增加Trace Tag</a></p>
<p>原文作者：jsonchao<br>原文链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/6870457006784774152">https://juejin.im/post/6870457006784774152</a><br>原文来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hzp201314.github.io/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" data-id="ckmc5p3i60003rwufemcacuc8" data-title="Android启动速度优化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/17/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          内存优化
        
      </div>
    </a>
  
  
    <a href="/2021/03/16/%E9%AB%98%E7%BA%A7UI%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%80%A6%E8%AE%BE%E8%AE%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">高级UI组件定制与解耦设计</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" rel="tag">Android架构师</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android%E6%9E%B6%E6%9E%84%E5%B8%88/" style="font-size: 10px;">Android架构师</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/17/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">内存优化</a>
          </li>
        
          <li>
            <a href="/2021/03/16/Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/">Android启动速度优化</a>
          </li>
        
          <li>
            <a href="/2021/03/16/%E9%AB%98%E7%BA%A7UI%E7%BB%84%E4%BB%B6%E5%AE%9A%E5%88%B6%E4%B8%8E%E8%A7%A3%E8%80%A6%E8%AE%BE%E8%AE%A1/">高级UI组件定制与解耦设计</a>
          </li>
        
          <li>
            <a href="/2021/03/15/Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/">Android稳定性优化</a>
          </li>
        
          <li>
            <a href="/2021/03/15/View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">View的绘制流程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Hzp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>